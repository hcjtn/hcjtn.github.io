<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1,user-scalable=no"><meta name="renderer" content="webkit"><meta name="color-scheme" content="dark light"><meta name="author" content="hcj"><meta name="description" content=""><meta name="keywords" content=""><title>5.JVM系列-堆</title><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="//at.alicdn.com/t/font_3242539_utq6ykfq7z.css"><link rel="stylesheet" light-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/github.min.css" dark-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/github-dark.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif" as="font"><link href="/style/index.css" rel="stylesheet"><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="ArcLength" type="application/atom+xml">
</head><body><header class="page-header"><nav><ul class="router-list"><li class="nav-item"> <a href="/">主页</a></li><li class="nav-item"> <a href="/archives/">归档</a></li><li class="nav-item"> <a href="/atom.xml">RSS</a></li></ul><div class="mode-switch"><span class="iconfont icon-DarkTheme"></span></div></nav></header><main><section class="main-content"><section class="post-page"><div class="title-bar"><h1>5.JVM系列-堆</h1><div class="post-info"><span>2023-03-25 17:21:28</span><span class="tags"><a href="/tags/JVM/">#JVM</a></span></div></div><article> <div class="content"><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><ol>
<li>HotSpot虚拟机上，所有的对象实例都是创建在堆上。</li>
</ol>
<h2 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h2><p>s0和s1满并不会触发GC回收器 当Eden区域满的事后就会自动将的from区的内容复制到to区去</p>
<p><strong>线程安全问题</strong>：我们可以看到，这里出现了两个26，为什么会出现这种情况，出现这种情况显然表明我们这个方法根本就不是线程安全的，出现这种问题的原因有很多，我们说最常见的一种，就是我们A线程在进入方法后，拿到了count的值，刚把这个值读取出来还没有改变count的值的时候，结果线程B也进来的，那么导致线程A和线程B拿到的count值是一样的。</p>
<h3 id="堆与进程"><a href="#堆与进程" class="headerlink" title="堆与进程"></a>堆与进程</h3><p>一个进程对应一个jvm实例 一个jvm实例使用一个运行时数据区</p>
<ol>
<li>堆针对一个JVM进程来说是唯一的。也就是<strong>一个进程只有一个JVM实例</strong>，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。</li>
<li>但是<span style="color:red"><strong>进程包含多个线程，他们是共享同一堆空间的</strong>。</span></li>
</ol>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0001.png"">



<ol>
<li><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>
</li>
<li><p><strong>Java堆区在JVM启动的时候即被创建</strong>，其空间大小也就确定了，堆是JVM管理的最大一块内存空间</p>
<blockquote>
<p>堆内存的大小是可以调节的。</p>
</blockquote>
</li>
<li><p>《Java虚拟机规范》规定，<span style="color:red">堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的</span>。</p>
<blockquote>
<p>逻辑上连续  实现上简单 直接分配一块连续空间 ，存储高效 执行的放一起。</p>
<p>物理上不连续 涉及到虚拟内存的问题  </p>
<p>这里涉及到对象实例在堆内存中的存储方式，物理内存连续的采用指针碰撞，不连续的采用动态列表</p>
</blockquote>
</li>
<li><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，<strong>TLAB</strong>）。</p>
<blockquote>
<p>tlab 如果所有的线程都共享同一个数据文件 势必会发生线程安全问题 可以使用他同步锁解决线程问题 但并发性很差 ，所以在堆空间中会划分出许多小空间 为每个线程分配一个空间 就是 TLAB</p>
</blockquote>
</li>
<li><p>《Java虚拟机规范》中对Java堆的描述是：**<span style="color:red">所有的对象实例</span>以及数组都应当在运行时分配在堆上**。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>
<ul>
<li>从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li>
</ul>
</li>
<li><p>数组和对象可能永远不会存储在栈上（<strong>不一定</strong>），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
</li>
<li><p><strong>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</strong></p>
<ul>
<li>也就是触发了GC的时候，才会进行回收</li>
<li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li>
</ul>
</li>
<li><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p>
</li>
</ol>
<blockquote>
<p>随着JVM的迭代升级，原来一些绝对的事情，在后续版本中也开始有了特例，变的不再那么绝对。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleHeap</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<span class="hljs-comment">//属性、成员变量</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;
        <span class="hljs-built_in">this</span>.id = id;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-string">&quot;My ID is &quot;</span> + id);
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">SimpleHeap</span> <span class="hljs-variable">sl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleHeap</span>(<span class="hljs-number">1</span>);
        <span class="hljs-type">SimpleHeap</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleHeap</span>(<span class="hljs-number">2</span>);

        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];

        Object[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];
    &#125;
&#125;</code></pre>

<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0002.png"">



<h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><blockquote>
<p>新生区&lt;&#x3D;&gt;新生代&lt;&#x3D;&gt;年轻代     养老区&lt;&#x3D;&gt;老年区 &lt;&#x3D;&gt;老年代      永久区&lt;&#x3D;&gt;永久代</p>
</blockquote>
<p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p>
<ol>
<li>Java7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区<ul>
<li>Young Generation Space    新生区      Young&#x2F;New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Old generation space    养老区           Old&#x2F;Tenure</li>
<li>Permanent Space   永久区                   Perm</li>
</ul>
</li>
<li>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间<ul>
<li>Young Generation Space 新生区，又被划分为Eden区和Survivor区</li>
<li>Old generation space 养老区</li>
<li>Meta Space 元空间 Meta</li>
</ul>
</li>
</ol>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0003.png"">



<ol start="2">
<li>堆空间内部结构，JDK1.8之前从永久代 替换成 元空间</li>
</ol>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0004.png"">



<h2 id="JVisualVM可视化查看堆内存"><a href="#JVisualVM可视化查看堆内存" class="headerlink" title="JVisualVM可视化查看堆内存"></a>JVisualVM可视化查看堆内存</h2><p>运行下面代码</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapDemo</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        System.out.println(<span class="hljs-string">&quot;start...&quot;</span>);
        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.MINUTES.sleep(<span class="hljs-number">30</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        System.out.println(<span class="hljs-string">&quot;end...&quot;</span>);
    &#125;

&#125;</code></pre>



<p>1、双击jdk目录下的这个文件</p>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0005.png"">



<p>2、工具 -&gt; 插件 -&gt; 安装Visual GC插件</p>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0006.png"">

<p>3、运行上面的代码</p>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0007.png"">



<h2 id="设置堆内存大小与-OOM"><a href="#设置堆内存大小与-OOM" class="headerlink" title="设置堆内存大小与 OOM"></a>设置堆内存大小与 OOM</h2><h3 id="设置堆内存"><a href="#设置堆内存" class="headerlink" title="设置堆内存"></a>设置堆内存</h3><ol>
<li><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置。</p>
<ul>
<li><strong>-Xms</strong>用于表示堆区的起始内存  用来设置堆空间(年轻代+老年代)初始内存大小，等价于**-XX:InitialHeapSize**</li>
<li><strong>-Xmx</strong>则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**</li>
</ul>
</li>
<li><p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</p>
</li>
<li><p>通常会将-Xms和-Xmx两个参数配置相同的值</p>
</li>
</ol>
<ul>
<li>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。</li>
<li>如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM</li>
</ul>
<ol start="4">
<li><p>默认情况下:</p>
<ul>
<li>初始内存大小：物理电脑内存大小&#x2F;64</li>
<li>最大内存大小：物理电脑内存大小&#x2F;4</li>
</ul>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 1. 设置堆空间大小的参数</span>
<span class="hljs-comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span>
<span class="hljs-comment"> *      -X 是jvm的运行参数</span>
<span class="hljs-comment"> *      ms 是memory start</span>
<span class="hljs-comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 2. 默认堆空间的大小</span>
<span class="hljs-comment"> *    初始内存大小：物理电脑内存大小 / 64</span>
<span class="hljs-comment"> *             最大内存大小：物理电脑内存大小 / 4</span>
<span class="hljs-comment"> * 3. 手动设置：-Xms600m -Xmx600m</span>
<span class="hljs-comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span>
<span class="hljs-comment"> *                  方式二：-XX:+PrintGCDetails</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSpaceInitial</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;

        <span class="hljs-comment">//返回Java虚拟机中的堆内存总量</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">initialMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;
        <span class="hljs-comment">//返回Java虚拟机试图使用的最大堆内存量</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;

        System.out.println(<span class="hljs-string">&quot;-Xms : &quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);

        System.out.println(<span class="hljs-string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="hljs-number">64.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="hljs-number">4.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);

        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">1000000</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>

<p>输出结果：</p>
<pre><code class="hljs java">-Xms : 123M
-Xmx : 1794M
系统内存大小为：<span class="hljs-number">7.</span>6875G
系统内存大小为：<span class="hljs-number">7.</span>0078125G</code></pre>

<p>两个不一样的原因待会再说</p>
<p>设置下参数再看</p>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0008.png"">

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSpaceInitial</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;

        <span class="hljs-comment">//返回Java虚拟机中的堆内存总量</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">initialMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;
        <span class="hljs-comment">//返回Java虚拟机试图使用的最大堆内存量</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;

        System.out.println(<span class="hljs-string">&quot;-Xms : &quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);


        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">1000000</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>

<p>输出结果：</p>
<pre><code class="hljs java">-Xms : 575M
-Xmx : 575M</code></pre>

<p>为什么会少25M</p>
<p><strong>方式一： jps   &#x2F;  jstat -gc 进程id</strong></p>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0009.png"">

<blockquote>
<p>jps：查看java进程</p>
<p>jstat：查看某进程内存使用情况</p>
</blockquote>
<pre><code class="hljs java">SOC: S0区总共容量
S1C: S1区总共容量
S0U: S0区使用的量
S1U: S1区使用的量
EC: 伊甸园区总共容量
EU: 伊甸园区使用的量
OC: 老年代总共容量
OU: 老年代使用的量</code></pre>

<p>1、</p>
<p>25600+25600+153600+409600 &#x3D; 614400K</p>
<p>614400 &#x2F;1024 &#x3D; 600M</p>
<p>2、</p>
<p>25600+153600+409600 &#x3D; 588800K</p>
<p>588800 &#x2F;1024 &#x3D; 575M</p>
<p>3、</p>
<p>并非巧合，S0区和S1区两个只有一个能使用，另一个用不了（后面会详解）</p>
<p> <strong>方式二：-XX:+PrintGCDetails</strong></p>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0010.png"">



<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMTest</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        ArrayList&lt;Picture&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;
            <span class="hljs-keyword">try</span> &#123;
                Thread.sleep(<span class="hljs-number">20</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Picture</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)));
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Picture</span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] pixels;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Picture</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span> &#123;
        <span class="hljs-built_in">this</span>.pixels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];
    &#125;
&#125;</code></pre>

<p>1、设置虚拟机参数</p>
<p><code>-Xms600m -Xmx600m</code></p>
<p>最终输出结果：</p>
<pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space
	at com.atguigu.java.Picture.&lt;init&gt;(OOMTest.java:<span class="hljs-number">29</span>)
	at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="hljs-number">20</span>)

Process finished with exit code <span class="hljs-number">1</span></code></pre>



<p>2、堆内存变化图</p>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0011.png"">

<p>3、原因：大对象导致堆内存溢出</p>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0012.png"">



<h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>1、存储在JVM中的Java对象可以被划分为两类：</p>
<pre><code>- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致
</code></pre>
<p>2、Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>
<p>3、其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p>
<blockquote>
<p>谁空谁是to区</p>
</blockquote>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0013.png"">

<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0014.png"">

<ul>
<li><p>配置新生代与老年代在堆结构的占比</p>
<ul>
<li><p>默认**-XX:NewRatio**&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p>
</li>
<li><p>可以修改**-XX:NewRatio**&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，</p>
</li>
<li><p>当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio&#x3D;8</p>
</li>
<li><p>几乎所有的Java对象都是在Eden区被new出来的。</p>
</li>
<li><p>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>
</li>
<li><p>可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</p>
</li>
</ol>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0015.png"">



<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * -Xms600m -Xmx600m</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.</span>
<span class="hljs-comment"> * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8</span>
<span class="hljs-comment"> * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）</span>
<span class="hljs-comment"> * -Xmn:设置新生代的空间的大小。 （一般不设置）</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart  shkstart@126.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020  17:23</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EdenSurvivorTest</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        System.out.println(<span class="hljs-string">&quot;我只是来打个酱油~&quot;</span>);
        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">1000000</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>



<h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<p><strong>具体过程</strong></p>
<ol>
<li>new的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>
<li>啥时候能去养老区呢？可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：**-XX:MaxTenuringThreshold**&#x3D;N 进行设置</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li>
<li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li>
</ol>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0019.png"">

<h3 id="图解对象分配（一般情况）"><a href="#图解对象分配（一般情况）" class="headerlink" title="图解对象分配（一般情况）"></a>图解对象分配（一般情况）</h3><p>1、我们创建的对象，一般都是存放在Eden区的，<strong>当我们Eden区满了后，就会触发GC操作</strong>，一般被称为 YGC &#x2F; Minor GC操作</p>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0016.png"">

<p>2、当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</p>
<p>3、同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To（S1）区，同时让存活的对象年龄 + 1</p>
<blockquote>
<p>下一次再进行GC的时候，</p>
<p>1、这一次的s0区为空，所以成为下一次GC的S1区</p>
<p>2、这一次的s1区则成为下一次GC的S0区</p>
<p>3、也就是说s0区和s1区在互相转换。</p>
</blockquote>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0017.png"">

<p>4、我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中</p>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0018.png"">

<p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</p>
<h3 id="特殊情况说明"><a href="#特殊情况说明" class="headerlink" title="特殊情况说明"></a>特殊情况说明</h3><p><strong>对象分配的特殊情况</strong></p>
<ol>
<li>如果来了一个新对象，先看看 Eden 是否放的下？<ul>
<li>如果 Eden 放得下，则直接放到 Eden 区</li>
<li>如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？</li>
</ul>
</li>
<li>将对象放到老年区又有两种情况：<ul>
<li>如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代</li>
<li>那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM</li>
</ul>
</li>
<li>如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区</li>
</ol>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0019.png"">

<h3 id="常用调优工具"><a href="#常用调优工具" class="headerlink" title="常用调优工具"></a>常用调优工具</h3><ol>
<li>JDK命令行</li>
<li>Eclipse：Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>Visual VM（实时监控，推荐）</li>
<li>Jprofiler（IDEA插件）</li>
<li>Java Flight Recorder（实时监控）</li>
<li>GCViewer</li>
<li>GCEasy</li>
</ol>
<h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><ol>
<li><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，<strong>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</strong></p>
<blockquote>
<p>Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>
</blockquote>
</li>
<li><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>
</li>
</ol>
<ul>
<li><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li><strong>新生代收集</strong>（Minor GC&#x2F;Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</li>
<li><strong>老年代收集</strong>（Major GC&#x2F;Old GC）：只是老年代的圾收集。</li>
<li>目前，只有CMS GC会有单独收集老年代的行为。</li>
<li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li>
</ul>
</li>
<li><p><strong>整堆收集</strong>（Full GC）：收集整个java堆和方法区的垃圾收集。</p>
</li>
</ul>
<blockquote>
<p>由于历史原因，外界各种解读，majorGC和Full GC有些混淆。</p>
</blockquote>
<h3 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h3><p><strong>年轻代 GC（Minor GC）触发机制</strong></p>
<ol>
<li><p>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满。Survivor满不会主动引发GC，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）</p>
</li>
<li><p>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>
</li>
<li><p>Minor GC会引发STW（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p>
</li>
</ol>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0020.png"">



<h3 id="Major-Full-GC"><a href="#Major-Full-GC" class="headerlink" title="Major&#x2F;Full GC"></a>Major&#x2F;Full GC</h3><blockquote>
<p>Full GC有争议，后续详解两者区别，暂时先看着</p>
</blockquote>
<p><strong>老年代GC（MajorGC）触发机制</strong></p>
<ol>
<li><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p>
</li>
<li><p>出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p>
<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC（哈？我有点迷？），如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li><p>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</p>
</li>
<li><p>如果Major GC后，内存还不足，就报OOM了</p>
</li>
</ol>
<p><strong>Full GC 触发机制（后面细讲）</strong></p>
<p><strong>触发Full GC执行的情况有如下五种：</strong></p>
<ol>
<li>调用System.gc()时，系统建议执行FullGC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ol>
<p>说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些</p>
<h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 测试MinorGC 、 MajorGC、FullGC</span>
<span class="hljs-comment"> * -Xms9m -Xmx9m -XX:+PrintGCDetails</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart  shkstart@126.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020  14:19</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCTest</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> &#123;
            List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
            <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.com&quot;</span>;
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
                list.add(a);
                a = a + a;
                i++;
            &#125;

        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
            t.printStackTrace();
            System.out.println(<span class="hljs-string">&quot;遍历次数为：&quot;</span> + i);
        &#125;
    &#125;
&#125;
</code></pre>

<p>输出：</p>
<pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="hljs-number">0.0455865</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.06</span> secs] 
[GC (Allocation Failure) [PSYoungGen: 2246K-&gt;496K(2560K)] 2470K-&gt;1506K(9728K), <span class="hljs-number">0.0009094</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] 
[GC (Allocation Failure) [PSYoungGen: 2294K-&gt;488K(2560K)] 3305K-&gt;2210K(9728K), <span class="hljs-number">0.0009568</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] 
[GC (Allocation Failure) [PSYoungGen: 1231K-&gt;488K(2560K)] 7177K-&gt;6434K(9728K), <span class="hljs-number">0.0005594</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] 
[GC (Allocation Failure) [PSYoungGen: 488K-&gt;472K(2560K)] 6434K-&gt;6418K(9728K), <span class="hljs-number">0.0005890</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] 
[Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(Allocation Failure)</span> [PSYoungGen: 472K-&gt;0K(2560K)] [ParOldGen: 5946K-&gt;4944K(7168K)] 6418K-&gt;4944K(9728K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="hljs-number">0.0045270</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] 
[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 4944K-&gt;4944K(8704K), <span class="hljs-number">0.0004954</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] 
[Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(Allocation Failure)</span> java.lang.OutOfMemoryError: Java heap space
	at java.util.Arrays.copyOf(Arrays.java:<span class="hljs-number">3332</span>)
	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="hljs-number">124</span>)
	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="hljs-number">448</span>)
	at java.lang.StringBuilder.append(StringBuilder.java:<span class="hljs-number">136</span>)
	at com.atguigu.java1.GCTest.main(GCTest.java:<span class="hljs-number">20</span>)
[PSYoungGen: 0K-&gt;0K(1536K)] [ParOldGen: 4944K-&gt;4877K(7168K)] 4944K-&gt;4877K(8704K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="hljs-number">0.0076061</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.02</span>, real=<span class="hljs-number">0.01</span> secs] 
遍历次数为：<span class="hljs-number">16</span>
Heap
 PSYoungGen      total 1536K, used 60K [<span class="hljs-number">0x00000000ffd00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)
  eden space 1024K, <span class="hljs-number">5</span>% used [<span class="hljs-number">0x00000000ffd00000</span>,<span class="hljs-number">0x00000000ffd0f058</span>,<span class="hljs-number">0x00000000ffe00000</span>)
  from space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x0000000100000000</span>)
  to   space 1024K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ffe00000</span>,<span class="hljs-number">0x00000000ffe00000</span>,<span class="hljs-number">0x00000000fff00000</span>)
 ParOldGen       total 7168K, used 4877K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ffd00000</span>, <span class="hljs-number">0x00000000ffd00000</span>)
  object space 7168K, <span class="hljs-number">68</span>% used [<span class="hljs-number">0x00000000ff600000</span>,<span class="hljs-number">0x00000000ffac3408</span>,<span class="hljs-number">0x00000000ffd00000</span>)
 Metaspace       used 3525K, capacity 4502K, committed 4864K, reserved 1056768K
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 391K, capacity 394K, committed 512K, reserved 1048576K</code></pre>



<pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="hljs-number">0.0455865</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.06</span> secs] 
</code></pre>



<ul>
<li><p>[PSYoungGen: 2037K-&gt;504K(2560K)]：年轻代总空间为 2560K ，当前占用 2037K ，经过垃圾回收后剩余504K</p>
</li>
<li><p>2037K-&gt;728K(9728K)：堆内存总空间为 9728K ，当前占用2037K ，经过垃圾回收后剩余728K</p>
</li>
</ul>
<h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p>为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<ul>
<li>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to或s0&#x2F;s1）构成，to总为空。</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象。</li>
</ul>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0021.png"">



<p>其实不分代完全可以，分代的唯一理由就是优化GC性能。</p>
<ul>
<li>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。（性能低）</li>
</ul>
<ul>
<li>而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）</li>
</ul>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0022.png"">



<h2 id="对象内存分配策略"><a href="#对象内存分配策略" class="headerlink" title="对象内存分配策略"></a>对象内存分配策略</h2><ol>
<li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。</li>
<li>对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</li>
<li>对象晋升老年代的年龄阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置</li>
</ol>
<p><strong>针对不同年龄段的对象分配原则如下所示：</strong></p>
<ol>
<li><strong>优先分配到Eden</strong>：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li>
<li><strong>大对象直接分配到老年代</strong>：尽量避免程序中出现过多的大对象</li>
<li><strong>长期存活的对象分配到老年代</strong></li>
<li><strong>动态对象年龄判断</strong>：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li>
<li><strong>空间分配担保</strong>： -XX:HandlePromotionFailure 。</li>
<li>如果对象过大，比eden空间的分配内存大小还要大，那么s1 s0 空间也必然不足，对象会直接进入老年代，不会经过YGC的垃圾回收</li>
</ol>
<blockquote>
<p>一些细节放在后面说</p>
</blockquote>
<h2 id="TLAB为对象分配内存（保证线程安全）"><a href="#TLAB为对象分配内存（保证线程安全）" class="headerlink" title="TLAB为对象分配内存（保证线程安全）"></a>TLAB为对象分配内存（保证线程安全）</h2><h3 id="为什么有-TLAB"><a href="#为什么有-TLAB" class="headerlink" title="为什么有 TLAB"></a>为什么有 TLAB</h3><ol start="2">
<li><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p>
</li>
<li><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>
</li>
<li><p>为避免多个线程操作同一地址，需要使用<strong>加锁等机制</strong>，进而影响分配速度。</p>
<blockquote>
<p>至于为什么内存分配需要加锁，很简单，因为多线程可能竞争一块内存空间，而那一块内存只能分配给一个对象，加锁是乐观锁了,CAS+失败重试，提高性能，由此可见TLAB对性能提高更大 TLAB中的对象并不是私有的，这个技术只是为了解决在对给对象分配内存的时候，不需要加锁，普通的EDEN区分配是需要加锁的 TLAB在EDEN中，是可以被其它所有线程访问的，GC的时候也会被回收</p>
</blockquote>
</li>
</ol>
<h3 id="什么是-TLAB"><a href="#什么是-TLAB" class="headerlink" title="什么是 TLAB"></a>什么是 TLAB</h3><p>TLAB（Thread Local Allocation Buffer）</p>
<ol>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong>。</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li>
<li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ol>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0023.png"">

<p>1、每个线程都有一个TLAB空间</p>
<p>2、当一个线程的TLAB存满时，可以使用公共区域（蓝色）的</p>
<h3 id="TLAB再说明"><a href="#TLAB再说明" class="headerlink" title="TLAB再说明"></a>TLAB再说明</h3><ol>
<li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</p>
</li>
<li><p>在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。</p>
</li>
<li><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“**-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。</p>
</li>
<li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存。</p>
</li>
</ol>
<blockquote>
<p>1、哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，<strong>分配新的缓存区时才需要同步锁定</strong>                   —-这是《深入理解JVM》–第三版里说的</p>
<p>2、和这里讲的有点不同。我猜测说的意思是某一次分配，如果TLAB用完了，那么<strong>这一次</strong>先在Eden区直接分配。空闲下来后再加锁分配新的TLAB（TLAB内存较大，分配时间应该较长）</p>
<p>3、堆空间不都是共享的 存在tlab这样的私有空间</p>
</blockquote>
<p><strong>TLAB 分配过程</strong></p>
<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="\chapter_005\0024.png"">



<h2 id="堆空间参数设置"><a href="#堆空间参数设置" class="headerlink" title="堆空间参数设置"></a>堆空间参数设置</h2><h3 id="常用参数设置"><a href="#常用参数设置" class="headerlink" title="常用参数设置"></a>常用参数设置</h3><blockquote>
<p><strong>官方文档</strong>：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p>
<p>我们只说常用的</p>
</blockquote>
<pre><code class="hljs java">* 测试堆空间常用的jvm参数：
* -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值
* -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）
*      具体查看某个参数的指令： jps：查看当前运行中的进程
*                             jinfo -flag SurvivorRatio 进程id
*
* -Xms：初始堆空间内存 （默认为物理内存的<span class="hljs-number">1</span>/<span class="hljs-number">64</span>）
* -Xmx：最大堆空间内存（默认为物理内存的<span class="hljs-number">1</span>/<span class="hljs-number">4</span>）
* -Xmn：设置新生代的大小。(初始值及最大值)
* -XX:NewRatio：配置新生代与老年代在堆结构的占比
    	新生代区域过小，导致YGC频繁调用 占用用户线程 导致STW总体时间变多
* -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例
   	Eden区域过大 意味着s0和s1区域过小，很容易发生s1和s0区域无法存放类 只能直接将类存放到老年代中使得MinorGC数去意义
* -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄  默认<span class="hljs-number">15</span>
* -XX:+PrintGCDetails：输出详细的GC处理日志
* 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc
* -XX:HandlePromotionFailure：是否设置空间分配担保
</code></pre>



<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>1、在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p>
<ul>
<li><p>如果大于，则此次Minor GC是安全的</p>
</li>
<li><p>如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。</p>
<ul>
<li>如果HandlePromotionFailure&#x3D;true，那么会继续检查<strong>老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>
<li>如果小于，则进行一次Full GC。</li>
</ul>
</li>
<li>如果HandlePromotionFailure&#x3D;false，则进行一次Full GC。</li>
</ul>
</li>
</ul>
<p><strong>历史版本</strong></p>
<ol>
<li>在JDK6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。</li>
<li>JDK6 Update 24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC</strong>，否则将进行Full GC。即 HandlePromotionFailure&#x3D;true</li>
</ol>
<h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><p><strong>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</strong></p>
<ol>
<li><p>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
</li>
<li><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<blockquote>
<p>没有发生逃逸对象分析的对象 可以分配到栈上 随着方法的结束栈空间被移除</p>
</blockquote>
</li>
<li><p>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
</li>
</ol>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><ol>
<li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li>
<li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li>
<li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li>
<li>逃逸分析的基本行为就是分析对象动态作用域：<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
</ol>
<p><strong>逃逸分析举例</strong></p>
<p>1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">my_method</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">V</span>();
    <span class="hljs-comment">// use v</span>
    <span class="hljs-comment">// ....</span>
    v = <span class="hljs-literal">null</span>;
&#125;</code></pre>



<p>2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;
    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();
    sb.append(s1);
    sb.append(s2);
    <span class="hljs-keyword">return</span> sb;
&#125;</code></pre>



<p>3、如果想要StringBuffer sb不发生逃逸，可以这样写</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;
    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();
    sb.append(s1);
    sb.append(s2);
    <span class="hljs-keyword">return</span> sb.toString();
&#125;</code></pre>



<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 逃逸分析</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EscapeAnalysis</span> &#123;

    <span class="hljs-keyword">public</span> EscapeAnalysis obj;

    <span class="hljs-comment">/*</span>
<span class="hljs-comment">    方法返回EscapeAnalysis对象，发生逃逸</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">public</span> EscapeAnalysis <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-keyword">return</span> obj == <span class="hljs-literal">null</span>? <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>() : obj;
    &#125;
    <span class="hljs-comment">/*</span>
<span class="hljs-comment">    为成员属性赋值，发生逃逸</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObj</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-built_in">this</span>.obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();
    &#125;
    <span class="hljs-comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span>

    <span class="hljs-comment">/*</span>
<span class="hljs-comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();
    &#125;
    <span class="hljs-comment">/*</span>
<span class="hljs-comment">    引用成员变量的值，发生逃逸</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis1</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> getInstance();
        <span class="hljs-comment">//getInstance().xxx()同样会发生逃逸 </span>
        <span class="hljs-comment">// 关心得对象实体 在getInstance()里面存在隐藏得this.obj = new EscapeAnalysis()；</span>
    &#125;
&#125;</code></pre>



<p><strong>逃逸分析参数设置</strong></p>
<ol>
<li><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p>
</li>
<li><p>如果使用的是较早的版本，开发人员则可以通过：</p>
<ul>
<li>选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析</li>
<li>通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>开发中能使用局部变量的，就不要使用在方法外定义。</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ol>
<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>
<li><strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>
</ol>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ol>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有<strong>逃逸出方法</strong>的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li>
<li>常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li>
</ol>
<p><strong>栈上分配举例</strong></p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 栈上分配测试</span>
<span class="hljs-comment"> * -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackAllocation</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;
            alloc();
        &#125;
        <span class="hljs-comment">// 查看执行时间</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        System.out.println(<span class="hljs-string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);
        <span class="hljs-comment">// 为了方便查看堆内存中对象个数，线程sleep</span>
        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">1000000</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e1) &#123;
            e1.printStackTrace();
        &#125;
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<span class="hljs-comment">//未发生逃逸</span>
    &#125;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;

    &#125;
&#125;</code></pre>

<p>输出结果：</p>
<pre><code class="hljs plaintext">[GC (Allocation Failure) [PSYoungGen: 33280K-&gt;808K(38400K)] 33280K-&gt;816K(125952K), 0.0483350 secs] [Times: user=0.00 sys=0.00, real=0.06 secs] 
[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;808K(38400K)] 34096K-&gt;816K(125952K), 0.0008411 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;792K(38400K)] 34096K-&gt;800K(125952K), 0.0008427 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 34072K-&gt;808K(38400K)] 34080K-&gt;816K(125952K), 0.0012223 secs] [Times: user=0.08 sys=0.00, real=0.00 secs] 
花费的时间为： 114 ms</code></pre>





<p>1、JVM 参数设置</p>
<p>-Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</p>
<p>2、日志打印：发生了 GC ，耗时 114ms</p>
<p><strong>开启逃逸分析的情况</strong></p>
<p>输出结果：</p>
<pre><code class="hljs plaintext">花费的时间为： 5 ms</code></pre>

<p>1、参数设置</p>
<p>-Xmx128m -Xms128m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</p>
<p>2、日志打印：并没有发生 GC ，耗时5ms 。</p>
<h3 id="同步省略（同步消除）"><a href="#同步省略（同步消除）" class="headerlink" title="同步省略（同步消除）"></a>同步省略（同步消除）</h3><ol>
<li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
</li>
<li><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。</p>
</li>
<li><p>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个<strong>取消同步的过程就叫同步省略，也叫锁消除</strong>。</p>
</li>
</ol>
<p>例如下面的代码</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-type">Object</span> <span class="hljs-variable">hollis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
    <span class="hljs-keyword">synchronized</span>(hollis) &#123;
        System.out.println(hollis);
    &#125;
&#125;</code></pre>

<p>代码中对hollis这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-type">Object</span> <span class="hljs-variable">hellis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
	System.out.println(hellis);
&#125;</code></pre>



<p><strong>字节码分析</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">Object</span> <span class="hljs-variable">hollis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
        <span class="hljs-keyword">synchronized</span>(hollis) &#123;
            System.out.println(hollis);
        &#125;
    &#125;
&#125;</code></pre>



<pre><code class="hljs java"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java/lang/Object&gt;
 <span class="hljs-number">3</span> dup
 <span class="hljs-number">4</span> invokespecial #<span class="hljs-number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;
 <span class="hljs-number">7</span> astore_1
 <span class="hljs-number">8</span> aload_1
 <span class="hljs-number">9</span> dup
<span class="hljs-number">10</span> astore_2
<span class="hljs-number">11</span> monitorenter
<span class="hljs-number">12</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;
<span class="hljs-number">15</span> aload_1
<span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;
<span class="hljs-number">19</span> aload_2
<span class="hljs-number">20</span> monitorexit
<span class="hljs-number">21</span> goto <span class="hljs-number">29</span> (+<span class="hljs-number">8</span>)
<span class="hljs-number">24</span> astore_3
<span class="hljs-number">25</span> aload_2
<span class="hljs-number">26</span> monitorexit
<span class="hljs-number">27</span> aload_3
<span class="hljs-number">28</span> athrow
<span class="hljs-number">29</span> <span class="hljs-keyword">return</span></code></pre>

<p>注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，<strong>同步省略操作是在解释运行时发生的</strong></p>
<h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p><strong>分离对象或标量替换</strong></p>
<ol>
<li>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li>
<li>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li>
<li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</li>
</ol>
<p>重点关注标量替换和栈上分配 这两个的触发条件一样 ，都是外界没有进行访问方法内的数据，标量替换是将集合聚合量替换成标量，栈上分配是将对象存储到栈上。</p>
<p><strong>标量替换举例</strong></p>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;
    alloc();
&#125;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-type">Point</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
    System.out.println(<span class="hljs-string">&quot;point.x&quot;</span> + point.x + <span class="hljs-string">&quot;;point.y&quot;</span> + point.y);
&#125;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> y;
&#125;</code></pre>



<p>以上代码，经过标量替换后，就会变成</p>
<pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;
    System.out.println(<span class="hljs-string">&quot;point.x = &quot;</span> + x + <span class="hljs-string">&quot;; point.y=&quot;</span> + y);
&#125;</code></pre>



<ol>
<li>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。</li>
<li>那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</li>
<li>标量替换为栈上分配提供了很好的基础。</li>
</ol>
<p><strong>标量替换参数设置</strong></p>
<p>参数 -XX:+ElimilnateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p>
<p><strong>代码示例</strong></p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 标量替换测试</span>
<span class="hljs-comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart  shkstart@126.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020  12:01</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScalarReplace</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;
        <span class="hljs-keyword">public</span> String name;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<span class="hljs-comment">//未发生逃逸</span>
        u.id = <span class="hljs-number">5</span>;
        u.name = <span class="hljs-string">&quot;www.atguigu.com&quot;</span>;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;
            alloc();
        &#125;
        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        System.out.println(<span class="hljs-string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);
    &#125;
&#125;</code></pre>



<p><strong>未开启标量替换</strong></p>
<p>1、JVM 参数</p>
<p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</p>
<p>2、日志</p>
<pre><code class="hljs java">[GC (Allocation Failure)  25600K-&gt;880K(98304K), <span class="hljs-number">0.0012658</span> secs]
[GC (Allocation Failure)  26480K-&gt;832K(98304K), <span class="hljs-number">0.0012124</span> secs]
[GC (Allocation Failure)  26432K-&gt;784K(98304K), <span class="hljs-number">0.0009719</span> secs]
[GC (Allocation Failure)  26384K-&gt;832K(98304K), <span class="hljs-number">0.0009071</span> secs]
[GC (Allocation Failure)  26432K-&gt;768K(98304K), <span class="hljs-number">0.0010643</span> secs]
[GC (Allocation Failure)  26368K-&gt;824K(101376K), <span class="hljs-number">0.0012354</span> secs]
[GC (Allocation Failure)  32568K-&gt;712K(100864K), <span class="hljs-number">0.0011291</span> secs]
[GC (Allocation Failure)  32456K-&gt;712K(100864K), <span class="hljs-number">0.0006368</span> secs]
花费的时间为： <span class="hljs-number">99</span> ms</code></pre>



<p><strong>开启标量替换</strong></p>
<p>1、JVM 参数</p>
<p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</p>
<p>2、日志：时间减少很多，且无GC</p>
<pre><code class="hljs plaintext">花费的时间为： 6 ms</code></pre>





<p>上述代码在主函数中调用了1亿次alloc()方法，进行对象创建由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>
<p><code>-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></p>
<p>这里设置参数如下：</p>
<ol>
<li>参数 -server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li>
<li>参数 -XX:+DoEscapeAnalysis：启用逃逸分析</li>
<li>参数 -Xmx10m：指定了堆空间最大为10MB</li>
<li>参数 -XX:+PrintGC：将打印GC日志。</li>
<li>参数 -XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>
</ol>
<h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><ol>
<li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li>
<li>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li>
<li>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li>
<li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，<strong>Oracle Hotspot JVM中并未这么做</strong>（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，<strong>所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上</strong>。</li>
<li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，<strong>所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</strong>。</li>
</ol>
<blockquote>
<p><strong>堆是分配对象的唯一选择么？ 不是 但是hotspot中确实是所有的对象都在堆上</strong></p>
</blockquote>
<p>综上：<strong>对象实例都是分配在堆上</strong>。What the fuck？</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
</li>
<li><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。</p>
</li>
<li><p>当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；</p>
</li>
<li><p>如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；</p>
</li>
<li><p>如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</p>
</li>
<li><p>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</p>
</li>
<li><p>当GC发生在老年代时则被称为Major GC或者Full GC。</p>
</li>
<li><p>一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>
</li>
</ol>
</div></article><div class="copyright-wrapper"><p>原文作者:<a href="http://example.com">hcj</a></p><p>原文链接:<a href="http://example.com/2023/03/25/5-JVM%E7%B3%BB%E5%88%97-%E5%A0%86/">5.JVM系列-堆</a></p><p>发表日期: 2023-03-25 17:21:28</p><p>更新日期: 2024-03-29 21:34:34</p><p>版权声明: 本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class="post-pager"><div class="prev"><a href="/2023/03/31/6-JVM%E7%B3%BB%E5%88%97-%E6%96%B9%E6%B3%95%E5%8C%BA/" title="6.JVM系列-方法区">上一篇 6.JVM系列-方法区</a></div><div class="next"> <a href="/2023/03/21/4-JVM%E7%B3%BB%E5%88%97-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/" title="4.JVM系列-虚拟机栈">下一篇 4.JVM系列-虚拟机栈</a></div></div></section></section></main><footer class="footer-page"><div><span>Powered by</span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a><span>| Theme</span><a target="_blank" rel="noopener" href="https://github.com/techmovie/hexo-theme-instapaper">instapaper</a></div></footer><script src="/scripts/dark.js"></script><script src="/scripts/post.js"></script></body></html>