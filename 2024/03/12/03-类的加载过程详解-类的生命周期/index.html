<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport"
        content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1,user-scalable=no">
    <meta name="renderer" content="webkit">
    <meta name="color-scheme" content="dark light">
    <meta name="author" content="hcj">
    <meta name="description" content="">
    <meta name="keywords" content="">
    <title>类的加载过程详解(类的生命周期)</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_3242539_utq6ykfq7z.css">
    <link rel="stylesheet" light-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/github.min.css"
        dark-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/github-dark.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif" as="font">
    <link href="/style/index.css" rel="stylesheet">
    <meta name="generator" content="Hexo 7.1.1">
    <link rel="alternate" href="/atom.xml" title="ArcLength" type="application/atom+xml">
</head>

<body>
    <header class="page-header">
        <nav>
            <ul class="router-list">
                <li class="nav-item"> <a href="/">主页</a></li>
                <li class="nav-item"> <a href="/archives/">归档</a></li>
                <li class="nav-item"> <a href="/atom.xml">RSS</a></li>
            </ul>
            <div class="mode-switch"><span class="iconfont icon-DarkTheme"></span></div>
        </nav>
    </header>
    <main>
        <section class="main-content">
            <section class="post-page">
                <div class="title-bar">
                    <h1>类的加载过程详解(类的生命周期)</h1>
                    <div class="post-info"><span>2024-03-12 20:16:30</span><span class="tags"><a
                                href="/tags/JVM-class/">#JVM class</a></span></div>
                </div>
                <article>
                    <div class="content">
                        <h2 id="加载阶段-Loading"><a href="#加载阶段-Loading" class="headerlink"
                                title="加载阶段(Loading)"></a>加载阶段(Loading)</h2>
                        <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                class="img-loading" data-original="\tushi\Snipaste_2023-06-01_11-29-33.png""> </p>
<h4 id=" 获取二进制流的方法"><a href="#获取二进制流的方法" class="headerlink" title="获取二进制流的方法"></a>获取二进制流的方法</h4>
                        <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                class="img-loading" data-original="\tushi\Snipaste_2023-06-01_11-34-00.png""></p>
<h4 id=" 类模型与class实例的位置"><a href="#类模型与class实例的位置" class="headerlink" title="类模型与class实例的位置"></a>类模型与class实例的位置</h4>
                        <p><strong>类模型的位置</strong></p>
                        <p>加载的类在JVM中创建类结构，类结构会存储在方法区</p>
                        <p><strong>Class实例的位置</strong></p>
                        <p>类将
                            .class文件加载到元空间后，会在堆中创建Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class文件对象是在加载类的过程中创建的，每个类对应都有一个Class类型对象。
                        </p>
                        <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                class="img-loading" data-original="\tushi\Snipaste_2023-06-01_11-42-25.png""></p>
<p>外部可以通过访问order的class对象来获取order的类数据结构</p>
<h4 id=" 数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h4>
                        <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                class="img-loading" data-original="\tushi\Snipaste_2023-06-01_11-48-28.png""></p>
<h2 id=" 链接阶段（Linking）"><a href="#链接阶段（Linking）" class="headerlink" title="链接阶段（Linking）"></a>链接阶段（Linking）</h2>
                        <h4 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h4>
                        <p>验证的目的是保证加载的字节码是合法、合理并且是符合规范的</p>
                        <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                class="img-loading" data-original="\tushi\Snipaste_2023-06-01_16-41-57.png""></p>
<p>注意：</p>
<ul>
<li>格式验证会和加载阶段同时进行，验证通过，类加载器才会将而二进制数据信息加载到方法区中</li>
<li>格式检查之外的验证都是在方法区内进行</li>
</ul>
<p>​	</p>
<p><img src=" data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-01_16-47-36.png""><img src="
                                data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-01_16-53-46.png""></p>
<h4 id=" 准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4>
                        <p>为类的静态变量（包含引用类型）分配内存空间，并将其初始化为默认值</p>
                        <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                class="img-loading" data-original="\tushi\Snipaste_2023-06-01_16-59-49.png""></p>
<p>注意 </p>
<ul>
<li><p>这里不包含基本数据类型的字段使用 static final修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值</p>
<ul>
<li>准备阶段是为变量分配空间，所以final修饰的是常量，所以直接对其赋值</li>
</ul>
</li>
<li><p>基本数据类型:</p>
<ul>
<li>非final修饰的变量，在准备环节进行默认初始化赋值。</li>
<li>final 修饰以后，在准备环节直接进行显示赋值。</li>
<li>拓展:如果使用字面量的方式定义一个字符串的常量的话，也是在准备坏节直接进行显示赋值。</li>
</ul>
</li>
<li><p>这里并不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量会随着对象一起分配到java堆中</p>
</li>
<li><p>在这个阶段并不会向初始化阶段中那样会有初始化或者代码被执行</p>
</li>
</ul>
<h4 id=" 解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h4>
                        <p>将类、接口、字段、和方法的符号引用转化为直接引用</p>
                        <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                class="img-loading" data-original="\tushi\Snipaste_2023-06-01_17-38-17.png""><img src="
                                data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-01_17-44-34.png""></p>
<blockquote>
<p>就是逻辑地址转化为物理地址</p>
</blockquote>
<h2 id=" 初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2>
                        <h4 id="初始化过程和类的初始化"><a href="#初始化过程和类的初始化" class="headerlink"
                                title="初始化过程和类的初始化"></a>初始化过程和类的初始化</h4>
                        <p>为类的静态变量赋予正确的初始值</p>
                        <p>类的初始化时类装载得最后一个环节</p>
                        <p>到了初始化阶段，才真正开始执行类中定义得java字节码</p>
                        <p>初始化的重要工作就是执行类的初始化方法:<code>&lt;clinit&gt;()</code></p>
                        <p>说明</p>
                        <ol>
                            <li>在加载一个类之前往往会先加载给类的父类，因此父类的<code>&lt;clinit&gt;</code>总是在子类的<code>&lt;clinit&gt;</code>之前执行，换句话说，即使父类的static块的优先级高于子类的static的代码块
                            </li>
                            <li>并不是所有的类都会执行 <code>&lt;clinit&gt;</code> <strong>不会</strong>执行clinit方法的有：<ul>
                                    <li>一个类中并没有声明任何的类变量，也没有静态代码块时</li>
                                    <li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</li>
                                    <li>一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式</li>
                                </ul>
                            </li>
                        </ol>
                        <h4 id="初始化阶段赋值与准备阶段赋值的比较"><a href="#初始化阶段赋值与准备阶段赋值的比较" class="headerlink"
                                title="初始化阶段赋值与准备阶段赋值的比较"></a>初始化阶段赋值与准备阶段赋值的比较</h4>
                        <pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 哪些场景下，java编译器就不会生成&lt;clinit&gt;()方法</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InitializationTest1</span> &#123;
    <span class="hljs-comment">//场景1：对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
    <span class="hljs-comment">//场景2：静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num1;
    <span class="hljs-comment">//场景3：比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
&#125;



<span class="hljs-keyword">package</span> com.jvm.中篇.chapter03.src.com.atguigu.java;

<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 说明：使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</span>
<span class="hljs-comment"> * 情况1：在链接阶段的准备环节赋值           </span>
<span class="hljs-comment"> * 情况2：在初始化阶段&lt;clinit&gt;()中赋值</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 结论：</span>
<span class="hljs-comment"> * 在链接阶段的准备环节赋值的情况：</span>
<span class="hljs-comment"> * 1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行</span>
<span class="hljs-comment"> * 2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 在初始化阶段&lt;clinit&gt;()中赋值的情况：</span>
<span class="hljs-comment"> * 排除上述的在准备环节赋值的情况之外的情况。</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 最终结论：使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。</span>
<span class="hljs-comment"> </span>
<span class="hljs-comment"> 只要是字面量就在链接环节的加载中进行赋值</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InitializationTest2</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INT_CONSTANT</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-comment">//在链接阶段的准备环节赋值</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">INTEGER_CONSTANT1</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<span class="hljs-comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">INTEGER_CONSTANT2</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">1000</span>);<span class="hljs-comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s0</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloworld0&quot;</span>;<span class="hljs-comment">//在链接阶段的准备环节赋值</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;helloworld1&quot;</span>);<span class="hljs-comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloworld2&quot;</span>;   <span class="hljs-comment">//在链接阶段的准备环节赋值</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUM1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>);<span class="hljs-comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>
&#125;
</code></pre>



                        <h4 id="的线程安全"><a href="#的线程安全" class="headerlink"
                                title="&lt;clinit&gt;的线程安全"></a><code>&lt;clinit&gt;</code>的线程安全</h4>
                        <p>如果多线程同时区初始化一个类，那么只会有一个线程区执行这个类的<code>&lt;clinit&gt;</code>方法，其他线程均需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;</code>方法结束
                        </p>
                        <p>如果之前的线程成功加载了类，则当使用这个类时，jvm会直接返回给他已经准备好的信息</p>
                        <h4 id="类的主动和被动使用"><a href="#类的主动和被动使用" class="headerlink" title="类的主动和被动使用"></a>类的主动和被动使用</h4>
                        <p>主动使用：会执行初始化阶段 调用 <code>&lt;clinit&gt;</code>方法 (会执行类的静态块)</p>
                        <ul>
                            <li><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                    class="img-loading"
                                    data-original="\tushi\Snipaste_2023-06-02_14-23-12.png""><img src="
                                    data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-02_15-07-20.png""></li>
</ul>
<p>被动使用</p>
<ul>
<li><p><img src=" data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-02_14-24-49.png"" alt=" Snipaste_2023-06-02_14-24-49">
                                </p>
                                <p>注：第二点 new数组的内部成员的对象会存在主动引用 第三点 这里的常量指的是字面量 第四点 使用forName()会导致类的主动使用</p>
                            </li>
                        </ul>
                        <h2 id="类的使用Using"><a href="#类的使用Using" class="headerlink" title="类的使用Using"></a>类的使用Using</h2>
                        <p>开发人员可以在程序中访问和调用它的静态类成员信息，或者使用new关键在为其创建对象实例</p>
                        <h2 id="类的卸载-Unloding"><a href="#类的卸载-Unloding" class="headerlink"
                                title="类的卸载 Unloding"></a>类的卸载 Unloding</h2>
                        <p><span style="color:red">一个类何时结束生命周期，取决于它的class对象和时结束生命周期</span></p>
                        <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                class="img-loading" data-original="\tushi\Snipaste_2023-06-02_15-54-41.png""></p>
<p><img src=" data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-02_15-58-20.png""><img src="
                                data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-02_15-58-08.png""></p>
<p><img src=" data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-02_15-50-45.png""><img src="
                                data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-02_15-56-10.png""></p>
<h2 id=" 类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h2>
                        <p>类加载器是jvm执行类加载机制的前提。</p>
                        <p>ClassLoader的作用</p>
                        <ul>
                            <li>classLoader是java的核心组件，负责将Class信息的二进制流读入到jvm内部，转化为与目标类对应的java.lang.class对象实例。然后交给jvm进行链接、初始化等操作。
                            </li>
                            <li>所有的class都是由类加载器进行加载的。</li>
                            <li>类加载器只能影响到加载阶段，无法改变类的链接、初始化阶段</li>
                            <li>类加载器并没有绑定在jvm内部，可以更加灵活和动态地执行类加载操作。</li>
                        </ul>
                        <h4 id="类加载分类：显示加载和隐式加载"><a href="#类加载分类：显示加载和隐式加载" class="headerlink"
                                title="类加载分类：显示加载和隐式加载"></a>类加载分类：显示加载和隐式加载</h4>
                        <p>加载方式是指JVM加载class文件到内存的方式</p>
                        <ul>
                            <li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getclassLoader(
                                ).loadclass()加载class对象。</li>
                            <li>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。
                            </li>
                        </ul>
                        <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserTest</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(); <span class="hljs-comment">//隐式加载</span>

        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.atguigu.java.User&quot;</span>); <span class="hljs-comment">//显式加载</span>
            ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;com.atguigu.java.User&quot;</span>);<span class="hljs-comment">//显式加载</span>
        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;

    &#125;
&#125;</code></pre>



                        <h4 id="类加载器的必要性"><a href="#类加载器的必要性" class="headerlink" title="类加载器的必要性"></a>类加载器的必要性</h4>
                        <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                class="img-loading" data-original="\tushi\Snipaste_2023-06-02_16-48-27.png""></p>
<h4 id=" 命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4>
                        <p><span
                                style="color:red">对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性</span>。每一个类加载器都拥有一个独立的类名称空间:<span
                                style="color:red">比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</span>。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。
                        </p>
                        <p>命名空间</p>
                        <ul>
                            <li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li>
                            <li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li>
                            <li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li>
                        </ul>
                        <p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
                        <pre><code class="hljs java">

<span class="hljs-keyword">package</span> com.jvm.中篇.chapter04.src.com.atguigu.java;

<span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;
<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.InputStream;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 14:22</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;
    <span class="hljs-keyword">private</span> String rootDir;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserClassLoader</span><span class="hljs-params">(String rootDir)</span> &#123;
        <span class="hljs-built_in">this</span>.rootDir = rootDir;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 编写findClass方法的逻辑</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;
        <span class="hljs-comment">// 获取类的class文件字节数组</span>
        <span class="hljs-type">byte</span>[] classData = getClassData(name);
        <span class="hljs-keyword">if</span> (classData == <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>();
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">//直接生成class对象</span>
            <span class="hljs-keyword">return</span> defineClass(name, classData, <span class="hljs-number">0</span>, classData.length);
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 编写获取class文件并转换为字节码流的逻辑 * <span class="hljs-doctag">@param</span> className * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] getClassData(String className) &#123;
        <span class="hljs-comment">// 读取类文件的字节</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> classNameToPath(className);
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-type">InputStream</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(path);
            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();
            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];
            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-comment">// 读取类文件的字节码</span>
            <span class="hljs-keyword">while</span> ((len = ins.read(buffer)) != -<span class="hljs-number">1</span>) &#123;
                baos.write(buffer, <span class="hljs-number">0</span>, len);
            &#125;
            <span class="hljs-keyword">return</span> baos.toByteArray();
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 类文件的完全路径</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">classNameToPath</span><span class="hljs-params">(String className)</span> &#123;
        <span class="hljs-keyword">return</span> rootDir + <span class="hljs-string">&quot;\\&quot;</span> + className.replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;\\&#x27;</span>) + <span class="hljs-string">&quot;.class&quot;</span>;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">String</span> <span class="hljs-variable">rootDir</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\code\\workspace_idea5\\JVMDemo1\\chapter04\\src\\&quot;</span>;

        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//创建自定义的类的加载器1</span>
            <span class="hljs-type">UserClassLoader</span> <span class="hljs-variable">loader1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserClassLoader</span>(rootDir);
            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> loader1.findClass(<span class="hljs-string">&quot;com.atguigu.java.User&quot;</span>);

            <span class="hljs-comment">//创建自定义的类的加载器2</span>
            <span class="hljs-type">UserClassLoader</span> <span class="hljs-variable">loader2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserClassLoader</span>(rootDir);
            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz2</span> <span class="hljs-operator">=</span> loader2.findClass(<span class="hljs-string">&quot;com.atguigu.java.User&quot;</span>);

            System.out.println(clazz1 == clazz2); <span class="hljs-comment">//clazz1与clazz2对应了不同的类模板结构。 false</span>
            
            这里相当于<span class="hljs-keyword">new</span>了两个类加载器，类型相同，但是在堆中的内存位置是不同的，所以信息也不同
                
            System.out.println(clazz1.getClassLoader());
            System.out.println(clazz2.getClassLoader());

            <span class="hljs-comment">//######################</span>
            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz3</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;com.atguigu.java.User&quot;</span>);
            System.out.println(clazz3.getClassLoader());


            System.out.println(clazz1.getClassLoader().getParent());

        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;


    &#125;

&#125;</code></pre>





                        <h4 id="类的加载机制的三个基本特征"><a href="#类的加载机制的三个基本特征" class="headerlink"
                                title="类的加载机制的三个基本特征"></a>类的加载机制的三个基本特征</h4>
                        <ul>
                            <li>双亲委派机制</li>
                            <li>可见性<ul>
                                    <li>子类加载器可以访问父类加载器加载的类型 但反过来不允许</li>
                                </ul>
                            </li>
                            <li>单一性<ul>
                                    <li>因为父类加载器的类型对于子类是可见的，所以父类加载器中加载过的类型，就不会在子类加载器中重复加载</li>
                                    <li>但是注意，类加载器“邻居”间，同一类型任然可以被加载多次，因为互相并不可见</li>
                                </ul>
                            </li>
                        </ul>
                        <h2 id="类的加载器详解"><a href="#类的加载器详解" class="headerlink" title="类的加载器详解"></a>类的加载器详解</h2>
                        <p>类加载器分为两种 引导类加载器 和 自定义加载器</p>
                        <ul>
                            <li>
                                <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                        class="img-loading" data-original="\tushi\Snipaste_2023-06-02_18-50-52.png""> </p>
</li>
<li><p>所有派生于抽象类ClassLoader的类加载器都是自定义加载器</p>
</li>
<li><p>除了顶层的启动类加载器外，其余的类加载器都应当由自己的“父类加载器”。</p>
</li>
<li><p>不同类加载器看似是继承关系，实际上是包含关系，在下层加载器中，包含着上层加载器的引用</p>
</li>
</ul>
<pre><code class=" hljs java"><span class="hljs-keyword">class</span> <span
                                        class="hljs-title class_">ClassLoader</span>&#123;
                                    ClassLoader parent; <span class="hljs-comment">//父类加载器</span>
                                    <span class="hljs-keyword">public</span> <span
                                        class="hljs-title function_">ChildClassLoader</span><span
                                        class="hljs-params">(ClassLoader parent)</span>&#123;
                                    <span class="hljs-type">this</span> <span class="hljs-variable">parent</span> <span
                                        class="hljs-operator">=</span> parent
                                    &#125;
                                    &#125;

                                    <span class="hljs-keyword">class</span> <span
                                        class="hljs-title class_">ParentClassLoader</span> <span
                                        class="hljs-keyword">extends</span> <span
                                        class="hljs-title class_">ClassLoader</span>&#123;
                                    <span class="hljs-keyword">public</span> <span
                                        class="hljs-title function_">ParentClassLoader</span><span
                                        class="hljs-params">(ClassLoader parent)</span>&#123;
                                    <span class="hljs-built_in">super</span>(parent);
                                    &#125;
                                    &#125;

                                    <span class="hljs-keyword">class</span> <span
                                        class="hljs-title class_">ChildClassLoader</span> <span
                                        class="hljs-keyword">extends</span> <span
                                        class="hljs-title class_">ClassLoader</span>&#123;
                                    <span class="hljs-keyword">public</span> <span
                                        class="hljs-title function_">ChildClassLoader</span><span
                                        class="hljs-params">(ClassLoader parent)</span>&#123;<span
                                        class="hljs-comment">// parent = new ParentClassLoader();
                                        换句话说就是父类加载器作为子类加载器的属性出现</span>
                                    <span class="hljs-built_in">super</span>(parent);
                                    &#125;
                                    &#125;</code></pre>



                                <h4 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h4>
                                <ul>
                                    <li>Bootstrap类加载器包名为java、javax、sun等开头的类</li>
                                    <li>没有父类加载器 本身是c++编写 不会有java的继承结构 </li>
                                    <li>加载扩展类加载器和应用程序类加载器</li>
                                    <li>没有嵌套在jvm中</li>
                                </ul>
                                <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                        class="img-loading" data-original="\tushi\Snipaste_2023-06-02_20-27-34.png""></p>
<h4 id=" 扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4>
                                <ul>
                                    <li>java语言编写</li>
                                    <li>继承于ClassLoader</li>
                                </ul>
                                <h4 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器
                                </h4>
                                <ul>
                                    <li>java语言编写，由sun.misc.Launcher$AppClassLoader实现继承于ClassLoader类</li>
                                    <li>父类加载器为扩展类加载器</li>
                                    <li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库应用程序中的类加载器默认是系统类加载器。</li>
                                    <li>它是用户自定义类加载器的默认父加载器</li>
                                    <li>通过classLoader的getSystemClassLoader()方法可以获取到该类加载器</li>
                                </ul>
                                <h4 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器
                                </h4>
                                <ul>
                                    <li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
                                    <li>体现java语言强大生命力和巨大魅力的关键因素之一便是,Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。
                                    </li>
                                    <li>通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。
                                    </li>
                                    <li>同时，自定义加载器能够实现应用隔离，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C++程序要好太多，想不修改C&#x2F;C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。
                                    </li>
                                    <li>自定义类加载器通常需要继承于classLoader。</li>
                                </ul>
                                <p>关于数组类型的加载，使用的类的加载器于数组元素使用的加载器相同</p>
                                <p>基本数据类型不需要类的加载器</p>
                                <h4 id="ClassLoader原码解析"><a href="#ClassLoader原码解析" class="headerlink"
                                        title="ClassLoader原码解析"></a>ClassLoader原码解析</h4>
                                <h5 id="ClassLoader主要方法"><a href="#ClassLoader主要方法" class="headerlink"
                                        title="ClassLoader主要方法"></a>ClassLoader主要方法</h5>
                                <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                        class="img-loading" data-original="\tushi\Snipaste_2023-06-02_19-54-39.png""></p>
<p>findClassload是URLClassLoad里面的方法 在 扩展类加载器和应用程序加载器中没有该方法</p>
<p><img src=" data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-02_20-32-08.png""></p>
<p><img src=" data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-02_20-27-34.png""></p>
<pre><code class=" hljs java">满足双亲委派机制 采用的是递归的思想

                                    <span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name,
                                    <span class="hljs-type">boolean</span> resolve) <span
                                        class="hljs-comment">//true-加载class的同时进行解析操作</span>
                                    <span class="hljs-keyword">throws</span> ClassNotFoundException
                                    &#123;
                                    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;
                                    <span class="hljs-comment">//同步操作，保证只能加载一次</span>
                                    <span class="hljs-comment">// 首先，在缓存中判断是否已经加载到同名的类</span>
                                    Class&lt;?&gt; c = findLoadedClass(name);
                                    <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>)
                                    &#123;
                                    <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span
                                        class="hljs-operator">=</span> System.nanoTime();
                                    <span class="hljs-keyword">try</span> &#123;
                                    <span class="hljs-comment">// 获取当前加载器的父类加载器</span>
                                    <span class="hljs-keyword">if</span> (parent != <span
                                        class="hljs-literal">null</span>) &#123;
                                    <span class="hljs-comment">// 如果存在父类加载器，就调用父类加载器进行类加载</span>
                                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);
                                    &#125; <span class="hljs-keyword">else</span> &#123;
                                    <span class="hljs-comment">// 不存在父类加载器 即父类加载器就是引导类加载器 就使用启动类加载器进行加载</span>
                                    c = findBootstrapClassOrNull(name);
                                    &#125;
                                    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
                                    <span class="hljs-comment">// ClassNotFoundException thrown if class not
                                        found</span>
                                    <span class="hljs-comment">// from the non-null parent class loader</span>
                                    &#125;

                                    <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>)
                                    &#123; <span class="hljs-comment">// 父类加载器没有加载该类 或者该类的加载器没有加载该类</span>
                                    <span class="hljs-comment">//调用当前类加载器的findClass()</span>
                                    <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span
                                        class="hljs-operator">=</span> System.nanoTime();
                                    c = findClass(name);

                                    <span class="hljs-comment">// this is the defining class loader; record the
                                        stats</span>
                                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                                    sun.misc.PerfCounter.getFindClasses().increment();
                                    &#125;
                                    &#125;
                                    <span class="hljs-keyword">if</span> (resolve) &#123; <span class="hljs-comment">//
                                        是否进行解析操作</span>
                                    resolveClass(c);
                                    &#125;
                                    <span class="hljs-keyword">return</span> c;
                                    &#125;
                                    &#125;</code></pre>





                                <pre><code class="hljs java"> <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(<span class="hljs-keyword">final</span> String name)<span class="hljs-keyword">throws</span> ClassNotFoundException&#123;

 ******
<span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) &#123;
      <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//直接defind查询到的结果返回出去作为fiandclass的结果</span>
          <span class="hljs-keyword">return</span> defineClass(name, res);
      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(name, e);
      &#125;
  &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  &#125;
     
     ****
 &#125;</code></pre>



                                <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                        class="img-loading" data-original="\tushi\Snipaste_2023-06-02_20-37-55.png""></p>
<h4 id=" SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink"
                                        title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader
                                    </h4>
                                <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                        class="img-loading"
                                        data-original="\tushi\Snipaste_2023-06-02_20-39-15.png""><img src="
                                        data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-02_20-40-17.png""></p>
<h4 id=" Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink"
                                        title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()
                                    </h4>
                                <ul>
                                    <li>class.forName():是一个静态方法,最常用的是Class.forName(String
                                        className);根据传入的类的全限定名返回一个Class对象。<span
                                            style="color:red">该方法在将Class文件加载到内存的同时,会执行类的初始化</span>。<ul>
                                            <li>如:class.forName( “com.atguigu.java.Helloworld” );</li>
                                        </ul>
                                    </li>
                                    <li>classLoader.loadClass():这是一个实例方法,需要一个ClassLoader对象来调用该方法。<span
                                            style="color:red">该方法将Class文件加载到内存时,并不会执行类的初始化,直到这个类第一次使用时才进行初始化</span>。该方法因为需要得到个classLoader对象,所以可以根据需要指定使用哪个类加载器.
                                        <ul>
                                            <li>如:ClassLoader cl&#x3D;…… .;<br>c1.loadclass(
                                                “com.atguigu.java.Helloworld” );</li>
                                        </ul>
                                    </li>
                                </ul>
                                <h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2>
                                <p>双亲委派机制，这种机制能够更好的保证Java平台的安全</p>
                                <p>向上委托，向下加载</p>
                                <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                        class="img-loading" data-original="\tushi\Snipaste_2023-06-03_10-26-40.png""></p>
<h4 id=" 优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4>
                                <ol>
                                    <li>避免类的重复加载，保证了一个类全局的唯一性<ul>
                                            <li>体现在 在某一个类加载器中只能加载一次 同时 不能有多个类加载器都可以加载该类</li>
                                        </ul>
                                    </li>
                                    <li>保证了核心类库不被随意修改，保证程序安全</li>
                                </ol>
                                <h4 id="双亲委派机制代码体现"><a href="#双亲委派机制代码体现" class="headerlink"
                                        title="双亲委派机制代码体现"></a>双亲委派机制代码体现</h4>
                                <p>loadClass源码</p>
                                <h4 id="双亲委派机制弊端"><a href="#双亲委派机制弊端" class="headerlink" title="双亲委派机制弊端"></a>双亲委派机制弊端
                                </h4>
                                <p>检查类是否接受委托是单向的，使得结构非常清晰，但会带来一个问题就是 顶层的类加载器不能访问底层的Classloader所加载的类</p>
                                <blockquote>
                                    <p>如果一个类被底层的类加载器加载了，那么顶层的类加载器确实无法直接访问这个类。但是，如果顶层的类加载器需要加载一个与底层类加载器加载的类同名的类时，它会从自己已经加载的类中查找，而不会去查找底层类加载器中已经加载的类。这意味着，同名的类在不同类加载器中是两个不同的类，它们并不相互影响。
                                    </p>
                                </blockquote>
                                <h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4>
                                <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                        class="img-loading" data-original="\tushi\Snipaste_2023-06-03_10-44-35.png""></p>
<h3 id=" 破坏双亲委派机制的行为"><a href="#破坏双亲委派机制的行为" class="headerlink" title="破坏双亲委派机制的行为"></a>破坏双亲委派机制的行为</h3>
                                <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                        class="img-loading" data-original="\tushi\Snipaste_2023-06-03_10-57-55.png""></p>
<p><img src=" data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-03_11-01-35.png""></p>
<p><img src=" data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-03_11-02-06.png""></p>
<p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类</p>
<p><img src=" data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-03_11-05-55.png""><img src="
                                        data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-03_11-10-15.png""></p>
<pre><code class=" hljs java"><span class="hljs-keyword">package</span> com.jvm.中篇.chapter04.src.com.atguigu.java1;

                                    <span class="hljs-keyword">import</span> java.lang.reflect.Method;


                                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>
                                    <span class="hljs-title class_">LoopRun</span> &#123;
                                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>
                                    <span class="hljs-keyword">void</span> <span
                                        class="hljs-title function_">main</span><span class="hljs-params">(String
                                        args[])</span> &#123;
                                    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
                                    &#123;
                                    <span class="hljs-keyword">try</span> &#123;
                                    <span class="hljs-comment">//1. 创建自定义类加载器的实例</span>
                                    <span class="hljs-type">MyClassLoader</span> <span
                                        class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span
                                        class="hljs-keyword">new</span> <span
                                        class="hljs-title class_">MyClassLoader</span>(<span
                                        class="hljs-string">&quot;D:\\code\\workspace_idea5\\JVMDemo1\\chapter04\\src\\&quot;</span>);
                                    <span class="hljs-comment">//2. 加载指定的类</span>
                                    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span
                                        class="hljs-operator">=</span> loader.findClass(<span
                                        class="hljs-string">&quot;com.atguigu.java1.Demo1&quot;</span>);
                                    <span class="hljs-comment">//3. 创建运行时类的实例</span>
                                    <span class="hljs-type">Object</span> <span class="hljs-variable">demo</span> <span
                                        class="hljs-operator">=</span> clazz.newInstance();
                                    <span class="hljs-comment">//4. 获取运行时类中指定的方法</span>
                                    <span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span
                                        class="hljs-operator">=</span> clazz.getMethod(<span
                                        class="hljs-string">&quot;hot&quot;</span>);
                                    <span class="hljs-comment">//5. 调用指定的方法</span>
                                    m.invoke(demo);
                                    Thread.sleep(<span class="hljs-number">5000</span>);
                                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                                    System.out.println(<span class="hljs-string">&quot;not find&quot;</span>);

                                    <span class="hljs-keyword">try</span> &#123;
                                    Thread.sleep(<span class="hljs-number">5000</span>);
                                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;
                                    ex.printStackTrace();
                                    &#125;

                                    &#125;
                                    &#125;
                                    &#125;

                                    &#125;


                                    <span class="hljs-keyword">package</span>
                                    com.jvm.中篇.chapter04.src.com.atguigu.java1;

                                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>
                                    <span class="hljs-title class_">Demo1</span> &#123;
                                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>
                                    <span class="hljs-title function_">hot</span><span class="hljs-params">()</span>
                                    &#123;
                                    System.out.println(<span class="hljs-string">&quot;OldDemo1---&gt;
                                        NewDemo1&quot;</span>);
                                    &#125;

                                    &#125;

                                    </code></pre>





                                <h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2>
                                <p>Java安全模型的核心就是Java沙箱</p>
                                <p>沙箱机制就是将java代码限定在虚拟机特定的运行范围内，并且严格限制对本地系统资源的访问</p>
                                <h2 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h2>
                                <h4 id="设置自定义加载器的原因"><a href="#设置自定义加载器的原因" class="headerlink"
                                        title="设置自定义加载器的原因"></a>设置自定义加载器的原因</h4>
                                <ul>
                                    <li>隔离加载类<ul>
                                            <li>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境中</li>
                                            <li>防止类仲裁 导致类冲突（不同jar包版本冲突）</li>
                                        </ul>
                                    </li>
                                    <li>修改类的加载方式<ul>
                                            <li>类的加载模型并非强制，除引导类加载器外，其他类加载器动态的按需加载</li>
                                        </ul>
                                    </li>
                                    <li>扩展加载源<ul>
                                            <li>可以从 数据库、网络、甚至是机顶盒中进行加载</li>
                                        </ul>
                                    </li>
                                    <li>防止源码泄露<ul>
                                            <li>Java代码容易被篡改和编译、可以进行加密编译，所以类加载也需要自定义，还原加密的字节码</li>
                                        </ul>
                                    </li>
                                </ul>
                                <p>注意：</p>
                                <ul>
                                    <li>在Java类型转化的时候，只有两个类型都是由同一个加载器所加载，才能进行类型转化，否则转化时会发生异常</li>
                                </ul>
                                <h4 id="实现自定义加载器"><a href="#实现自定义加载器" class="headerlink" title="实现自定义加载器"></a>实现自定义加载器
                                </h4>
                                <p>所有用户自定义的加载器都需要继承ClassLoader类</p>
                                <p>在定义ClassLoader的子类时可以有两种做法：</p>
                                <ol>
                                    <li>重写findclass() 建议 </li>
                                    <li>重写loadclass()</li>
                                </ol>
                                <p>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改<br>loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。
                                </p>
                                <ul>
                                    <li>loadClass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。<span
                                            style="color:red">因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构</span>。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。
                                    </li>
                                    <li>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。</li>
                                </ul>
                                <pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jvm.中篇.chapter04.src.com.atguigu.java2;

<span class="hljs-keyword">import</span> java.io.BufferedInputStream;
<span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;
<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 15:20</span>
<span class="hljs-comment"> * 自定义ClassLoader</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;
    <span class="hljs-keyword">private</span> String byteCodePath;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClassLoader</span><span class="hljs-params">(String byteCodePath)</span> &#123;
        <span class="hljs-built_in">this</span>.byteCodePath = byteCodePath;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClassLoader</span><span class="hljs-params">(ClassLoader parent, String byteCodePath)</span> &#123;
        <span class="hljs-built_in">super</span>(parent);
        <span class="hljs-built_in">this</span>.byteCodePath = byteCodePath;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;
        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//获取字节码文件的完整路径</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> byteCodePath + className + <span class="hljs-string">&quot;.class&quot;</span>;
            <span class="hljs-comment">//获取一个输入流</span>
            bis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName));
            <span class="hljs-comment">//获取一个输出流</span>
            baos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();
            <span class="hljs-comment">//具体读入数据并写出的过程</span>
            <span class="hljs-type">int</span> len;
            <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];
            <span class="hljs-keyword">while</span> ((len = bis.read(data)) != -<span class="hljs-number">1</span>) &#123;
                baos.write(data, <span class="hljs-number">0</span>, len);
            &#125;
            <span class="hljs-comment">//获取内存中的完整的字节数组的数据</span>
            <span class="hljs-type">byte</span>[] byteCodes = baos.toByteArray();
            <span class="hljs-comment">//调用defineClass()，将字节数组的数据转换为Class的实例。</span>
            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> defineClass(<span class="hljs-literal">null</span>, byteCodes, <span class="hljs-number">0</span>, byteCodes.length);
            <span class="hljs-keyword">return</span> clazz;
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">if</span> (baos != <span class="hljs-literal">null</span>)
                    baos.close();
            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">if</span> (bis != <span class="hljs-literal">null</span>)
                    bis.close();
            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;


    &#125;
&#125;


<span class="hljs-keyword">package</span> com.jvm.中篇.chapter04.src.com.atguigu.java2;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoaderTest</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">MyClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassLoader</span>(<span class="hljs-string">&quot;d:/&quot;</span>);

        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> loader.loadClass(<span class="hljs-string">&quot;Demo1&quot;</span>);
            System.out.println(<span class="hljs-string">&quot;加载此类的类的加载器为：&quot;</span> + clazz.getClassLoader().getClass().getName());

            System.out.println(<span class="hljs-string">&quot;加载当前Demo1类的类的加载器的父类加载器为：&quot;</span> + clazz.getClassLoader().getParent().getClass().getName());
        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>





                                <h2 id="java9-jvm新特性"><a href="#java9-jvm新特性" class="headerlink"
                                        title="java9 jvm新特性"></a>java9 jvm新特性</h2>
                                <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="
                                        class="img-loading"
                                        data-original="\tushi\Snipaste_2023-06-03_12-51-52.png""><img src="
                                        data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-03_12-54-34.png""></p>
<p><img src=" data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-03_12-57-55.png""></p>
<p><img src=" data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-03_12-58-43.png""><img src="
                                        data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class=" img-loading" data-original="\tushi\Snipaste_2023-06-03_12-59-05.png""></p>
</div></article><div class=" copyright-wrapper">
                                <p>原文作者:<a href="http://example.com">hcj</a></p>
                                <p>原文链接:<a
                                        href="http://example.com/2024/03/12/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">类的加载过程详解(类的生命周期)</a>
                                </p>
                                <p>发表日期: 2024-03-12 20:16:30</p>
                                <p>更新日期: 2024-03-30 14:40:44</p>
                                <p>版权声明: 本文采用<a rel="license noopener" target="_blank"
                                        href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0
                                        国际许可协议</a>进行许可</p>
                    </div>
                    <div class="post-pager">
                        <div class="prev"></div>
                        <div class="next"> <a href="/2023/10/12/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/"
                                title="字节码指令集">下一篇 字节码指令集</a></div>
                    </div>
            </section>
        </section>
    </main>
    <footer class="footer-page">
        <div><span>Powered by</span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a><span>|
                Theme</span><a target="_blank" rel="noopener"
                href="https://github.com/techmovie/hexo-theme-instapaper">instapaper</a></div>
    </footer>
    <script src="/scripts/dark.js"></script>
    <script src="/scripts/post.js"></script>
</body>

</html>