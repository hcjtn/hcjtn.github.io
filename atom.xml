<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ArcLength</title>
  
  <subtitle>hcj</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-14T02:10:37.256Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>hcj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类的加载过程详解(类的生命周期)</title>
    <link href="http://example.com/2024/03/12/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2024/03/12/03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2024-03-12T12:16:30.000Z</published>
    <updated>2024-03-14T02:10:37.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加载阶段-Loading"><a href="#加载阶段-Loading" class="headerlink" title="加载阶段(Loading)"></a>加载阶段(Loading)</h2><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_11-29-33.png"> </p><h4 id="获取二进制流的方法"><a href="#获取二进制流的方法" class="headerlink" title="获取二进制流的方法"></a>获取二进制流的方法</h4><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_11-34-00.png"></p><h4 id="类模型与class实例的位置"><a href="#类模型与class实例的位置" class="headerlink" title="类模型与class实例的位置"></a>类模型与class实例的位置</h4><p><strong>类模型的位置</strong></p><p>加载的类在JVM中创建类结构，类结构会存储在方法区</p><p><strong>Class实例的位置</strong></p><p>类将 .class文件加载到元空间后，会在堆中创建Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class文件对象是在加载类的过程中创建的，每个类对应都有一个Class类型对象。</p><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_11-42-25.png"></p><p>外部可以通过访问order的class对象来获取order的类数据结构</p><h4 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h4><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_11-48-28.png"></p><h2 id="链接阶段（Linking）"><a href="#链接阶段（Linking）" class="headerlink" title="链接阶段（Linking）"></a>链接阶段（Linking）</h2><h4 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h4><p>验证的目的是保证加载的字节码是合法、合理并且是符合规范的</p><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_16-41-57.png"></p><p>注意：</p><ul><li>格式验证会和加载阶段同时进行，验证通过，类加载器才会将而二进制数据信息加载到方法区中</li><li>格式检查之外的验证都是在方法区内进行</li></ul><p>​</p><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_16-47-36.png"><img src="/%5Ctushi%5CSnipaste_2023-06-01_16-53-46.png"></p><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>为类的静态变量（包含引用类型）分配内存空间，并将其初始化为默认值</p><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_16-59-49.png"></p><p>注意 </p><ul><li><p>这里不包含基本数据类型的字段使用 static final修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值</p><ul><li>准备阶段是为变量分配空间，所以final修饰的是常量，所以直接对其赋值</li></ul></li><li><p>基本数据类型:</p><ul><li>非final修饰的变量，在准备环节进行默认初始化赋值。</li><li>final 修饰以后，在准备环节直接进行显示赋值。</li><li>拓展:如果使用字面量的方式定义一个字符串的常量的话，也是在准备坏节直接进行显示赋值。</li></ul></li><li><p>这里并不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量会随着对象一起分配到java堆中</p></li><li><p>在这个阶段并不会向初始化阶段中那样会有初始化或者代码被执行</p></li></ul><h4 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h4><p>将类、接口、字段、和方法的符号引用转化为直接引用</p><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_17-38-17.png"><img src="/%5Ctushi%5CSnipaste_2023-06-01_17-44-34.png"></p><blockquote><p>就是逻辑地址转化为物理地址</p></blockquote><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h4 id="初始化过程和类的初始化"><a href="#初始化过程和类的初始化" class="headerlink" title="初始化过程和类的初始化"></a>初始化过程和类的初始化</h4><p>为类的静态变量赋予正确的初始值</p><p>类的初始化时类装载得最后一个环节</p><p>到了初始化阶段，才真正开始执行类中定义得java字节码</p><p>初始化的重要工作就是执行类的初始化方法:<code>&lt;clinit&gt;()</code></p><p>说明</p><ol><li>在加载一个类之前往往会先加载给类的父类，因此父类的<code>&lt;clinit&gt;</code>总是在子类的<code>&lt;clinit&gt;</code>之前执行，换句话说，即使父类的static块的优先级高于子类的static的代码块</li><li>并不是所有的类都会执行 <code>&lt;clinit&gt;</code>   <strong>不会</strong>执行clinit方法的有：<ul><li>一个类中并没有声明任何的类变量，也没有静态代码块时</li><li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</li><li>一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式</li></ul></li></ol><h4 id="初始化阶段赋值与准备阶段赋值的比较"><a href="#初始化阶段赋值与准备阶段赋值的比较" class="headerlink" title="初始化阶段赋值与准备阶段赋值的比较"></a>初始化阶段赋值与准备阶段赋值的比较</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 哪些场景下，java编译器就不会生成&lt;clinit&gt;()方法</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InitializationTest1</span> &#123;    <span class="hljs-comment">//场景1：对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-comment">//场景2：静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num1;    <span class="hljs-comment">//场景3：比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">package</span> com.jvm.中篇.chapter03.src.com.atguigu.java;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 说明：使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</span><span class="hljs-comment"> * 情况1：在链接阶段的准备环节赋值           </span><span class="hljs-comment"> * 情况2：在初始化阶段&lt;clinit&gt;()中赋值</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 结论：</span><span class="hljs-comment"> * 在链接阶段的准备环节赋值的情况：</span><span class="hljs-comment"> * 1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行</span><span class="hljs-comment"> * 2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 在初始化阶段&lt;clinit&gt;()中赋值的情况：</span><span class="hljs-comment"> * 排除上述的在准备环节赋值的情况之外的情况。</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 最终结论：使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。</span><span class="hljs-comment"> </span><span class="hljs-comment"> 只要是字面量就在链接环节的加载中进行赋值</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InitializationTest2</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INT_CONSTANT</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-comment">//在链接阶段的准备环节赋值</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">INTEGER_CONSTANT1</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<span class="hljs-comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">INTEGER_CONSTANT2</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">1000</span>);<span class="hljs-comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s0</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloworld0&quot;</span>;<span class="hljs-comment">//在链接阶段的准备环节赋值</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;helloworld1&quot;</span>);<span class="hljs-comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloworld2&quot;</span>;   <span class="hljs-comment">//在链接阶段的准备环节赋值</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUM1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>);<span class="hljs-comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>&#125;</code></pre><h4 id="的线程安全"><a href="#的线程安全" class="headerlink" title="&lt;clinit&gt;的线程安全"></a><code>&lt;clinit&gt;</code>的线程安全</h4><p>如果多线程同时区初始化一个类，那么只会有一个线程区执行这个类的<code>&lt;clinit&gt;</code>方法，其他线程均需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;</code>方法结束</p><p>如果之前的线程成功加载了类，则当使用这个类时，jvm会直接返回给他已经准备好的信息</p><h4 id="类的主动和被动使用"><a href="#类的主动和被动使用" class="headerlink" title="类的主动和被动使用"></a>类的主动和被动使用</h4><p>主动使用：会执行初始化阶段 调用 <code>&lt;clinit&gt;</code>方法  (会执行类的静态块)</p><ul><li><img src="/%5Ctushi%5CSnipaste_2023-06-02_14-23-12.png"><img src="/%5Ctushi%5CSnipaste_2023-06-02_15-07-20.png"></li></ul><p>被动使用</p><ul><li><p><img src="/%5Ctushi%5CSnipaste_2023-06-02_14-24-49.png" alt="Snipaste_2023-06-02_14-24-49"></p><p>注：第二点 new数组的内部成员的对象会存在主动引用    第三点 这里的常量指的是字面量 第四点 使用forName()会导致类的主动使用</p></li></ul><h2 id="类的使用Using"><a href="#类的使用Using" class="headerlink" title="类的使用Using"></a>类的使用Using</h2><p>开发人员可以在程序中访问和调用它的静态类成员信息，或者使用new关键在为其创建对象实例</p><h2 id="类的卸载-Unloding"><a href="#类的卸载-Unloding" class="headerlink" title="类的卸载 Unloding"></a>类的卸载 Unloding</h2><p><span style="color:red">一个类何时结束生命周期，取决于它的class对象和时结束生命周期</span></p><p><img src="/%5Ctushi%5CSnipaste_2023-06-02_15-54-41.png"></p><p><img src="/%5Ctushi%5CSnipaste_2023-06-02_15-58-20.png"><img src="/%5Ctushi%5CSnipaste_2023-06-02_15-58-08.png"></p><p><img src="/%5Ctushi%5CSnipaste_2023-06-02_15-50-45.png"><img src="/%5Ctushi%5CSnipaste_2023-06-02_15-56-10.png"></p><h2 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h2><p>类加载器是jvm执行类加载机制的前提。</p><p>ClassLoader的作用</p><ul><li>classLoader是java的核心组件，负责将Class信息的二进制流读入到jvm内部，转化为与目标类对应的java.lang.class对象实例。然后交给jvm进行链接、初始化等操作。</li><li>所有的class都是由类加载器进行加载的。</li><li>类加载器只能影响到加载阶段，无法改变类的链接、初始化阶段</li><li>类加载器并没有绑定在jvm内部，可以更加灵活和动态地执行类加载操作。</li></ul><h4 id="类加载分类：显示加载和隐式加载"><a href="#类加载分类：显示加载和隐式加载" class="headerlink" title="类加载分类：显示加载和隐式加载"></a>类加载分类：显示加载和隐式加载</h4><p>加载方式是指JVM加载class文件到内存的方式</p><ul><li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getclassLoader( ).loadclass()加载class对象。</li><li>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(); <span class="hljs-comment">//隐式加载</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.atguigu.java.User&quot;</span>); <span class="hljs-comment">//显式加载</span>            ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;com.atguigu.java.User&quot;</span>);<span class="hljs-comment">//显式加载</span>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="类加载器的必要性"><a href="#类加载器的必要性" class="headerlink" title="类加载器的必要性"></a>类加载器的必要性</h4><p><img src="/%5Ctushi%5CSnipaste_2023-06-02_16-48-27.png"></p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p><span style="color:red">对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性</span>。每一个类加载器都拥有一个独立的类名称空间:<span style="color:red">比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</span>。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p><p>命名空间</p><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li><li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li><li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li></ul><p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jvm.中篇.chapter04.src.com.atguigu.java;<span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 14:22</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;    <span class="hljs-keyword">private</span> String rootDir;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserClassLoader</span><span class="hljs-params">(String rootDir)</span> &#123;        <span class="hljs-built_in">this</span>.rootDir = rootDir;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 编写findClass方法的逻辑</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;        <span class="hljs-comment">// 获取类的class文件字节数组</span>        <span class="hljs-type">byte</span>[] classData = getClassData(name);        <span class="hljs-keyword">if</span> (classData == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>();        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//直接生成class对象</span>            <span class="hljs-keyword">return</span> defineClass(name, classData, <span class="hljs-number">0</span>, classData.length);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 编写获取class文件并转换为字节码流的逻辑 * <span class="hljs-doctag">@param</span> className * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] getClassData(String className) &#123;        <span class="hljs-comment">// 读取类文件的字节</span>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> classNameToPath(className);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">InputStream</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(path);            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-comment">// 读取类文件的字节码</span>            <span class="hljs-keyword">while</span> ((len = ins.read(buffer)) != -<span class="hljs-number">1</span>) &#123;                baos.write(buffer, <span class="hljs-number">0</span>, len);            &#125;            <span class="hljs-keyword">return</span> baos.toByteArray();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 类文件的完全路径</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">classNameToPath</span><span class="hljs-params">(String className)</span> &#123;        <span class="hljs-keyword">return</span> rootDir + <span class="hljs-string">&quot;\\&quot;</span> + className.replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;\\&#x27;</span>) + <span class="hljs-string">&quot;.class&quot;</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">rootDir</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\code\\workspace_idea5\\JVMDemo1\\chapter04\\src\\&quot;</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建自定义的类的加载器1</span>            <span class="hljs-type">UserClassLoader</span> <span class="hljs-variable">loader1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserClassLoader</span>(rootDir);            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> loader1.findClass(<span class="hljs-string">&quot;com.atguigu.java.User&quot;</span>);            <span class="hljs-comment">//创建自定义的类的加载器2</span>            <span class="hljs-type">UserClassLoader</span> <span class="hljs-variable">loader2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserClassLoader</span>(rootDir);            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz2</span> <span class="hljs-operator">=</span> loader2.findClass(<span class="hljs-string">&quot;com.atguigu.java.User&quot;</span>);            System.out.println(clazz1 == clazz2); <span class="hljs-comment">//clazz1与clazz2对应了不同的类模板结构。 false</span>                        这里相当于<span class="hljs-keyword">new</span>了两个类加载器，类型相同，但是在堆中的内存位置是不同的，所以信息也不同                            System.out.println(clazz1.getClassLoader());            System.out.println(clazz2.getClassLoader());            <span class="hljs-comment">//######################</span>            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz3</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;com.atguigu.java.User&quot;</span>);            System.out.println(clazz3.getClassLoader());            System.out.println(clazz1.getClassLoader().getParent());        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="类的加载机制的三个基本特征"><a href="#类的加载机制的三个基本特征" class="headerlink" title="类的加载机制的三个基本特征"></a>类的加载机制的三个基本特征</h4><ul><li>双亲委派机制</li><li>可见性<ul><li>子类加载器可以访问父类加载器加载的类型 但反过来不允许</li></ul></li><li>单一性<ul><li>因为父类加载器的类型对于子类是可见的，所以父类加载器中加载过的类型，就不会在子类加载器中重复加载</li><li>但是注意，类加载器“邻居”间，同一类型任然可以被加载多次，因为互相并不可见</li></ul></li></ul><h2 id="类的加载器详解"><a href="#类的加载器详解" class="headerlink" title="类的加载器详解"></a>类的加载器详解</h2><p>类加载器分为两种 引导类加载器 和 自定义加载器</p><ul><li><p><img src="/%5Ctushi%5CSnipaste_2023-06-02_18-50-52.png"> </p></li><li><p>所有派生于抽象类ClassLoader的类加载器都是自定义加载器</p></li><li><p>除了顶层的启动类加载器外，其余的类加载器都应当由自己的“父类加载器”。</p></li><li><p>不同类加载器看似是继承关系，实际上是包含关系，在下层加载器中，包含着上层加载器的引用</p></li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoader</span>&#123;    ClassLoader parent;  <span class="hljs-comment">//父类加载器</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChildClassLoader</span><span class="hljs-params">(ClassLoader parent)</span>&#123;        <span class="hljs-type">this</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> parent    &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;     <span class="hljs-keyword">public</span> <span class="hljs-title function_">ParentClassLoader</span><span class="hljs-params">(ClassLoader parent)</span>&#123;       <span class="hljs-built_in">super</span>(parent);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChildClassLoader</span><span class="hljs-params">(ClassLoader parent)</span>&#123;<span class="hljs-comment">// parent = new ParentClassLoader();  换句话说就是父类加载器作为子类加载器的属性出现</span>       <span class="hljs-built_in">super</span>(parent);    &#125;&#125;</code></pre><h4 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h4><ul><li>Bootstrap类加载器包名为java、javax、sun等开头的类</li><li>没有父类加载器 本身是c++编写 不会有java的继承结构 </li><li>加载扩展类加载器和应用程序类加载器</li><li>没有嵌套在jvm中</li></ul><p><img src="/%5Ctushi%5CSnipaste_2023-06-02_20-27-34.png"></p><h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><ul><li>java语言编写</li><li>继承于ClassLoader</li></ul><h4 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h4><ul><li>java语言编写，由sun.misc.Launcher$AppClassLoader实现继承于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库应用程序中的类加载器默认是系统类加载器。</li><li>它是用户自定义类加载器的默认父加载器</li><li>通过classLoader的getSystemClassLoader()方法可以获取到该类加载器</li></ul><h4 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h4><ul><li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li><li>体现java语言强大生命力和巨大魅力的关键因素之一便是,Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li><li>通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li><li>同时，自定义加载器能够实现应用隔离，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C++程序要好太多，想不修改C&#x2F;C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li><li>自定义类加载器通常需要继承于classLoader。</li></ul><p>关于数组类型的加载，使用的类的加载器于数组元素使用的加载器相同</p><p>基本数据类型不需要类的加载器</p><h4 id="ClassLoader原码解析"><a href="#ClassLoader原码解析" class="headerlink" title="ClassLoader原码解析"></a>ClassLoader原码解析</h4><h5 id="ClassLoader主要方法"><a href="#ClassLoader主要方法" class="headerlink" title="ClassLoader主要方法"></a>ClassLoader主要方法</h5><p><img src="/%5Ctushi%5CSnipaste_2023-06-02_19-54-39.png"></p><p>findClassload是URLClassLoad里面的方法 在 扩展类加载器和应用程序加载器中没有该方法</p><p><img src="/%5Ctushi%5CSnipaste_2023-06-02_20-32-08.png"></p><p><img src="/%5Ctushi%5CSnipaste_2023-06-02_20-27-34.png"></p><pre><code class="hljs java">满足双亲委派机制  采用的是递归的思想<span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)  <span class="hljs-comment">//true-加载class的同时进行解析操作</span>        <span class="hljs-keyword">throws</span> ClassNotFoundException    &#123;        <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;  <span class="hljs-comment">//同步操作，保证只能加载一次</span>            <span class="hljs-comment">// 首先，在缓存中判断是否已经加载到同名的类</span>            Class&lt;?&gt; c = findLoadedClass(name);            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// 获取当前加载器的父类加载器</span>                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;                        <span class="hljs-comment">// 如果存在父类加载器，就调用父类加载器进行类加载</span>                        c = parent.loadClass(name, <span class="hljs-literal">false</span>);                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// 不存在父类加载器 即父类加载器就是引导类加载器 就使用启动类加载器进行加载</span>                        c = findBootstrapClassOrNull(name);                    &#125;                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                    <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>                    <span class="hljs-comment">// from the non-null parent class loader</span>                &#125;                <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 父类加载器没有加载该类 或者该类的加载器没有加载该类</span>                    <span class="hljs-comment">//调用当前类加载器的findClass()</span>                    <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();                    c = findClass(name);                    <span class="hljs-comment">// this is the defining class loader; record the stats</span>                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                    sun.misc.PerfCounter.getFindClasses().increment();                &#125;            &#125;            <span class="hljs-keyword">if</span> (resolve) &#123;  <span class="hljs-comment">// 是否进行解析操作</span>                resolveClass(c);            &#125;            <span class="hljs-keyword">return</span> c;        &#125;    &#125;</code></pre><pre><code class="hljs java"> <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(<span class="hljs-keyword">final</span> String name)<span class="hljs-keyword">throws</span> ClassNotFoundException&#123; ******<span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//直接defind查询到的结果返回出去作为fiandclass的结果</span>          <span class="hljs-keyword">return</span> defineClass(name, res);      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(name, e);      &#125;  &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;          **** &#125;</code></pre><p><img src="/%5Ctushi%5CSnipaste_2023-06-02_20-37-55.png"></p><h4 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h4><p><img src="/%5Ctushi%5CSnipaste_2023-06-02_20-39-15.png"><img src="/%5Ctushi%5CSnipaste_2023-06-02_20-40-17.png"></p><h4 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h4><ul><li>class.forName():是一个静态方法,最常用的是Class.forName(String className);根据传入的类的全限定名返回一个Class对象。<span style="color:red">该方法在将Class文件加载到内存的同时,会执行类的初始化</span>。<ul><li>如:class.forName( “com.atguigu.java.Helloworld” );</li></ul></li><li>classLoader.loadClass():这是一个实例方法,需要一个ClassLoader对象来调用该方法。<span style="color:red">该方法将Class文件加载到内存时,并不会执行类的初始化,直到这个类第一次使用时才进行初始化</span>。该方法因为需要得到个classLoader对象,所以可以根据需要指定使用哪个类加载器.<ul><li>如:ClassLoader cl&#x3D;…… .;<br>c1.loadclass( “com.atguigu.java.Helloworld” );</li></ul></li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>双亲委派机制，这种机制能够更好的保证Java平台的安全</p><p>向上委托，向下加载</p><p><img src="/%5Ctushi%5CSnipaste_2023-06-03_10-26-40.png"></p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>避免类的重复加载，保证了一个类全局的唯一性<ul><li>体现在 在某一个类加载器中只能加载一次 同时 不能有多个类加载器都可以加载该类</li></ul></li><li>保证了核心类库不被随意修改，保证程序安全</li></ol><h4 id="双亲委派机制代码体现"><a href="#双亲委派机制代码体现" class="headerlink" title="双亲委派机制代码体现"></a>双亲委派机制代码体现</h4><p>loadClass源码</p><h4 id="双亲委派机制弊端"><a href="#双亲委派机制弊端" class="headerlink" title="双亲委派机制弊端"></a>双亲委派机制弊端</h4><p>检查类是否接受委托是单向的，使得结构非常清晰，但会带来一个问题就是 顶层的类加载器不能访问底层的Classloader所加载的类</p><blockquote><p>如果一个类被底层的类加载器加载了，那么顶层的类加载器确实无法直接访问这个类。但是，如果顶层的类加载器需要加载一个与底层类加载器加载的类同名的类时，它会从自己已经加载的类中查找，而不会去查找底层类加载器中已经加载的类。这意味着，同名的类在不同类加载器中是两个不同的类，它们并不相互影响。</p></blockquote><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p><img src="/%5Ctushi%5CSnipaste_2023-06-03_10-44-35.png"></p><h3 id="破坏双亲委派机制的行为"><a href="#破坏双亲委派机制的行为" class="headerlink" title="破坏双亲委派机制的行为"></a>破坏双亲委派机制的行为</h3><p><img src="/%5Ctushi%5CSnipaste_2023-06-03_10-57-55.png"></p><p><img src="/%5Ctushi%5CSnipaste_2023-06-03_11-01-35.png"></p><p><img src="/%5Ctushi%5CSnipaste_2023-06-03_11-02-06.png"></p><p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类</p><p><img src="/%5Ctushi%5CSnipaste_2023-06-03_11-05-55.png"><img src="/%5Ctushi%5CSnipaste_2023-06-03_11-10-15.png"></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jvm.中篇.chapter04.src.com.atguigu.java1;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoopRun</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//1. 创建自定义类加载器的实例</span>                <span class="hljs-type">MyClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassLoader</span>(<span class="hljs-string">&quot;D:\\code\\workspace_idea5\\JVMDemo1\\chapter04\\src\\&quot;</span>);                <span class="hljs-comment">//2. 加载指定的类</span>                <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> loader.findClass(<span class="hljs-string">&quot;com.atguigu.java1.Demo1&quot;</span>);                <span class="hljs-comment">//3. 创建运行时类的实例</span>                <span class="hljs-type">Object</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> clazz.newInstance();                <span class="hljs-comment">//4. 获取运行时类中指定的方法</span>                <span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;hot&quot;</span>);                <span class="hljs-comment">//5. 调用指定的方法</span>                m.invoke(demo);                Thread.sleep(<span class="hljs-number">5000</span>);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                System.out.println(<span class="hljs-string">&quot;not find&quot;</span>);                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">5000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;                    ex.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.jvm.中篇.chapter04.src.com.atguigu.java1;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hot</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;OldDemo1---&gt; NewDemo1&quot;</span>);    &#125;&#125;</code></pre><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>Java安全模型的核心就是Java沙箱</p><p>沙箱机制就是将java代码限定在虚拟机特定的运行范围内，并且严格限制对本地系统资源的访问</p><h2 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h2><h4 id="设置自定义加载器的原因"><a href="#设置自定义加载器的原因" class="headerlink" title="设置自定义加载器的原因"></a>设置自定义加载器的原因</h4><ul><li>隔离加载类<ul><li>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境中</li><li>防止类仲裁 导致类冲突（不同jar包版本冲突）</li></ul></li><li>修改类的加载方式<ul><li>类的加载模型并非强制，除引导类加载器外，其他类加载器动态的按需加载</li></ul></li><li>扩展加载源<ul><li>可以从 数据库、网络、甚至是机顶盒中进行加载</li></ul></li><li>防止源码泄露<ul><li>Java代码容易被篡改和编译、可以进行加密编译，所以类加载也需要自定义，还原加密的字节码</li></ul></li></ul><p>注意：</p><ul><li>在Java类型转化的时候，只有两个类型都是由同一个加载器所加载，才能进行类型转化，否则转化时会发生异常</li></ul><h4 id="实现自定义加载器"><a href="#实现自定义加载器" class="headerlink" title="实现自定义加载器"></a>实现自定义加载器</h4><p>所有用户自定义的加载器都需要继承ClassLoader类</p><p>在定义ClassLoader的子类时可以有两种做法：</p><ol><li>重写findclass()         建议 </li><li>重写loadclass()</li></ol><p>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改<br>loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</p><ul><li>loadClass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。<span style="color:red">因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构</span>。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li><li>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jvm.中篇.chapter04.src.com.atguigu.java2;<span class="hljs-keyword">import</span> java.io.BufferedInputStream;<span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 15:20</span><span class="hljs-comment"> * 自定义ClassLoader</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;    <span class="hljs-keyword">private</span> String byteCodePath;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClassLoader</span><span class="hljs-params">(String byteCodePath)</span> &#123;        <span class="hljs-built_in">this</span>.byteCodePath = byteCodePath;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClassLoader</span><span class="hljs-params">(ClassLoader parent, String byteCodePath)</span> &#123;        <span class="hljs-built_in">super</span>(parent);        <span class="hljs-built_in">this</span>.byteCodePath = byteCodePath;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//获取字节码文件的完整路径</span>            <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> byteCodePath + className + <span class="hljs-string">&quot;.class&quot;</span>;            <span class="hljs-comment">//获取一个输入流</span>            bis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName));            <span class="hljs-comment">//获取一个输出流</span>            baos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();            <span class="hljs-comment">//具体读入数据并写出的过程</span>            <span class="hljs-type">int</span> len;            <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];            <span class="hljs-keyword">while</span> ((len = bis.read(data)) != -<span class="hljs-number">1</span>) &#123;                baos.write(data, <span class="hljs-number">0</span>, len);            &#125;            <span class="hljs-comment">//获取内存中的完整的字节数组的数据</span>            <span class="hljs-type">byte</span>[] byteCodes = baos.toByteArray();            <span class="hljs-comment">//调用defineClass()，将字节数组的数据转换为Class的实例。</span>            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> defineClass(<span class="hljs-literal">null</span>, byteCodes, <span class="hljs-number">0</span>, byteCodes.length);            <span class="hljs-keyword">return</span> clazz;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (baos != <span class="hljs-literal">null</span>)                    baos.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (bis != <span class="hljs-literal">null</span>)                    bis.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;<span class="hljs-keyword">package</span> com.jvm.中篇.chapter04.src.com.atguigu.java2;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoaderTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">MyClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassLoader</span>(<span class="hljs-string">&quot;d:/&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> loader.loadClass(<span class="hljs-string">&quot;Demo1&quot;</span>);            System.out.println(<span class="hljs-string">&quot;加载此类的类的加载器为：&quot;</span> + clazz.getClassLoader().getClass().getName());            System.out.println(<span class="hljs-string">&quot;加载当前Demo1类的类的加载器的父类加载器为：&quot;</span> + clazz.getClassLoader().getParent().getClass().getName());        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="java9-jvm新特性"><a href="#java9-jvm新特性" class="headerlink" title="java9 jvm新特性"></a>java9 jvm新特性</h2><p><img src="/%5Ctushi%5CSnipaste_2023-06-03_12-51-52.png"><img src="/%5Ctushi%5CSnipaste_2023-06-03_12-54-34.png"></p><p><img src="/%5Ctushi%5CSnipaste_2023-06-03_12-57-55.png"></p><p><img src="/%5Ctushi%5CSnipaste_2023-06-03_12-58-43.png"><img src="/%5Ctushi%5CSnipaste_2023-06-03_12-59-05.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;加载阶段-Loading&quot;&gt;&lt;a href=&quot;#加载阶段-Loading&quot; class=&quot;headerlink&quot; title=&quot;加载阶段(Loading)&quot;&gt;&lt;/a&gt;加载阶段(Loading)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/%5Ctushi%5CSnipas</summary>
      
    
    
    
    
    <category term="JVM class" scheme="http://example.com/tags/JVM-class/"/>
    
  </entry>
  
  <entry>
    <title>字节码指令集</title>
    <link href="http://example.com/2023/10/12/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    <id>http://example.com/2023/10/12/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/</id>
    <published>2023-10-12T12:16:15.000Z</published>
    <updated>2024-03-14T02:10:42.550Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java字节码对于JVM就像汇编对于计算机，属于基本执行指令</p><p>java虚拟机有一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及紧随其后的0到多个代表此操作所需要参数（操作数）而构成。大多数的指令都不包含操作数，只有一个操作码</p><p>字节长度(0~255)限制了指令集死亡操作码总数不能超过256</p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解</p><p>do{</p><p>自动计算PC寄存器的值加1;</p><p>根据Pc寄存器的指示位置，从字节码流中取出操作码;</p><p>if(字节码存在操作数){</p><p>​从字节码流中取出操作数;</p><p>​        执行操作码所定义的操作;</p><p>}while(字节码长度&gt;0);</p><h2 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h2><p>操作数栈：存放计算的操作数栈和返回结果</p><ul><li>执行每一条指令之前，Java虚拟机要求该指令的操作数栈已被压入操作数栈中。在执行指令的时候，<strong>java虚拟机会将该指令所需要的操作数弹出，并且将指令的结果重新压入栈中</strong></li></ul><p>局部变量表：字节码程序将计算的结果缓存到局部变量区之中</p><ul><li>jvm将局部变量区当成一个数组，依次存放this指针(仅非静态方法)，所传入的参数，以及字节码中局部变量</li></ul><h4 id="局部变量压栈指令-load"><a href="#局部变量压栈指令-load" class="headerlink" title="局部变量压栈指令 load"></a>局部变量压栈指令 load</h4><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈</p><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_10-33-08.png" alt="Snipaste_2023-05-28_10-33-08"></p><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_11-03-00.png"></p><pre><code class="hljs java"><span class="hljs-comment">//1.局部变量压栈指令</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-type">int</span> num, Object obj,<span class="hljs-type">long</span> count,<span class="hljs-type">boolean</span> flag,<span class="hljs-type">short</span>[] arr)</span> &#123;      System.out.println(num);      System.out.println(obj);      System.out.println(count);      System.out.println(flag);      System.out.println(arr);  &#125;</code></pre><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_11-17-58.png"></p><h4 id="常量入栈指令"><a href="#常量入栈指令" class="headerlink" title="常量入栈指令"></a>常量入栈指令</h4><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容不同，又可以分为const系列、push系列和ldc指令</p><p>const系列：用于对特定的常量入栈，入栈的常量隐含在指令本身里面</p><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_11-28-29.png"></p><p>push系列：主要包括bipush和sipush。他们的主要区别是接收数据类型不同，bipush是接收8位整数作为参数，sipush接收16位整数，他们都将参数压入栈</p><ul><li>所以bipush的范围是-128~127</li><li>sipush的范围是 -32768~32767</li></ul><p>ldc系列：</p><ul><li>如果以上指令都不能满足需求，那么可以使用万能的ldc系列，它可以接收一个8位的参数，该参数指向常量池中的int、float或者String的索引，将指定的索引范围压入堆栈。</li><li>类似的还有ldc_w,他接收两个8位参数，能支持的索引范围大于ldc</li></ul><pre><code class="hljs java"><span class="hljs-comment">//2.常量入栈指令</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushConstLdc</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">32767</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">32768</span>;    &#125;</code></pre><p>总结</p><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_11-42-09.png"></p><h4 id="出栈装入局部变量表指令"><a href="#出栈装入局部变量表指令" class="headerlink" title="出栈装入局部变量表指令"></a>出栈装入局部变量表指令</h4><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_12-52-40.png"></p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_13-17-58.png"><img src="/%5Ctushi%5CSnipaste_2023-05-28_13-21-44.png"></p><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_13-28-32.png"></p><h5 id="运算符"><a href="#运算符" class="headerlink" title="++运算符"></a>++运算符</h5><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_14-47-32.png"></p><h5 id="比较指令的说明"><a href="#比较指令的说明" class="headerlink" title="比较指令的说明"></a>比较指令的说明</h5><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_14-37-24.png"></p><h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><ol><li>类型转换指令可以将两种不同的数值类型进行相互转化</li><li>这些住转化操作一般用于实现用户带码中的显示类型转化操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题</li></ol><h4 id="宽化类型转化"><a href="#宽化类型转化" class="headerlink" title="宽化类型转化"></a>宽化类型转化</h4><p>小范围类型向大范围类型转化的安全转化</p><ul><li>int –&gt; long、float或者double类型 对应的指令为：i2l, i2f, i2d</li><li>从long–&gt;float、double类型。对应的类型指令为：l2f, l2d</li><li>float–&gt;double  对应的指令为: f2d</li></ul><p>简化为： int–&gt;long–&gt;float–&gt;double</p><p><strong>精度损失问题</strong></p><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_15-12-47.png"><img src="/%5Ctushi%5CSnipaste_2023-05-28_15-21-18.png"></p><h4 id="窄化类型处理"><a href="#窄化类型处理" class="headerlink" title="窄化类型处理"></a>窄化类型处理</h4><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_15-37-53.png"><img src="/%5Ctushi%5CSnipaste_2023-05-28_16-11-25.png"></p><h2 id="创建类和数组的实例的指令"><a href="#创建类和数组的实例的指令" class="headerlink" title="创建类和数组的实例的指令"></a>创建类和数组的实例的指令</h2><p>可进一步分为创建指令，字段访问指令、数组操作指令、类型检查指令</p><h3 id="创建指令"><a href="#创建指令" class="headerlink" title="创建指令"></a>创建指令</h3><p><img src="/%5Ctushi%5CSnipaste_2023-05-30_18-07-01.png"></p><pre><code class="hljs java"><span class="hljs-comment">//1.创建指令</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newInstance</span><span class="hljs-params">()</span> &#123;       <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();       <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;atguigu.avi&quot;</span>);   &#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newArray</span><span class="hljs-params">()</span> &#123;       <span class="hljs-type">int</span>[] intArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];       Object[] objArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];       <span class="hljs-type">int</span>[][] mintArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];       String[][] strArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>][];   &#125;</code></pre><pre><code class="hljs java"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java/lang/Object&gt; <span class="hljs-number">3</span> dup    <span class="hljs-comment">// 复制一个引用   在存储的时候调用一个引用，在调用的时候同样会消耗一个引用</span> <span class="hljs-number">4</span> invokespecial #<span class="hljs-number">1</span> &lt;java/lang/Object.&lt;init&gt; : ()V&gt; <span class="hljs-number">7</span> astore_1 <span class="hljs-number">8</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">3</span> &lt;java/io/File&gt;<span class="hljs-number">11</span> dup<span class="hljs-number">12</span> ldc #<span class="hljs-number">4</span> &lt;atguigu.avi&gt;<span class="hljs-number">14</span> invokespecial #<span class="hljs-number">5</span> &lt;java/io/File.&lt;init&gt; : (Ljava/lang/String;)V&gt;<span class="hljs-number">17</span> astore_2<span class="hljs-number">18</span> <span class="hljs-keyword">return</span>             <span class="hljs-number">0</span> bipush <span class="hljs-number">10</span> <span class="hljs-number">2</span> newarray <span class="hljs-number">10</span> (<span class="hljs-type">int</span>) <span class="hljs-number">4</span> astore_1 <span class="hljs-number">5</span> bipush <span class="hljs-number">10</span> <span class="hljs-number">7</span> anewarray #<span class="hljs-number">2</span> &lt;java/lang/Object&gt;<span class="hljs-number">10</span> astore_2<span class="hljs-number">11</span> bipush <span class="hljs-number">10</span><span class="hljs-number">13</span> bipush <span class="hljs-number">10</span><span class="hljs-number">15</span> multianewarray #<span class="hljs-number">6</span> &lt;[[I&gt; dim <span class="hljs-number">2</span><span class="hljs-number">19</span> astore_3<span class="hljs-number">20</span> bipush <span class="hljs-number">10</span><span class="hljs-number">22</span> anewarray #<span class="hljs-number">7</span> &lt;[Ljava/lang/String;&gt;   <span class="hljs-comment">// 这里只是一维数组 原因：因为这种情况在堆中只开辟了一个长度为十的数组，里面每个元的类型strArry[]这在里没有做初始化，全部为null</span><span class="hljs-number">25</span> astore <span class="hljs-number">4</span><span class="hljs-number">27</span> <span class="hljs-keyword">return</span></code></pre><h3 id="字段访问指令"><a href="#字段访问指令" class="headerlink" title="字段访问指令"></a>字段访问指令</h3><p><img src="/%5Ctushi%5CSnipaste_2023-05-30_18-28-43.png"><img src="/%5Ctushi%5CSnipaste_2023-05-30_18-38-00.png"><img src="/%5Ctushi%5CSnipaste_2023-05-30_18-38-43.png"><img src="/%5Ctushi%5CSnipaste_2023-05-30_18-38-58.png"></p><blockquote><p>getstatic和putstatic指令的主要区别在于getstatic用于获取静态字段的值，而putstatic用于设置静态字段的值。</p><p>getstatic指令的作用是将一个静态字段的值读取到操作数栈中，而putstatic指令的作用则是将一个操作数栈中的值写入到一个静态字段中去。  </p><blockquote><p>操作的是 值 ！！！！</p></blockquote><p>不同之处在于getstatic从静态字段中获取值并放入操作数栈顶，而putstatic从操作数栈顶取值并放入静态字段中。从这个角度来看，两者的操作方向是互相对称的。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrderId</span><span class="hljs-params">()</span>&#123;      <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();      order.id = <span class="hljs-number">1001</span>;      System.out.println(order.id);      Order.name = <span class="hljs-string">&quot;ORDER&quot;</span>;      System.out.println(Order.name);  &#125;</code></pre><pre><code class="hljs java"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">11</span> &lt;com/jvm/中篇/chapter02/src/com/atguigu/java/Order&gt; <span class="hljs-number">3</span> dup <span class="hljs-number">4</span> invokespecial #<span class="hljs-number">12</span> &lt;com/jvm/中篇/chapter02/src/com/atguigu/java/Order.&lt;init&gt; : ()V&gt; <span class="hljs-number">7</span> astore_1 <span class="hljs-number">8</span> aload_1 <span class="hljs-number">9</span> sipush <span class="hljs-number">1001</span><span class="hljs-number">12</span> putfield #<span class="hljs-number">13</span> &lt;com/jvm/中篇/chapter02/src/com/atguigu/java/Order.id : I&gt;<span class="hljs-number">15</span> getstatic #<span class="hljs-number">8</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<span class="hljs-number">18</span> aload_1<span class="hljs-number">19</span> getfield #<span class="hljs-number">13</span> &lt;com/jvm/中篇/chapter02/src/com/atguigu/java/Order.id : I&gt;<span class="hljs-number">22</span> invokevirtual #<span class="hljs-number">14</span> &lt;java/io/PrintStream.println : (I)V&gt;<span class="hljs-number">25</span> ldc #<span class="hljs-number">15</span> &lt;ORDER&gt;<span class="hljs-number">27</span> putstatic #<span class="hljs-number">16</span> &lt;com/jvm/中篇/chapter02/src/com/atguigu/java/Order.name : Ljava/lang/String;&gt;  <span class="hljs-comment">// 注：此时在操作数栈中只剩下了 ORDER 但此时因机构不需要将对象加载进来 ，应为静态变量对应的是类所以不需要对象的引用 以及不需要aload了</span><span class="hljs-number">30</span> getstatic #<span class="hljs-number">8</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<span class="hljs-number">33</span> getstatic #<span class="hljs-number">16</span> &lt;com/jvm/中篇/chapter02/src/com/atguigu/java/Order.name : Ljava/lang/String;&gt;<span class="hljs-number">36</span> invokevirtual #<span class="hljs-number">10</span> &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;<span class="hljs-number">39</span> <span class="hljs-keyword">return</span></code></pre><h3 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h3><p><img src="/%5Ctushi%5CSnipaste_2023-05-30_18-58-59.png"></p><blockquote><p>注：这里store修改的就不是局部变量表了 而是将结果存储到堆空间中</p></blockquote><p><img src="/%5Ctushi%5CSnipaste_2023-05-30_19-11-05.png"></p><pre><code class="hljs java"><span class="hljs-comment">//3.数组操作指令</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArray</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span>[] intArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];        intArray[<span class="hljs-number">3</span>] = <span class="hljs-number">20</span>;        System.out.println(intArray[<span class="hljs-number">1</span>]);        <span class="hljs-type">boolean</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">10</span>];        arr[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;    &#125;</code></pre><pre><code class="hljs java"> <span class="hljs-number">0</span> bipush <span class="hljs-number">10</span> <span class="hljs-number">2</span> newarray <span class="hljs-number">10</span> (<span class="hljs-type">int</span>) <span class="hljs-number">4</span> astore_1 <span class="hljs-number">5</span> aload_1       <span class="hljs-comment">// 数组引用 </span> <span class="hljs-number">6</span> iconst_3      <span class="hljs-comment">// 索引</span> <span class="hljs-number">7</span> bipush <span class="hljs-number">20</span>     <span class="hljs-comment">// 值</span> <span class="hljs-number">9</span> iastore<span class="hljs-number">10</span> getstatic #<span class="hljs-number">8</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<span class="hljs-number">13</span> aload_1      <span class="hljs-comment">// 数组引用</span><span class="hljs-number">14</span> iconst_1     <span class="hljs-comment">// 索引</span><span class="hljs-number">15</span> iaload<span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">14</span> &lt;java/io/PrintStream.println : (I)V&gt;<span class="hljs-number">19</span> bipush <span class="hljs-number">10</span><span class="hljs-number">21</span> newarray <span class="hljs-number">4</span> (<span class="hljs-type">boolean</span>)<span class="hljs-number">23</span> astore_2<span class="hljs-number">24</span> aload_2      <span class="hljs-comment">//数组引用</span><span class="hljs-number">25</span> iconst_1     <span class="hljs-comment">//索引</span><span class="hljs-number">26</span> iconst_1     <span class="hljs-comment">//值</span><span class="hljs-number">27</span> bastore<span class="hljs-number">28</span> <span class="hljs-keyword">return</span></code></pre><p>​</p><h3 id="类型检查指令"><a href="#类型检查指令" class="headerlink" title="类型检查指令"></a>类型检查指令</h3><p><img src="/%5Ctushi%5CSnipaste_2023-05-30_19-51-13.png"></p><pre><code class="hljs java"><span class="hljs-comment">//4.类型检查指令</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">checkCast</span><span class="hljs-params">(Object obj)</span> &#123;        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String) &#123; <span class="hljs-comment">// 判断obj是否是 String的一个实例</span>            <span class="hljs-keyword">return</span> (String) obj;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;    &#125;</code></pre><pre><code class="hljs java"> <span class="hljs-number">0</span> aload_1 <span class="hljs-number">1</span> <span class="hljs-keyword">instanceof</span> #<span class="hljs-number">17</span> &lt;java/lang/String&gt; <span class="hljs-number">4</span> ifeq <span class="hljs-number">12</span> (+<span class="hljs-number">8</span>) <span class="hljs-number">7</span> aload_1 <span class="hljs-number">8</span> checkcast #<span class="hljs-number">17</span> &lt;java/lang/String&gt;<span class="hljs-number">11</span> areturn<span class="hljs-number">12</span> aconst_null<span class="hljs-number">13</span> areturn</code></pre><h2 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h2><h3 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><p><img src="/%5Ctushi%5CSnipaste_2023-05-30_19-59-04.png"></p><blockquote><p>静态类型绑定的方法不存在方法的重写</p><blockquote><p>**invokespecial  invokestatic **调用的方法中不存在方法的重写</p></blockquote></blockquote><pre><code class="hljs java">eg: MethodInvokeReturnTest 以及 InterfaceMethodTest</code></pre><h3 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h3><p><img src="/%5Ctushi%5CSnipaste_2023-05-30_20-15-59.png"><img src="/%5Ctushi%5CSnipaste_2023-05-30_20-18-02.png"></p><h2 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h2><p><img src="/%5Ctushi%5CSnipaste_2023-05-30_20-25-27.png"><img src="/%5Ctushi%5CSnipaste_2023-05-30_20-26-00.png"></p><p>没有 变量调用（或者说 在整个方法周期中没有对该数据进行调用） 会将操作数栈中的数据pop出去</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#123;    bar();&#125;<span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-number">0</span> aload_0<span class="hljs-number">1</span> invokevirtual #<span class="hljs-number">5</span> &lt;com/jvm/中篇/chapter02/src/com/atguigu/java/StackOperateTest.bar : ()J&gt;<span class="hljs-number">4</span> pop2<span class="hljs-number">5</span> <span class="hljs-keyword">return</span></code></pre><h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><p>大体上分为：</p><ul><li>比较指令</li><li>条件跳转指令</li><li>比较条件跳转指令</li><li>多条件分支跳转指令</li><li>无条件跳转指令</li></ul><h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><p><img src="/%5Ctushi%5CSnipaste_2023-05-28_14-37-24.png"></p><p>数值类型的数据才可以比较大小  double long float</p><p>boolean、引用数据类型不可以比较大小</p><p>​</p><h3 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h3><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_08-24-49.png"><img src="/%5Ctushi%5CSnipaste_2023-06-01_08-26-38.png"></p><pre><code class="hljs java"><span class="hljs-comment">//1.条件跳转指令</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compare1</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(a != <span class="hljs-number">0</span>)&#123;            a = <span class="hljs-number">10</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            a = <span class="hljs-number">20</span>;        &#125;    &#125;</code></pre><pre><code class="hljs java"> <span class="hljs-number">0</span> iconst_0 <span class="hljs-number">1</span> istore_1 <span class="hljs-number">2</span> iload_1 <span class="hljs-number">3</span> ifeq <span class="hljs-number">12</span> (+<span class="hljs-number">9</span>) <span class="hljs-number">6</span> bipush <span class="hljs-number">10</span> <span class="hljs-number">8</span> istore_1 <span class="hljs-number">9</span> goto <span class="hljs-number">15</span> (+<span class="hljs-number">6</span>)<span class="hljs-number">12</span> bipush <span class="hljs-number">20</span><span class="hljs-number">14</span> istore_1<span class="hljs-number">15</span> <span class="hljs-keyword">return</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compare3</span><span class="hljs-params">()</span> &#123;       <span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;       <span class="hljs-type">long</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;       System.out.println(i1 &gt; l1);   &#125;</code></pre><pre><code class="hljs java"> <span class="hljs-number">0</span> bipush <span class="hljs-number">10</span> <span class="hljs-number">2</span> istore_1 <span class="hljs-number">3</span> ldc2_w #<span class="hljs-number">6</span> &lt;<span class="hljs-number">20</span>&gt; <span class="hljs-number">6</span> lstore_2 <span class="hljs-number">7</span> getstatic #<span class="hljs-number">4</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<span class="hljs-number">10</span> iload_1<span class="hljs-number">11</span> i2l      <span class="hljs-comment">//先进行宽化处理</span><span class="hljs-number">12</span> lload_2<span class="hljs-number">13</span> lcmp     <span class="hljs-comment">//比较指令进行比较  是-1</span><span class="hljs-number">14</span> ifle <span class="hljs-number">21</span> (+<span class="hljs-number">7</span>)  <span class="hljs-comment">// 条件符合进行跳转</span><span class="hljs-number">17</span> iconst_1<span class="hljs-number">18</span> goto <span class="hljs-number">22</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">21</span> iconst_0<span class="hljs-number">22</span> invokevirtual #<span class="hljs-number">5</span> &lt;java/io/PrintStream.println : (Z)V&gt;<span class="hljs-number">25</span> <span class="hljs-keyword">return</span>            注：在sysyem.out.print的时候传给的数字，按理说输出的应该也是数字 但是实际输出的是<span class="hljs-type">boolean</span> 查看字节码后发现 &lt;println : (Z)V&gt;，sysyem.out.print使用的<span class="hljs-type">boolean</span>类型的，所以输出的也是<span class="hljs-type">boolean</span>类型</code></pre><p>只有float double long才会进行比较指令和条件跳转指令相结合</p><p>如果本身是byte boolean char int 直接使用条件跳转指令(单个)</p><h3 id="比较条件跳转指令"><a href="#比较条件跳转指令" class="headerlink" title="比较条件跳转指令"></a>比较条件跳转指令</h3><p>如果是两个int或者引用类型进行比较 则需要使用条件跳转指令</p><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_09-01-12.png"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ifCompare2</span><span class="hljs-params">()</span> &#123;       <span class="hljs-type">short</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;       <span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;       System.out.println(s1 &gt; b1);   &#125;</code></pre><pre><code class="hljs java"> <span class="hljs-number">0</span> bipush <span class="hljs-number">9</span> <span class="hljs-number">2</span> istore_1 <span class="hljs-number">3</span> bipush <span class="hljs-number">10</span> <span class="hljs-number">5</span> istore_2 <span class="hljs-number">6</span> getstatic #<span class="hljs-number">4</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt; <span class="hljs-number">9</span> iload_1<span class="hljs-number">10</span> iload_2<span class="hljs-number">11</span> if_icmple <span class="hljs-number">18</span> (+<span class="hljs-number">7</span>)<span class="hljs-number">14</span> iconst_1<span class="hljs-number">15</span> goto <span class="hljs-number">19</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">18</span> iconst_0<span class="hljs-number">19</span> invokevirtual #<span class="hljs-number">5</span> &lt;java/io/PrintStream.println : (Z)V&gt;<span class="hljs-number">22</span> <span class="hljs-keyword">return</span></code></pre><h3 id="多条件分支跳转指令"><a href="#多条件分支跳转指令" class="headerlink" title="多条件分支跳转指令"></a>多条件分支跳转指令</h3><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_09-22-51.png"></p><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_09-23-08.png"></p><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_09-23-33.png"></p><pre><code class="hljs java"><span class="hljs-comment">//jdk7新特性：引入String类型</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swtich3</span><span class="hljs-params">(String season)</span>&#123;        <span class="hljs-keyword">switch</span>(season)&#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;SPRING&quot;</span>:<span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;SUMMER&quot;</span>:<span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;AUTUMN&quot;</span>:<span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;WINTER&quot;</span>:<span class="hljs-keyword">break</span>;        &#125;    &#125;</code></pre><pre><code class="hljs java">  <span class="hljs-number">0</span> aload_1  <span class="hljs-number">1</span> astore_2  <span class="hljs-number">2</span> iconst_m1  <span class="hljs-number">3</span> istore_3  <span class="hljs-number">4</span> aload_2  <span class="hljs-number">5</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/String.hashCode : ()I&gt;  <span class="hljs-number">8</span> lookupswitch <span class="hljs-number">4</span>-<span class="hljs-number">1842350579</span>:  <span class="hljs-number">52</span> (+<span class="hljs-number">44</span>)-<span class="hljs-number">1837878353</span>:  <span class="hljs-number">66</span> (+<span class="hljs-number">58</span>)-<span class="hljs-number">1734407483</span>:  <span class="hljs-number">94</span> (+<span class="hljs-number">86</span>)<span class="hljs-number">1941980694</span>:  <span class="hljs-number">80</span> (+<span class="hljs-number">72</span>)<span class="hljs-keyword">default</span>:  <span class="hljs-number">105</span> (+<span class="hljs-number">97</span>) <span class="hljs-number">52</span> aload_2 <span class="hljs-number">53</span> ldc #<span class="hljs-number">12</span> &lt;SPRING&gt; <span class="hljs-number">55</span> invokevirtual #<span class="hljs-number">13</span> &lt;java/lang/String.equals : (Ljava/lang/Object;)Z&gt; <span class="hljs-number">58</span> ifeq <span class="hljs-number">105</span> (+<span class="hljs-number">47</span>) <span class="hljs-number">61</span> iconst_0 <span class="hljs-number">62</span> istore_3 <span class="hljs-number">63</span> goto <span class="hljs-number">105</span> (+<span class="hljs-number">42</span>) <span class="hljs-number">66</span> aload_2 <span class="hljs-number">67</span> ldc #<span class="hljs-number">14</span> &lt;SUMMER&gt; <span class="hljs-number">69</span> invokevirtual #<span class="hljs-number">13</span> &lt;java/lang/String.equals : (Ljava/lang/Object;)Z&gt; <span class="hljs-number">72</span> ifeq <span class="hljs-number">105</span> (+<span class="hljs-number">33</span>) <span class="hljs-number">75</span> iconst_1 <span class="hljs-number">76</span> istore_3 <span class="hljs-number">77</span> goto <span class="hljs-number">105</span> (+<span class="hljs-number">28</span>) <span class="hljs-number">80</span> aload_2 <span class="hljs-number">81</span> ldc #<span class="hljs-number">15</span> &lt;AUTUMN&gt; <span class="hljs-number">83</span> invokevirtual #<span class="hljs-number">13</span> &lt;java/lang/String.equals : (Ljava/lang/Object;)Z&gt; <span class="hljs-number">86</span> ifeq <span class="hljs-number">105</span> (+<span class="hljs-number">19</span>) <span class="hljs-number">89</span> iconst_2 <span class="hljs-number">90</span> istore_3 <span class="hljs-number">91</span> goto <span class="hljs-number">105</span> (+<span class="hljs-number">14</span>) <span class="hljs-number">94</span> aload_2 <span class="hljs-number">95</span> ldc #<span class="hljs-number">16</span> &lt;WINTER&gt; <span class="hljs-number">97</span> invokevirtual #<span class="hljs-number">13</span> &lt;java/lang/String.equals : (Ljava/lang/Object;)Z&gt;<span class="hljs-number">100</span> ifeq <span class="hljs-number">105</span> (+<span class="hljs-number">5</span>)<span class="hljs-number">103</span> iconst_3<span class="hljs-number">104</span> istore_3<span class="hljs-number">105</span> iload_3<span class="hljs-number">106</span> tableswitch <span class="hljs-number">0</span> to <span class="hljs-number">3</span><span class="hljs-number">0</span>:  <span class="hljs-number">136</span> (+<span class="hljs-number">30</span>)<span class="hljs-number">1</span>:  <span class="hljs-number">139</span> (+<span class="hljs-number">33</span>)<span class="hljs-number">2</span>:  <span class="hljs-number">142</span> (+<span class="hljs-number">36</span>)<span class="hljs-number">3</span>:  <span class="hljs-number">145</span> (+<span class="hljs-number">39</span>)<span class="hljs-keyword">default</span>:  <span class="hljs-number">145</span> (+<span class="hljs-number">39</span>)<span class="hljs-number">136</span> goto <span class="hljs-number">145</span> (+<span class="hljs-number">9</span>)<span class="hljs-number">139</span> goto <span class="hljs-number">145</span> (+<span class="hljs-number">6</span>)<span class="hljs-number">142</span> goto <span class="hljs-number">145</span> (+<span class="hljs-number">3</span>)<span class="hljs-number">145</span> <span class="hljs-keyword">return</span></code></pre><h3 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h3><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_09-38-17.png"></p><pre><code class="hljs java"><span class="hljs-comment">//4.无条件跳转指令</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">whileInt</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>) &#123;            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.com&quot;</span>;            i++;        &#125;    &#125;</code></pre><pre><code class="hljs java"> <span class="hljs-number">0</span> iconst_0 <span class="hljs-number">1</span> istore_1 <span class="hljs-number">2</span> iload_1 <span class="hljs-number">3</span> bipush <span class="hljs-number">100</span> <span class="hljs-number">5</span> if_icmpge <span class="hljs-number">17</span> (+<span class="hljs-number">12</span>) <span class="hljs-number">8</span> ldc #<span class="hljs-number">17</span> &lt;atguigu.com&gt;<span class="hljs-number">10</span> astore_2<span class="hljs-number">11</span> iinc <span class="hljs-number">1</span> by <span class="hljs-number">1</span><span class="hljs-number">14</span> goto <span class="hljs-number">2</span> (-<span class="hljs-number">12</span>)<span class="hljs-number">17</span> <span class="hljs-keyword">return</span></code></pre><p>从字节码角度讲 for 和 while 没有任何区别 但从语法角度讲 while 和 for中i的作用域范围不同</p><h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><h4 id="抛出异常指令"><a href="#抛出异常指令" class="headerlink" title="抛出异常指令"></a>抛出异常指令</h4><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_09-55-37.png"></p><h4 id="异常处理与异常表"><a href="#异常处理与异常表" class="headerlink" title="异常处理与异常表"></a>异常处理与异常表</h4><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_10-03-46.png"></p><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_10-25-04.png"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryCatch</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">try</span>&#123;        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:/hello.txt&quot;</span>);        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);        <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello!&quot;</span>;    &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">catch</span>(RuntimeException e)&#123;        e.printStackTrace();    &#125;&#125;</code></pre><h3 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h3><h4 id="方法级同步"><a href="#方法级同步" class="headerlink" title="方法级同步"></a>方法级同步</h4><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_10-28-21.png"></p><p><img src="/%5Ctushi%5CSnipaste_2023-06-01_10-50-49.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Java字节码对于JVM就像汇编对于计算机，属于基本执行指令&lt;/p&gt;
&lt;p&gt;java虚拟机有一个字节长度的、代表着某种特定操作含义的数字（称</summary>
      
    
    
    
    
    <category term="CLASS" scheme="http://example.com/tags/CLASS/"/>
    
  </entry>
  
  <entry>
    <title>slot槽位映射方案</title>
    <link href="http://example.com/2023/09/13/slot%E6%A7%BD%E4%BD%8D%E6%98%A0%E5%B0%84%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2023/09/13/slot%E6%A7%BD%E4%BD%8D%E6%98%A0%E5%B0%84%E6%96%B9%E6%A1%88/</id>
    <published>2023-09-13T13:42:04.000Z</published>
    <updated>2024-03-15T13:43:28.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="slot槽位映射方案"><a href="#slot槽位映射方案" class="headerlink" title="slot槽位映射方案"></a>slot槽位映射方案</h1><h3 id="slot槽位映射，一般业界有三种解决方案"><a href="#slot槽位映射，一般业界有三种解决方案" class="headerlink" title="slot槽位映射，一般业界有三种解决方案"></a>slot槽位映射，一般业界有三种解决方案</h3><ol><li><p>哈希取余分区(小厂)</p><p>2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</p><p><strong>优点</strong>：</p><ul><li>简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据 支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求 (并维护这些请求的信息)， 起到负载均衡+分而治之的作用。</li></ul><p><strong>缺点：</strong></p><ul><li>原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化: Hash(key)&#x2F;3会 变成Hash(key) &#x2F;?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。<br>某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</li></ul></li><li><p>一致性哈希算法分区(中厂)</p><ul><li><p>是什么？</p><p>一致性Hash算法背景是在1997年由麻省理工学院提出的，设计目标是<strong>为了解决分布式缓存数据变动和映射问题</strong>，某个机器宕机了，分母数量改变了，自然取余数不行了 </p></li><li><p>能干嘛？</p><p>提出一致性Hash解决方案。目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系</p></li><li><p>3大步骤</p><p>算法构建一致性哈希环</p><p>一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(O&#x3D; 2^32),这样让它逻辑上形成了一个环形空间。<br>它也是按照使用取模的方法，<strong>前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性Hash算法是对2^32取模，简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环</strong>，如 假设某哈希函数H的值空间为0-2^32-1(即哈希值是一个32位无符号整形），整个哈希环如下图:整个空间<strong>按顺时针方向组织</strong>，圆环的正上方的点代表0，O点右侧的第一个点代表1，以此类推，2、3、4、……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1，0和2个32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p><p><strong>服务器IP节点映射</strong></p><p>将集群中各个IP节点映射到环上的某一个位置。<br>将各个服务器使用Hash进行一个哈希映射，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的<strong>哈希函数</strong>计算(hash(ip))，使用IP地址哈希后在环空间的位置如下:</p><p> <strong>key落到服务器的落键规则</strong></p><p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，<strong>从此位置沿环顺时针“行走”</strong>，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。<br>如我们有Object A、 Object B、 Object C. object D四个数据对象，经过哈希计算后，在环空间上的位置如下:根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p></li><li><p>优点</p><p>一致性哈希算法的容错性 ：假设Node C宕机，可以看到此时对象A、B、D不会受到影响。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器**(即沿着逆时针方向行走遇到的第一台服务器）之间数据<strong>，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据</strong>且这些数据会转移到D进行存储**。</p><p>一致性哈希算法的扩展性</p><p>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，不会导致hash取余全部数据重新洗牌。</p></li><li><p>缺点</p><p>一致性哈希算法的数据倾斜问题</p><p>一致性Hash算法在服务<strong>节点太少时</strong>，容易因为节点分布不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上)问题，例如系统中只有两台服务器:</p></li><li><p>小总结</p><p>为了在节点数目发生改变时尽可能少的迁移数据</p><p>将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。</p><p>优点 ：加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</p><p>缺点 ：数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p></li></ul></li><li><p>哈希槽分区(大厂)</p><ul><li><p>是什么？ HASH_SLOT &#x3D; CRC16(key) mod 16384</p><ol><li><p>为什么出现</p><p>哈希槽实质就是一个数组，数组[0, 2^14 - 1]形成hash slot空间</p></li><li><p>能干什么</p><p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽(slot)，用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里面放的是数据。</p><p>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配</p></li><li><p>多少个hash</p><p>一个集群只能有16384个槽，编号0-16383(0-2^14-1)。这些槽会分配给集群中的所有主节点，分配策略没有要求。</p><p>集群会记录节点和槽的对应关系，解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取模，余数是几key就落入对应的槽里。HASH_SLOT &#x3D; CRC16(key) mod 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p></li></ol></li><li><p>哈希槽计算</p><p>Redis集群中内置了16384个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在Redis集群中放置一个key-valuel时，redis先对key使用crc16算法算出一个结果然后用结果对16384求余数[ CRC16(key) % 16384]，这样每个key都会对应一个编号在0-16383之间的哈希槽，也就是映射到某个节点上。如下代码，key之A、B在Node2， key之C落在Node3上</p></li></ul><h3 id="经典面试题：为什么Redis集群的最大槽数是16384个？"><a href="#经典面试题：为什么Redis集群的最大槽数是16384个？" class="headerlink" title="经典面试题：为什么Redis集群的最大槽数是16384个？"></a>经典面试题：为什么Redis集群的最大槽数是16384个？</h3><p>Redis集群并没有使用一致性hash而是引入了哈希槽的概念。Redis 集群有16384个哈希糟，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。但为什么哈希槽的数量是16384 (2^14）个呢？</p><p>CRC16算法产生的hash值有16bit，该算法可以产生2^16&#x3D;65536个值。<br>换句话说值是分布在0～65535之间，有更大的65536不用为什么只用16384就够?</p><p>作者在做mod运算的时候，为什么不mod65536，而选择mod16384? $\textcolor{blue}{\large HASH_SLOT &#x3D; CRC16(key) mod 65536为什么没启用？</p><p>作者回答：<a href="https://github.com/redis/redis/issues/2576">https://github.com/redis/redis/issues/2576</a></p><p>说明1：</p><p>正常的心跳数据包带有节点的完整配置，可以用幂等方式用旧的节点替换旧节点，以便更新旧的配置。<br>这意味着它们包含原始节点的插槽配置，该节点使用2k的空间和16k的插槽，但是会使用8k的空间（使用65k的插槽）。同时，由于其他设计折衷，Redis集群不太可能扩展到1000个以上的主节点。<br>因此16k处于正确的范围内，以确保每个主机具有足够的插槽，最多可容纳1000个矩阵，但数量足够少，可以轻松地将插槽配置作为原始位图传播。请注意，在小型群集中，位图将难以压缩，因为当N较小时，位图将设置的slot &#x2F; N位占设置位的很大百分比。</p><p>说明2：</p><p> <strong>(1)如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。</strong><br>在消息头中最占空间的是myslots[CLUSTER_SLOTS&#x2F;8]。当槽位为65536时，这块的大小是:65536÷8÷1024&#x3D;8kb</p><p>在消息头中最占空间的是myslots[CLUSTER_SLOTS&#x2F;8]。当槽位为16384时，这块的大小是:16384∶8∶1024&#x3D;2kb</p><p>因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。<br><strong>2)redis的集群主节点数量基本不可能超过1000个。</strong><br>集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点数量超过1000个。那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。<br><strong>(3)槽位越小，节点少的情况下，压缩比高，容易传输</strong><br>Redis主节点的配置信息中它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率slots &#x2F;N很高的话(N表示节点数)， bitmap的压缩率就很低。如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。</p><p>计算结论</p><p>Redis集群中内置了16384个哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在Redis集群中放置-一个key-value时， redis先对key使用crc16算法算出一个结果然后用结果对16384求余数[ CRC16(key) % 16384]， 这样每个key都会对应一个编号在0-16383之间的哈希槽，也就是映射到某个节点上。如下代码，key之A、B在Node2， key之C落在Node3上</p></li></ol><h3 id="Redis集群不保证强一致性"><a href="#Redis集群不保证强一致性" class="headerlink" title="Redis集群不保证强一致性"></a>Redis集群不保证强一致性</h3><p>redis集群不保证强一致性，这意味着在特定的条件下，Redis集群可能会丢掉一些被系统收到的写入请求命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;slot槽位映射方案&quot;&gt;&lt;a href=&quot;#slot槽位映射方案&quot; class=&quot;headerlink&quot; title=&quot;slot槽位映射方案&quot;&gt;&lt;/a&gt;slot槽位映射方案&lt;/h1&gt;&lt;h3 id=&quot;slot槽位映射，一般业界有三种解决方案&quot;&gt;&lt;a href=&quot;#s</summary>
      
    
    
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>JUC高并发编程</title>
    <link href="http://example.com/2023/08/12/JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2023/08/12/JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2023-08-12T12:07:29.000Z</published>
    <updated>2024-03-12T12:12:23.151Z</updated>
    
    <content type="html"><![CDATA[<p><strong>推荐阅读</strong></p><p><a href="https://blog.csdn.net/zhaojianting/article/details/97664370">彻底理解Runnable和Thread的区别_thread runnable-CSDN博客</a></p><p><a href="https://juejin.cn/post/6917526751199526920">HashMap为什么线程不安全 - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/weixin_44575037/article/details/105513014">协程的概念，为什么要用协程，以及协程的使用_协程的作用,优缺点-CSDN博客</a></p><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。在进行并发编程时，如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题。</p><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><ol><li></li></ol><p>this.wait()会释放锁</p><p>this.notifyAll()</p><p>自旋(while)一下就不会虚假唤醒</p><ol start="2"><li></li></ol><p>Lock lock &#x3D; new ReentrantLock()</p><p>Condition condition &#x3D; lock.newCondition()</p><p>condition.await()</p><p>condition.signal()</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li><p>ArrayList</p><p>线程不安全</p></li><li><p>Vector</p><p>线程安全</p></li><li><p>Collections.synchronizedList()</p><p>线程安全</p></li><li><p>CopyOnWriteArrayList()</p><p>写时复制技术</p></li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li><p>HashSet</p><p>线程不安全</p></li><li><p>CopyOnWriteArraySet()</p><p>线程安全</p></li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li><p>HashMap</p><p>线程不安全</p></li><li><p>ConcurrentHashMap</p><p>线程安全</p></li></ul><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap使用了<strong>锁分段技术</strong>，就是每一把锁只锁其中一部分数据。</p><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。</p><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>CAS实现</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池(thread pool) ：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p><p><strong>特点：</strong></p><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h4 id="线程池使用方式"><a href="#线程池使用方式" class="headerlink" title="线程池使用方式"></a>线程池使用方式</h4><p>都使用了ThreadPoolExecutor</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//一池五线程</span>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            threadPool.execute(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;办理业务&quot;</span>);            &#125;);        &#125;        threadPool.shutdown();        <span class="hljs-comment">//一池一线程</span>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">singleThreadExecutor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            singleThreadExecutor.execute(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;办理业务&quot;</span>);            &#125;);        &#125;        singleThreadExecutor.shutdown();        <span class="hljs-comment">//一池可扩容</span>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cachedThreadPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            cachedThreadPool.execute(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;办理业务&quot;</span>);            &#125;);        &#125;        cachedThreadPool.shutdown();    &#125;&#125;</code></pre><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><strong>七个参数</strong></p><ul><li>int corePoolSize 常驻线程数量</li><li>int maximumPoolSize 最大线程数量</li><li>long keepAliveTime， TimeUnit unit 线程存活时间，后面为单位</li><li>BlockingQueue<Runnable> workQueue 阻塞对列</li><li>ThreadFactory threadFactory 线程工厂</li><li>RejectedExecutionHandler handler 拒绝策略<ul><li>抛出异常</li><li>调用者运行</li><li>抛弃等待最久的任务</li><li>不做处理</li></ul></li></ul><h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><p>一般使用自定义线程池</p><h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><p>实现线程方式：</p><ul><li><p>继承Thread类</p></li><li><p>实现Runnable接口</p></li></ul><p>使用了静态代理</p><pre><code class="hljs java"><span class="hljs-comment">//优先使用，java单个继承、多个实现</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Threadtest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-comment">//实现run方法</span>&#125;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Threadtest</span>()).start();</code></pre><ul><li>实现Callable接口</li></ul><p>可以有返回值，可以抛出异常</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Threadtest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Object&gt; &#123;    <span class="hljs-comment">//实现call方法</span>&#125;<span class="hljs-comment">//创建执行服务:</span><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ser</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<span class="hljs-comment">//提交执行</span>Future&lt;Object&gt; r1 = ser.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Threadtest</span>());<span class="hljs-comment">//获取结果</span><span class="hljs-type">Object</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> r1.get();ser.shutdown();</code></pre><ul><li>线程池</li></ul><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><strong>用户线程</strong>：是系统的工作线程，会完成该程序需要完成的业务操作</p><p>守护线程：是一种特殊的线程，为某个用户线程服务，再后台默默完成系统性的服务</p><p>默认都是用户线程，守护线程是为其他线程服务的。</p><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>().setDaemon(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置为守护线程 必须在start之前设置</span><span class="hljs-comment">//GC线程就是一个守护线程</span></code></pre><blockquote><p>一个主线程 一个守护线程 ： 主线程结束 用户线程结束</p><p>一个主线程 一个用户线程： 主线程的结束，不会使用户线程结束</p></blockquote><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future接口(FutureTask实现类)定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>集成了：多线程，有返回值，异步，Callable注入，抛出异常，是Future的实现类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;                Thread.sleep(<span class="hljs-number">2000</span>);                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好&quot;</span>;            &#125;        &#125;);        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask).start();        <span class="hljs-keyword">try</span> &#123;            System.out.println(<span class="hljs-string">&quot;会阻塞吗?&quot;</span>);<span class="hljs-comment">//get方法会阻塞等待结果</span>            System.out.println(futureTask.get());        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;<span class="hljs-keyword">try</span>&#123;Timeunit.SECONDs.sleep(t3);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;e.printstackTrace();&#125;</code></pre><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>Future + 线程池异步多线程任务配合，能显著提高程序的执行效率。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>get方法容易导致阻塞，一般建议放在程序最后，当然可以设置超时时间。</p></li><li><p>轮循容易导致CPU空转</p></li></ul><pre><code class="hljs java">FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;                Thread.sleep(<span class="hljs-number">4000</span>);                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好&quot;</span>;            &#125;        &#125;);        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask).start();        <span class="hljs-keyword">try</span> &#123;            System.out.println(<span class="hljs-string">&quot;会阻塞吗?&quot;</span>);            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                <span class="hljs-keyword">if</span> (futureTask.isDone()) &#123;                    System.out.println(futureTask.get());                    <span class="hljs-keyword">break</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//暂停防止轮循</span>                    Thread.sleep(<span class="hljs-number">1000</span>);                    System.out.println(<span class="hljs-string">&quot;正在访问结果...&quot;</span>);                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;            e.printStackTrace();        &#125;</code></pre><p>Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果。</p><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>针对Future缺点，提出了CompletableFuture</p><p>对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果。</p><p>阻塞的方式和异步编程的设计理念相违背，而轮询的方式会耗费无谓的CPU资源。因此，JDK8设计出CompletableFuture。</p><p>CompletableFuture提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。</p><h4 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h4><ul><li>CompletionStage代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段</li><li>一个阶段的计算执行可以是一-个Function, Consumer或者Runnable。 比如: stage.thenApply(x -&gt; square()).thenAccept(X -&gt; System.out.print()).thenRun(O -&gt; System.out.println()</li><li>一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发</li></ul><p>代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段，有些类似Linux系统的管道分隔符传参数。</p><p><strong>该接口方法</strong></p><pre><code class="hljs java">getNow(<span class="hljs-string">&quot;xxxx&quot;</span>)<span class="hljs-comment">//未完成，立即返回xxxx</span>complete(<span class="hljs-string">&quot;xxxx&quot;</span>)<span class="hljs-comment">//是否打断get/join方法，打断get/join就立即返回xxxx</span>    <span class="hljs-comment">//thenApply</span><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);CompletableFuture.supplyAsync(() -&gt; &#123;System.out.println(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;, threadPool).thenApply(f -&gt; &#123;System.out.println(<span class="hljs-number">2</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">2</span> + f;&#125;);threadPool.shutdown();<span class="hljs-comment">//handle 出错了可以往下走</span><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);CompletableFuture.supplyAsync(() -&gt; &#123;System.out.println(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;, threadPool).handle((f, e) -&gt; &#123;System.out.println(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>);;System.out.println(<span class="hljs-number">2</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">2</span> + f;&#125;).handle((f, e) -&gt; &#123;System.out.println(<span class="hljs-number">3</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">3</span> + f;&#125;).whenComplete((v, e) -&gt; &#123;<span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;System.out.println(v);&#125;&#125;).exceptionally(e -&gt; &#123;e.printStackTrace();System.out.println(e.getMessage());<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;);threadPool.shutdown();<span class="hljs-comment">//thenAccept 接收任务处理结果，并消费处理，无返回结果</span><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);CompletableFuture.supplyAsync(() -&gt; &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;, threadPool).thenApply((f) -&gt; &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span> + f;&#125;).thenAccept(r -&gt; &#123;System.out.println(r);&#125;);threadPool.shutdown();<span class="hljs-comment">//thenRun 方法无返回值，其他方法对它无影响</span><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);System.out.println(CompletableFuture.supplyAsync(() -&gt; &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;, threadPool).thenRun(() -&gt; &#123;&#125;).join());;threadPool.shutdown();<span class="hljs-comment">//applyToEither判断谁快</span><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;System.out.println(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;, threadPool);CompletableFuture&lt;Integer&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;System.out.println(<span class="hljs-number">2</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;, threadPool);CompletableFuture&lt;String&gt; res = cf1.applyToEither(cf2, f -&gt; &#123;<span class="hljs-keyword">return</span> f + <span class="hljs-string">&quot; is winer&quot;</span>;&#125;);System.out.println(res.join());threadPool.shutdown();<span class="hljs-comment">//thenCombine结果合并</span>CompletableFuture&lt;Integer&gt; res = cf1.thenCombine(cf2, (x, y) -&gt; &#123;System.out.println(<span class="hljs-string">&quot;join&quot;</span>);<span class="hljs-keyword">return</span> x + y;&#125;);System.out.println(res.join());</code></pre><h4 id="核心静态方法"><a href="#核心静态方法" class="headerlink" title="核心静态方法"></a>核心静态方法</h4><p>推荐用这些方法创建CompletableFuture</p><p><strong>runAsync无返回值</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable, Executor executo)</span>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;System.out.println(Thread.currentThread().getName());&#125;, threadPool);System.out.println(completableFuture.get());threadPool.shutdown();</code></pre><p><strong>supplyAsync有返回值</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span><span class="hljs-comment">//没有指定线程池，用默认</span>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;System.out.println(Thread.currentThread().getName());<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;&#125;, threadPool);System.out.println(completableFuture.get());threadPool.shutdown();</code></pre><p>从Java8开始引入了CompletableFuture，它是Future的功能增强版，减少阻塞和轮询可以传入回调对象，<br>当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><pre><code class="hljs java"><span class="hljs-comment">//不用使用get阻塞接收</span><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;come in&quot;</span>);<span class="hljs-comment">//System.out.println(1/0);</span>&#125;, threadPool).whenComplete((r, e) -&gt; &#123;<span class="hljs-comment">//自动监听任务是否完成任务</span><span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;System.out.println(<span class="hljs-string">&quot;get result: &quot;</span> + r);&#125;&#125;).exceptionally(e -&gt; &#123;<span class="hljs-comment">//任务出现异常时执行</span>e.printStackTrace();System.out.println(<span class="hljs-string">&quot;error: &quot;</span> + e.getCause() + <span class="hljs-string">&quot;\t&quot;</span> + e.getMessage());<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;);threadPool.shutdown();</code></pre><p>主线程结束时，CompletableFuture默认使用的线程池会立刻关闭，建议使用自定义线程池，并手动关闭。</p><p><strong>Lambda表达式+Stream流式调用+Chain链式调用+Java8函数式接口</strong></p><table><thead><tr><th>函数式接口名称</th><th>方法名称</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td>Runnable</td><td>run</td><td>无参数</td><td>无返回值</td></tr><tr><td>Function</td><td>apply</td><td>1个参数</td><td>有返回值</td></tr><tr><td>Consume</td><td>accept</td><td>1个参数</td><td>无返回值</td></tr><tr><td>Supplier</td><td>get</td><td>没有参数</td><td>有返回值</td></tr><tr><td>BiConsumer</td><td>accept</td><td>2个参数</td><td>无返回值</td></tr></tbody></table><p>join()与get()类似，只是前者不会再编译期间检查异常，运行是报错再说</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，<strong>synchronized</strong>关键字和<strong>Lock</strong>的实现类都是悲观锁，适应写操作频繁的场景。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>认为自己在使用数据时不会有别的线程修改数据或资源，所以不会添加锁。<br>在Java中是通过使用无锁编程来实现，只是在更新数据的时候去判断，之前有没有别的线程更新了这个数据。</p><p>如果这个数据没有被更新，当前线程将自己修改的数据成功写入。<br>如果这个数据已经被其它线程更新，则根据不同的实现执行不同的操作，比如放弃修改、重试抢锁等等</p><p><strong>判断规则</strong></p><ul><li>版本号机制</li><li>CAS算法</li></ul><p>适合读频繁的场景</p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p><strong>synchronized使用的三种方式：</strong></p><ul><li><p>作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁。</p><p>调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置。如果设置了，执行线程会将先持有monitor锁，然后再执行方法，最后在方法完成(无论是正常完成还是非正常完成)时释放monitor</p></li><li><p>作用于代码块，对括号里配置的对象加锁。</p><p>synchronized同步代码块实现使用的是monitorenter和monitorexit指令，来保证持有锁，释放锁。会而外多加一个monitorexit，为了出现异常时也能释放锁。</p></li><li><p>作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁。</p><p>ACC_STATIC，ACC_SYNCHRONIZED访问标志区分该方法是否静态同步方法</p></li></ul><p><strong>为什么任何一个对象都能成为一个锁呢？</strong></p><p>objectMonitor.java -&gt; objectMonitor.cpp -&gt; objectMonitor.hpp</p><p>因为monitor采用objectMonitor实现的</p><p><strong>什么是管程monitor</strong></p><p>管程(英语: Monitors, 也称为监视器)是一种程序结构，结构内的多个子程序(对象或模块)形成的多个工作线程互斥访问共享资源。<br>这些共享资源一般是硬件设备或一群变量。对共享变量能够进行的所有操作集中在一个模块中。(把信号量及其操作原语“封装”在一个对象内部)<br>管程实现了在一个时间点， 最多只有一个线程在执行管程的某个子程序。管程提供了一种机制，管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendEmail</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">&quot;----sendEmail&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendSMS</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">&quot;-----sendSMS&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;-------he11o&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Phone</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-type">Phone</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p1.sendEmail();        &#125;).start();                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p1.sendSMS();        &#125;).start();    &#125;&#125;</code></pre><p>先Email，后SMS</p><p>一个对象里面如果有多个synchronized方法，某一个时刻内， 只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内， 只能有唯一的一 个线程去访间这些synchronized方法。</p><p>锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Phone</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-type">Phone</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p1.sendEmail();        &#125;).start();                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p1.hello();        &#125;).start();    &#125;&#125;</code></pre><p>先hello，后Email</p><p>普通方法与同步锁无关</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Phone</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-type">Phone</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p1.sendEmail();        &#125;).start();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p2.sendSMS();        &#125;).start();    &#125;&#125;</code></pre><p>先SMS，后Email</p><p>不是同一把锁</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendEmail</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">&quot;----sendEmail&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendSMS</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">&quot;-----sendSMS&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;-------he11o&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Phone</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-type">Phone</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p1.sendEmail();        &#125;).start();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p1.sendSMS();        &#125;).start();    &#125;&#125;</code></pre><p>先Email，后SMS</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Phone</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-type">Phone</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p1.sendEmail();        &#125;).start();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p2.sendSMS();        &#125;).start();    &#125;&#125;</code></pre><p>先Email，后SMS</p><p>上述两种情况，加的是类锁</p><p>对F普通同步方法，锁的是当前实例对象，通常指this，具体的一部部手机，所有的普通同步方法用的都是同把锁-&gt;实例对象本身，对于静态同步方法， 锁的是当前类的Class对象， 如Phone.class唯的一 个模板对于同步方法块，锁的是synchronized括号内的对象。</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendEmail</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">&quot;----sendEmail&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendSMS</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">&quot;-----sendSMS&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;-------he11o&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Phone</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-type">Phone</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p1.sendEmail();        &#125;).start();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p1.sendSMS();        &#125;).start();    &#125;&#125;</code></pre><p>先SMS，后Email</p><p>前者为类锁，后者为对象锁</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Phone</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-type">Phone</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p1.sendEmail();        &#125;).start();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            p2.sendSMS();        &#125;).start();    &#125;&#125;</code></pre><p>先SMS，后Email</p><p>上述两种情况：当个线程试图访问同步代码时 它直先必须得到锁，正常退出或抛出异常时必须释放锁。<br>所有的普通同步方法用的都是同一把锁一实例对象本身，就是new出来的具体实例对象本身，本类this也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁。<br>所有的静态同步方法用的也是同一把锁一类对象本身，就是我们说过的唯一模板Class<br>具体实例对象this和唯一模板class, 这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁。</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>是指多个线程按照申请锁的顺序来获取锁，这里类似排队买票，先来的人先买后来的人在队尾排着，这是公平的。</p><p>Lock lock &#x3D; new ReentrantLock(true)</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并<br>发环境下，有可能造成优先级翻转或者饥饿的状态(某个线程一直得不到锁)。</p><p>Lock lock &#x3D; new ReentrantLock(false)</p><p>Lock lock &#x3D; new ReentrantLock()&#x2F;&#x2F;默认非公平锁</p><p>恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU的时间片，尽量减少CPU空闲状态时间。<br>使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</p><p>非公平锁线程切换开销大。</p><h4 id="可重入锁又名递归锁"><a href="#可重入锁又名递归锁" class="headerlink" title="可重入锁又名递归锁"></a>可重入锁又名递归锁</h4><p>ReentrantLock 和 synchronized都是可重入锁</p><p>是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对 象)，不会因为之前已经获取过还没释放而阻塞。</p><p><strong>隐式锁（synchronized）</strong></p><p>默认就是可重入锁</p><p>在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        reEntryM1();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reEntryM1</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            <span class="hljs-keyword">synchronized</span> (object)&#123;                System. out . println(Thread.currentThread(). getName()+<span class="hljs-string">&quot;\t ---外层调用&quot;</span>);                <span class="hljs-keyword">synchronized</span> (object)&#123;                    System. out . println(Thread. currentThread(). getName()+<span class="hljs-string">&quot;\t ----中层调用&quot;</span>);                    <span class="hljs-keyword">synchronized</span> (object)&#123;                        System. out . println( Thread.currentThread(). getName()+<span class="hljs-string">&quot;\t ----内层调用&quot;</span>);                    &#125;                &#125;            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>). start();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            <span class="hljs-keyword">new</span> <span class="hljs-title class_">JucTest</span>().m1();        &#125;).start();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入</span>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t ----come in&quot;</span>);        m2();        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t ----end m1&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span>&#123;        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t ----come in&quot;</span>);        m3();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> &#123;        System.out.println(Thread.currentThread(). getName()+<span class="hljs-string">&quot;\t ----come in&quot;</span>);    &#125;&#125;</code></pre><p><strong>显示锁（ReentrantLock）</strong></p><p>显示指定lock() unlock()</p><p>加锁几次就要解锁几次</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            lock.lock();            <span class="hljs-keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t ----come in外层调用&quot;</span>);                lock.lock();                <span class="hljs-keyword">try</span> &#123;                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t ----come in内层调用&quot;</span>);                &#125;<span class="hljs-keyword">finally</span> &#123;                    lock.unlock();                &#125;            &#125;<span class="hljs-keyword">finally</span> &#123;                lock.unlock();            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();    &#125;&#125;</code></pre><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><pre><code class="hljs java"><span class="hljs-comment">//死锁代码</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            <span class="hljs-keyword">synchronized</span> (objectA) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t自己持有A锁，希望获得B锁&quot;</span>);                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">synchronized</span> (objectB) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t成功获得B锁&quot;</span>);                &#125;            &#125;        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            <span class="hljs-keyword">synchronized</span> (objectB) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t自己持有B锁，希望获得A锁&quot;</span>);                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">synchronized</span> (objectA) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t成功获得A锁&quot;</span>);                &#125;            &#125;        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();    &#125;&#125;</code></pre><p><strong>排查死锁</strong></p><p>1.纯命令</p><p>​jps -l</p><p>​jstack 进程编号</p><p>2.jconsole图形化界面</p><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p><strong>协商中断</strong></p><p>首先一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止，自己来决定自己的命运。<br>所以，Thread.stop，Thread.suspend，Thread.resume都已经被废弃了。<br>其次在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。<br>因此，Java提供了一种用于停止线程的协商机制—–中断，也即中断标识协商机制。<br>中断只是一种协作协商机制，Java没 有给中断增加任何语法，中断的过程完全需要程序员自己实现。<br>若要中断一个线程，你需要手动调用该线程的interrupt方法，该方法也仅仅是将线程对象的中断标识设成true</p><p>接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程请求这条线程中断，此时究竟该做什么需要你自己写代码实现。<br>每个线程对象中都有一个中断标识位，用于表示线程是否被中断;该标识位为true表示中断，为false表示未中断;<br>通过调用线程对象的interrupt方法将该线程的标识位设为true;可以在别的线程中调用，也可以在自己的线程中调用。</p><p>如何实现线程中断停止</p><pre><code class="hljs java"><span class="hljs-comment">//1.使用volatile共享变量</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isStop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                <span class="hljs-keyword">if</span> (isStop) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;thread stop&quot;</span>);                    <span class="hljs-keyword">break</span>;                &#125;                System.out.println(<span class="hljs-string">&quot;t1 -------hello volatile&quot;</span>);            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">20</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            isStop = <span class="hljs-literal">true</span>;        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;<span class="hljs-comment">//使用原子类</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">atomicBoolean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                <span class="hljs-keyword">if</span> (atomicBoolean.get()) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;thread stop&quot;</span>);                    <span class="hljs-keyword">break</span>;                &#125;                System.out.println(<span class="hljs-string">&quot;t1 -------hello volatile&quot;</span>);            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">20</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            atomicBoolean.set(<span class="hljs-literal">true</span>);        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p>通过线程自带的<strong>中断API</strong>实列方法实现</p><ul><li><p>Thread.interrupted()</p><p>返回当前线程的中断状态，测试当前线程是否已被中断<br>将当前线程的中断状态清零并重新设为false，清除线程的中断状态</p></li><li><p>Thread.interrupt()</p><p>没有返回值</p><p>仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程</p><p>①如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以，interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。<br>②如果线程处于被阻塞状态( 例如处于sleep， wait， join等状态)，在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态，中断状态将被清除，并抛出一个InterruptedException异常。（可能程序会无限循环，解决方法须在异常catch处再调用interrupt方法）</p></li><li><p>Thread.isInterrupted()</p><p>判断当前线程是否被中断(通过检查中断标志位)，不清除线程的中断状态。</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">//通过线程自带的中断API实列方法实现</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;thread stop&quot;</span>);                    <span class="hljs-keyword">break</span>;                &#125;                System.out.println(<span class="hljs-string">&quot;t1 -------hello volatile&quot;</span>);            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);        t1.start();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">10</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            t1.interrupt();        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>线程的等待和唤醒</p><ul><li>使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程，使用必须持有锁</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            <span class="hljs-keyword">synchronized</span> (obj) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------come in&quot;</span>);                <span class="hljs-keyword">try</span> &#123;                    obj.wait();<span class="hljs-comment">//释放了锁？？？</span>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------waked&quot;</span>);            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            <span class="hljs-keyword">synchronized</span> (obj) &#123;                obj.notify();                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------notify&quot;</span>);            &#125;        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;<span class="hljs-comment">//wait 须在 notify前面</span></code></pre><ul><li>使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程，使用必须持有锁</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();        <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            lock.lock();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------come in&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                condition.await();                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------waked&quot;</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;                lock.unlock();            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            lock.lock();            condition.signal();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------notify&quot;</span>);            lock.unlock();        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;<span class="hljs-comment">//先await() 后signal</span></code></pre><ul><li>LockSupport类可以park阻塞当前线程以及unpark唤醒指定被阻塞的线程，</li></ul><pre><code class="hljs java"><span class="hljs-comment">//park unpark 无顺序要求。因为park发了许可证，线程没使用，会保留，许可证不会积累，最多只有一个</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------come in&quot;</span>);            LockSupport.park();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------waked&quot;</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);        t1.start();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            LockSupport.unpark(t1);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------notify&quot;</span>);        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><h3 id="JAVA内存模型（JMM）"><a href="#JAVA内存模型（JMM）" class="headerlink" title="JAVA内存模型（JMM）"></a>JAVA内存模型（JMM）</h3><p>CPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存，而内存的读和写操作的时候就会造成不一致的问题。</p><p>JVM规范中试图定义一种Java内存模型(java Memory Model，简称JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><p>JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。</p><p><strong>作用：</strong></p><p>通过JMM来实现线程和主内存之间的抽象关系。<br>屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><p><strong>可见性</strong></p><p>是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更，JMM规定了所有的变量都存储在主内存中。</p><p><strong>原子性</strong></p><p>指一个操作是不可打断的，即多线程环境下，操作不能被其他线程干扰。</p><p><strong>有序性</strong></p><p>指令重排</p><p>JVM能根据处理器特性(CPU多级缓存系统、多核处理器等)适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。但是，指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致(即可能产生”脏读”)， 简单说，两行以上不相干的代码在执行的时候有可能先执行的不是第一条， 不见得是从上到下顺序执行，执行顺序会被优化。</p><img src="D:/hexo_Blog/source/_posts/images/images_20221017191551.png"><h4 id="多线程对变量的读写过程"><a href="#多线程对变量的读写过程" class="headerlink" title="多线程对变量的读写过程"></a>多线程对变量的读写过程</h4><p>(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到 线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:</p><img src="D:/hexo_Blog/source/_posts/images/images_20221017192450.png"><h4 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h4><p> <strong>包含可见性和有序性的约束</strong></p><blockquote><p>如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常罗嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。<br>我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下有一个“先行发生”（Happens-Before）的原则限制和规矩，给你立好了规矩！</p><p>这个原则非常重要：<br>它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中。</p></blockquote><p>**happens-before **总原则</p><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者代码重排序，那么这两个操作之间必须存在happens-before(先行发生)原则。</p><p>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。<br>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</p><p><strong>八条</strong></p><ul><li><p>次序规则</p><p><strong>一个线程内</strong>，按照代码顺序，写在前面的操作先行发生于写在后面的操作;</p><blockquote><p>前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量X赋值为1，那后面一个操作肯定能知道X已经变成了1。</p></blockquote></li><li><p>锁定规则</p><p>一个unLock操作先行发生于后面 (这里的“后面”是指时间上的先后) 对同一个锁的Iock操作。</p><blockquote><p>直白来讲 就是同一个锁只能有一个类获取 ， A获取锁，B想要获取，只能等待A unLock该锁</p><p>可重入锁是同一线程的递归锁 不同线程 只能等待锁释放</p></blockquote></li><li><p>变量规则</p><p>对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的”后面”同样是指时间上的先后。</p></li><li><p>传递规则</p><p>如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C;</p></li><li><p>线程启动规则（Thread Start Rule）</p><p>Thread对象的start()方法先行发生于此线程的每一个动作</p></li><li><p>线程中断规则(Thread Interruption Rule)</p><p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p><blockquote><p>可以通过Thread.interrupted()检测到是否发生中断<br>也就是说你要先调用interrupt()方法设置过中断标志位，我才能检测到中断发送。</p></blockquote></li><li><p>线程终止规则(Thread Termination Rule)</p><p>线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过isAlive()等手段检测线程是否已经终止执行。</p></li><li><p>对象终结规则(Finalizer Rule)</p><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始</p><blockquote><p>对象生成之前，是不能调用finalize()的</p></blockquote></li></ul><p>JMM（Java Memory Model）和volatile是Java语言中两个不同的概念，但它们之间有一定的关系。</p><p><strong>JMM是一种内存模型，用于定义多线程环境下数据读写的规则</strong>。它规定了线程之间共享变量的可见性和顺序性，以确保在并发访问时不会出现数据不一致的问题。</p><p><strong>Volatile变量和JMM之间的关系在于，volatile变量的可见性保证是基于JMM的</strong>。在JMM中，线程之间的共享变量存在于主内存中，每个线程都有一块私有的本地内存。当一个线程修改了共享变量的值后，JMM会要求将该变量立即刷新回主内存中，以便其他线程可以立即看到最新的值。而对于volatile变量，Java语言规定当一个线程修改了它的值后，JMM会立即将该变量的值刷新回主内存中，并且会强制其他线程重新从主内存中读取该变量的值，以保证可见性。</p><p>因此，可以说volatile变量的可见性保证是基于JMM的，它们之间的关系在于共同维护多线程环境下的数据一致性和可见性。</p><h3 id="volatile（可见和禁重排）"><a href="#volatile（可见和禁重排）" class="headerlink" title="volatile（可见和禁重排）"></a>volatile（可见和禁重排）</h3><p><img src="D:/hexo_Blog/source/_posts/images/Snipaste_2023-11-21_15-56-18.png" alt="有序性"></p><p>满足：可见性，有序性（禁重排） </p><p>可见性：保证不同线程对某个变量完成操作后结果及时可见，即该共享变量一旦改变所有线程立即可见。</p><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中，并及时发出通知，大家可以去主内存拿最新版，前面的修改对后面所有线程可见。<br>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。</p><p>怎么保证可见性，有序性：<strong>内存屏障</strong></p><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>内存屏障(也称内存栅栏，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作)，避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性(禁重排)，但volatile无法保证原子性。</p><p><strong>内存屏障之前</strong>的所有写操作都要回写到主内存，</p><p><strong>内存屏障之后</strong>的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</p><p> <strong>写屏障</strong>( Store Memory Barrier) ：告诉处理器在写屏障之前将所有存储在缓存(store bufferes)中的数据同步到主内存。也就是说当看到Store屏障指令，就必须把该指令之前所有写入指令执行完毕才能继续往下执行。在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中。</p><p><strong>读屏障</strong>(Load Memory Barrier)：处理器在读屏障之后的读操作，都在读屏障之后执行。也就是说在Load屏障指令之后就能够保证后面的读取数据指令一定能够读取到最新的数据。即在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据。</p><h4 id="四大屏障"><a href="#四大屏障" class="headerlink" title="四大屏障"></a>四大屏障</h4><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1; LoadLoad; Load2</td><td>保证load1的读取操作在load2及后续读取操作之前执行</td></tr><tr><td>StoreStore</td><td>Store1; StoreStore; Store2</td><td>在store2及其后的写操作执行前， 保证store1的写操作已刷新到主内存</td></tr><tr><td>LoadStore</td><td>Load1; LoadStore; Store2</td><td>在stroe2及其后的写操作执行前， 保证load1的读操作已读取结束</td></tr><tr><td>StoreLoad</td><td>Store1; StoreLoad; Load2</td><td>保证store1的写操作已刷新到主内存之 后，load2及 其后的读操作才能执行</td></tr></tbody></table><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-comment">//static boolean flag = true;</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------come in&quot;</span>);            <span class="hljs-keyword">while</span> (flag);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------out&quot;</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);        t1.start();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        flag = <span class="hljs-literal">false</span>;        System.out.println(<span class="hljs-string">&quot;修改完成&quot;</span>);    &#125;&#125;</code></pre><p>1.主线程修改了flag之后没有将其刷新到主内存，所以t1线程看不到。<br>2.主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值， 没有去主内存中更新获取flag最新的值。</p><p>上述原因需要volatile解决</p><p><strong>volatile没有原子性：</strong> <em>可以被多线程打扰</em></p><p>对于volatile变量具备可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的，也仅是数据加载时是最新的。但是多线程环境下，”数据计算”和”数据赋值”操作可能多次出现，若数据在加载之后，若主内存volatile修饰变量发生修改之后，线程工作内存中的操作将会作废去读主内存最新值，操作出现写丢失问题。即各线程私有内存和主内存公共内存中变量不同步，进而导致数据不一致。由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改主内存共享变量的场景必须使用加锁同步。</p><p>如：i++</p><p><strong>volatile可以禁重排</strong></p><p>数据依赖性：若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。</p><p>不存在数据依赖关系，可以重排序。</p><h4 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h4><ul><li><p>单一赋值</p></li><li><p>布尔状态标志，判断业务是否结束</p></li><li><p>开销较低的读，写策略</p></li><li><p>DCL双端锁的发布</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">//单列模式</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeDoubleCheckSingleton</span> &#123;    <span class="hljs-comment">//private static SafeDoubleCheckSingleton singleton;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> SafeDoubleCheckSingleton singleton;<span class="hljs-comment">//解决下面隐患</span>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SafeDoubleCheckSingleton</span><span class="hljs-params">()</span>&#123;&#125;    <span class="hljs-comment">//双重锁设计</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SafeDoubleCheckSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (SafeDoubleCheckSingleton.class) &#123;                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;                    <span class="hljs-comment">//隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取</span>                    <span class="hljs-comment">//1.分配内存</span>                    <span class="hljs-comment">//2.初始化对象</span>                    <span class="hljs-comment">//3.指向内存</span>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeDoubleCheckSingleton</span>();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><blockquote><p> 在多线程环境下可以,使用原子类保证线程安全，无需加锁保证</p></blockquote><p>compare and swap的缩写，中文翻译成比较并交换，实现并发算法时常用到的一种技术。<br>它包含三个操作数一一内存位置、预期原值及更新值。<br>执行CAS操作的时候，将内存位置的值与预期原值比较:（类似乐观锁）<br>    <strong>如果相匹配，那么处理器会自动将该位置值更新为新值.</strong><br>    <strong>如果不匹配，处理器不做任何操作或者重来当它重来重试的这种行为成为–自旋！！</strong></p><blockquote><p><img src="/%5Cimages%5CSnipaste_2023-11-23_13-11-46.png"></p></blockquote><p>​    <strong>多个线程同时执行CAS操作只有一个会成功</strong></p><p><img src="D:/hexo_Blog/source/_posts/images/Snipaste_2023-11-21_19-23-40.png"></p><p>CAS是JDK提供的<strong>非阻塞原子性操作</strong>，它通过硬件保证了比较更新的原子性。<br>它是非阻塞的且自身具有原子性，也就是说这玩意效率更高且通过硬件保证，说明这玩意更可靠。<br><strong>CAS是一条CPU的原子指令</strong>(cmpxchg指令)，不会造成所谓的数据不一致问题，Unsafe提供的<br>CAS方法(如compareAndSwapXXX)底层实现即为CPU指令cmpxchg。<br>执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是CPU实现独占的，比起用synchronized重量级锁，这里的排他时间要短很多，所以在多线程情况下性能会比较好。</p><blockquote><p>1 Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。<br>注意Jnsafe类中的历所有方法都是native修饰的， 也就是说Jnsafe类中的方法都直接湖用操作系统底层资源热相应任务</p><p>AtomicInteger类主要利用CAS（compare and swap）+volatile和native方法来保证原子操作，从而避免synchronized的高开销，执行效率大为提升。</p></blockquote><h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    String username;    <span class="hljs-type">int</span> age;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();        <span class="hljs-type">User</span> <span class="hljs-variable">tom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">22</span>);        <span class="hljs-type">User</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-number">22</span>);        atomicReference.set(tom);        System.out.println(atomicReference.compareAndSet(tom, cat) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get().toString());        System.out.println(atomicReference.compareAndSet(tom, cat) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get().toString());    &#125;&#125;</code></pre><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>CAS是实现自旋锁的基础，CAS 利用CPU指令保证了操作的原子性，以达到锁的效果，至于自旋呢，看字面意思也很明白，自己旋转。是指尝试获取锁的线程不会立即阻寒，而是采用循环的方式去尝试获取锁，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。<strong>这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</strong></p><pre><code class="hljs java"><span class="hljs-comment">//实现自旋锁</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;come in&quot;</span>);        <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-literal">null</span>, thread)) &#123;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unLock</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();        atomicReference.compareAndSet(thread, <span class="hljs-literal">null</span>);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;task over, unLock&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">JucTest</span> <span class="hljs-variable">jucTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JucTest</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            jucTest.lock();            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            jucTest.unLock();        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();        <span class="hljs-comment">//保证A先于B</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">500</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            jucTest.lock();            jucTest.unLock();        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();    &#125;&#125;</code></pre><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>空轮询，CPU消耗大   这是自旋自带的缺点</li><li>ABA问题</li></ul><h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><pre><code class="hljs java"><span class="hljs-comment">//该类可以添加版本号 避免ABA问题</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String bookName;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Book</span> <span class="hljs-variable">javaBook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;javaBook&quot;</span>);        AtomicStampedReference&lt;Book&gt; stampedReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(javaBook, <span class="hljs-number">1</span>);        System.out.println(stampedReference.getReference() + <span class="hljs-string">&quot;\t&quot;</span> + stampedReference.getStamp());        <span class="hljs-type">Book</span> <span class="hljs-variable">mysqlBook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;mysqlBook&quot;</span>);        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stampedReference.compareAndSet(                javaBook,                mysqlBook,                stampedReference.getStamp(),                stampedReference.getStamp() + <span class="hljs-number">1</span>);        System.out.println(b + <span class="hljs-string">&quot;\t&quot;</span> + stampedReference.getReference() + <span class="hljs-string">&quot;\t&quot;</span> + stampedReference.getStamp());        b = stampedReference.compareAndSet(                mysqlBook,                javaBook,                stampedReference.getStamp(),                stampedReference.getStamp() + <span class="hljs-number">1</span>);        System.out.println(b + <span class="hljs-string">&quot;\t&quot;</span> + stampedReference.getReference() + <span class="hljs-string">&quot;\t&quot;</span> + stampedReference.getStamp());    &#125;&#125;</code></pre><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>CountDownLatch用法</p><p>​countDown()</p><p>​await()</p><h4 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h4><h4 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h4><p>AtomicStampedReference，version号，+1；</p><p>AtomicMarkableReference，一次，解决一次性问题（动没动过）</p><h4 id="对象的属性修改原子类"><a href="#对象的属性修改原子类" class="headerlink" title="对象的属性修改原子类"></a>对象的属性修改原子类</h4><p>使用目的：以一种线程安全的方式操作非线程安全对象内的某些字段</p><p>使用要求：更新的对象属性必须使用public volatile修饰符。因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</p><p>AtomicIntegerFieldUpdater</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">bankName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;CCB&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//    public void add() &#123;</span><span class="hljs-comment">//        money++;</span><span class="hljs-comment">//    &#125;</span>    AtomicIntegerFieldUpdater&lt;BankAccount&gt; fieldUpdater =            AtomicIntegerFieldUpdater.newUpdater(BankAccount.class, <span class="hljs-string">&quot;money&quot;</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transMoney</span><span class="hljs-params">()</span> &#123;        fieldUpdater.getAndIncrement(<span class="hljs-built_in">this</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">BankAccount</span> <span class="hljs-variable">bankAccount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>();        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;                        bankAccount.transMoney();                    &#125;                &#125;<span class="hljs-keyword">finally</span> &#123;                    countDownLatch.countDown();                &#125;            &#125;).start();        &#125;        <span class="hljs-keyword">try</span> &#123;            countDownLatch.await();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(bankAccount.money);    &#125;&#125;</code></pre><p>AtomicReferenceFieldUpdater</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCar</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">isInit</span> <span class="hljs-operator">=</span> Boolean.FALSE;    AtomicReferenceFieldUpdater&lt;MyCar, Boolean&gt; referenceFieldUpdater =            AtomicReferenceFieldUpdater.newUpdater(MyCar.class, Boolean.class, <span class="hljs-string">&quot;isInit&quot;</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (referenceFieldUpdater.compareAndSet(<span class="hljs-built_in">this</span>, Boolean.FALSE, Boolean.TRUE)) &#123;            System.out.println(<span class="hljs-string">&quot;success init&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;had been inited by other thread&quot;</span>);        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">MyCar</span> <span class="hljs-variable">myCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCar</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;                myCar.init();            &#125;).start();        &#125;    &#125;&#125;</code></pre><h4 id="原子操作增强类"><a href="#原子操作增强类" class="headerlink" title="原子操作增强类"></a>原子操作增强类</h4><p>LongAdder() 只能计算加法，且从0开始，比AtomicLong（底层为CAS，空轮询造成性能降低，但能保证精度）性能好。</p><p>LongAccumulator() 功能更强大</p><p>LongAdder底层原理：</p><p>Stripend64类</p><p>transient volatile cell[] cells;</p><p>transient volatile long base;</p><p><img src="/%5Cimages%5CSnipaste_2023-11-23_19-10-42.png"></p><h4 id="为什么快："><a href="#为什么快：" class="headerlink" title="为什么快："></a><strong>为什么快：</strong></h4><p>LongAdder的基本思路就是分散热点，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。<br>sum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong个value的更新压力分散到多个value中去，从而降级更新热点。（sum不能保证精度，只能保证最终一致性）</p><img src="\images\Snipaste_2023-11-23_19-26-53.png" style="zoom:50%;" /><h4 id="LongAdder源码分析："><a href="#LongAdder源码分析：" class="headerlink" title="LongAdder源码分析："></a>LongAdder源码分析：</h4><p>LongAdder在无竞争的情况，跟AtomicLong一样，对同一个base进行操作，当出现竞争关系时则是采用化整为零、分散热点的做法，用空间换时间用一个数组cells，将一个value拆分进这个数组cells。多个线程需要同时对value进行操作时候，可以对线程id进行hash得到hash值，再根据nash值映射到这个数组cellsi的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和base都加起来作为最终结果</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;        add(<span class="hljs-number">1L</span>);    &#125;<span class="hljs-comment">/*</span><span class="hljs-comment">as表示cell[]引用</span><span class="hljs-comment">b表示获取的base值</span><span class="hljs-comment">v表示期望值，</span><span class="hljs-comment">m表示cells数组的长度</span><span class="hljs-comment">a表示当前线程命中的cell单元格</span><span class="hljs-comment">*/</span><span class="hljs-comment">/*</span><span class="hljs-comment">1.最初无竞争时只更新base；</span><span class="hljs-comment">2.如果更新base失败后，首次新建一个Cell数组;</span><span class="hljs-comment">3.当多个线程竞争同一个Cell比较激烈时，可能就要扩容cell数组</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;        Cell[] as; <span class="hljs-type">long</span> b, v; <span class="hljs-type">int</span> m; Cell a;    <span class="hljs-comment">/*</span><span class="hljs-comment">     先判断cell[]是否存在，并发量小的初始值为null，所以前面的为false</span><span class="hljs-comment">     之后对long base进行CAS(比较并交换)操作，操作成功直接逃过该方法，并发量过大时，交换失败进入if循环，开始创建cell[]</span><span class="hljs-comment">     */</span>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> || !casBase(b = base, b + x)) &#123;            <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;            <span class="hljs-comment">/*</span><span class="hljs-comment">            as == null、(m = as.length - 1) &lt; 0   判断cell[]是否存在</span><span class="hljs-comment">            as[getProbe() &amp; m] 类似Hash寻找对应槽位</span><span class="hljs-comment">            (a = as[getProbe() &amp; m]) == null  寻找cell数组对应下标是否有值 如果没有值，就会进入到if语句 执行longAccumulate(x, null, uncontended);</span><span class="hljs-comment">          !(uncontended = a.cas(v = a.value, v + x))  对cell数组对应数组下标的值进行CAS操作</span><span class="hljs-comment">            */</span>            <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||                (a = as[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||                !(uncontended = a.cas(v = a.value, v + x)))                longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);        &#125;    &#125;<span class="hljs-comment">/*</span><span class="hljs-comment">long x 需要增加的值，一般默认都是 1 </span><span class="hljs-comment">LongBinaryOperator fn 默认传递的是null</span><span class="hljs-comment">wasUncontended竞争标识，如果是false则代表有竞争。只有cells初始化之后，并且当前线程CAS竞争修改失败，才会是false </span><span class="hljs-comment">*/</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longAccumulate</span><span class="hljs-params">(<span class="hljs-type">long</span> x, LongBinaryOperator fn,</span><span class="hljs-params">                          <span class="hljs-type">boolean</span> wasUncontended)</span> &#123;    <span class="hljs-comment">// 存储线程probe值</span>    <span class="hljs-type">int</span> h;    <span class="hljs-comment">// 如果getProbe（）方法返回0，说明随机数未初始化</span>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//使用ThreadLocalRandom.为当前线程重新计算一个hash值，强制初始化</span>        ThreadLocalRandom.current(); <span class="hljs-comment">// 强制进行初始化</span>        <span class="hljs-comment">// 重新获取probe值，hash值被重置就好比一个全新的线程一样，所以设置了wasUncontended竞争状态true。</span>        h = getProbe();        <span class="hljs-comment">//重新计算了当前线程hash后认为此次不算是一次竞争，都未初始化，肯定还不存在竞争激wasuncontended竞争状态true</span>        wasUncontended = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-type">boolean</span> <span class="hljs-variable">collide</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span>    <span class="hljs-keyword">for</span> (;;) &#123;        Cell[] as; Cell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;        <span class="hljs-comment">/*</span><span class="hljs-comment">        ce11s已经被初始化了</span><span class="hljs-comment">        Cel数组不再为空且可能存在Cell数组扩容</span><span class="hljs-comment">        */</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">        (as = cells) != null、(n = as.length) &gt; 0 cell数组存在 </span><span class="hljs-comment">        */</span>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 进行位于运算，如果为空，说明cells数组中存在还未初始化的坑位，开始初始化</span>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-comment">// 两次的cellsBusy == 0进行双端检索，防止多线程下高并发导致数据不一致</span>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span>                    <span class="hljs-type">Cell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);   <span class="hljs-comment">// 对cell进行初始化</span>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;  <span class="hljs-comment">// casCellsBusy() 判断获取锁是否成功</span>                        <span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span>                            Cell[] rs; <span class="hljs-type">int</span> m, j;                            <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-literal">null</span> &amp;&amp;  <span class="hljs-comment">// 数组存在</span>                                (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;                                   rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// rs[j = (m - 1) &amp; h] == null cells数组某个下标为空</span>                             <span class="hljs-comment">// 开始进行初始化</span>                                rs[j] = r;                                created = <span class="hljs-literal">true</span>;                            &#125;                        &#125; <span class="hljs-keyword">finally</span> &#123;                            <span class="hljs-comment">// 解除锁占用</span>                            cellsBusy = <span class="hljs-number">0</span>;                        &#125;                        <span class="hljs-keyword">if</span> (created)                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// 重新开始循环</span>                    &#125;                &#125;                collide = <span class="hljs-literal">false</span>;            &#125;             <span class="hljs-comment">// 进行位于运算，如果为空 cells数组对应的坑位已经实例化</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span>                wasUncontended = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// Continue after rehash</span>                        <span class="hljs-comment">// 运行CAS将新的数值写进去</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-literal">null</span>) ? v + x :                                         fn.applyAsLong(v, x))))                <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// 如果n大于等于cpu的个数，或者</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)                collide = <span class="hljs-literal">false</span>;            <span class="hljs-comment">// 就停止扩容</span>            <span class="hljs-comment">// </span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)                collide = <span class="hljs-literal">true</span>;            <span class="hljs-comment">// 开始进行cells数组扩容</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">if</span> (cells == as) &#123;      <span class="hljs-comment">// Expand table unless stale</span>                        Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[n &lt;&lt; <span class="hljs-number">1</span>]; <span class="hljs-comment">// 将cell扩大到原先的2倍</span>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-comment">// 将原cells数组中的数据拷贝到当前的数组当中去</span>                            rs[i] = as[i];                        cells = rs;                    &#125;                &#125; <span class="hljs-keyword">finally</span> &#123;                    cellsBusy = <span class="hljs-number">0</span>;                &#125;                collide = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span>            &#125;            h = advanceProbe(h);               &#125;                <span class="hljs-comment">/*</span><span class="hljs-comment">        cellsBusy：初始化cells或者扩容cells需要获取锁，0：表示无锁状态  1：表示其他线程已经持有了锁</span><span class="hljs-comment">casCellsBusy():通过CAS操作修改cellsBusy的值，CAS成功代表获取锁，返回true</span><span class="hljs-comment">        </span><span class="hljs-comment">        */</span>           <span class="hljs-comment">/*</span><span class="hljs-comment">        ce1ls没有加锁且没有初始化，则尝试对它进行加锁，并初始化ce11s数组</span><span class="hljs-comment">        cellsBusy == 0    初始化cells需要获取锁，0：表示无锁状态</span><span class="hljs-comment">        cells == as  </span><span class="hljs-comment">        casCellsBusy()    成功获取锁</span><span class="hljs-comment">        */</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;            <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// 初始化数组</span>                <span class="hljs-keyword">if</span> (cells == as) &#123;                    Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[<span class="hljs-number">2</span>];                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);  <span class="hljs-comment">// 为数组对应下标进行赋值</span>                    cells = rs;                    init = <span class="hljs-literal">true</span>;                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                cellsBusy = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">if</span> (init)                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-comment">/*</span><span class="hljs-comment">        cells正在进行初始化，则尝试直接在基数base上进行累加操作</span><span class="hljs-comment">        多个线程尝试CAS修改失败的线程会走到这个分支</span><span class="hljs-comment">        */</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-literal">null</span>) ? v + x :                                    fn.applyAsLong(v, x))))            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span>    &#125;&#125;</code></pre><p><img src="/%5Cimages%5CSnipaste_2023-11-24_14-29-29.png"><img src="/%5Cimages%5CSnipaste_2023-11-24_14-32-15.png"></p><h4 id="SUM求和"><a href="#SUM求和" class="headerlink" title="SUM求和"></a>SUM求和</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;        Cell[] as = cells; Cell a;        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> base;        <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;                <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)                    sum += a.value;            &#125;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;</code></pre><p><img src="/%5Cimages%5CSnipaste_2023-11-24_14-37-48.png"></p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><blockquote><p>记录线程独有的数据，不需要写回主线程内存</p></blockquote><p>实现每一个线程都有自己<strong>专属的本地变量副本</strong>(自己用自己的变量不麻烦别人，不和其他人共享，人人有份，人各一份)，主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题，比如我们之前讲解的8锁案例，资源类是使用同一部手机，多个线程抢夺同一部手机使用，假如人手一份是不是天下太平?</p><p>必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用try-finally 块进行回收。</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">House</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">saleCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saleHouse</span><span class="hljs-params">()</span> &#123;        ++saleCount;    &#125;<span class="hljs-comment">//    ThreadLocal&lt;Integer&gt; saleVolume = new ThreadLocal&lt;Integer&gt;() &#123;</span><span class="hljs-comment">//        @Override</span><span class="hljs-comment">//        protected Integer initialValue() &#123;</span><span class="hljs-comment">//            return 0;</span><span class="hljs-comment">//        &#125;</span><span class="hljs-comment">//    &#125;;</span>    ThreadLocal&lt;Integer&gt; saleVolume = ThreadLocal.withInitial(() -&gt; <span class="hljs-number">0</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saleVolumeByThreadLocal</span><span class="hljs-params">()</span> &#123;        saleVolume.set(<span class="hljs-number">1</span> + saleVolume.get());    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">House</span> <span class="hljs-variable">house</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">House</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">5</span>) + <span class="hljs-number">1</span>;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j&lt;= size; j++) &#123;                        house.saleHouse();                        house.saleVolumeByThreadLocal();                    &#125;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;号销售卖出:&quot;</span> + house.saleVolume.get());                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">//必须回收</span>                    house.saleVolume.remove();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        <span class="hljs-comment">//暂停亳秒</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.MILLISECONDS. sleep(<span class="hljs-number">300</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(Thread.currentThread( ).getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;共计卖出多少套: &quot;</span> + house.saleCount);    &#125;&#125;</code></pre><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4> <img src="\images\Snipaste_2023-11-24_16-25-54.png" style="zoom:50%;" /><blockquote><p>Thread调用了ThreadLocal.ThreadLocalMap；ThreadLocal包含了静态内部类ThreadLocalMap</p><p>threadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry对象。</p></blockquote><p>JVM内部维护了一个线程版的Map&lt;ThreadLocal，Value&gt;(通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中)，每个线程要用到这个T的时候，用当前的线程去Map里面获取，通过这样让每个线程都拥有了自己独立的变量，人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>OOM都不会被回收</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>当内存不够了，软引用才会被自动回收</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyObject</span><span class="hljs-params">()</span>&#123;&#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-built_in">super</span>.finalize();        System.out.println(<span class="hljs-string">&quot;-----该对象被gc了&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//当内存不够了，软引用才会被自动回收</span>        <span class="hljs-comment">//-Xms10m -Xmx10m 最大内存为10m</span>        SoftReference&lt;MyObject&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());        System.gc();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">&quot;内存够用: &quot;</span> + softReference.get());        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">20</span>];        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(<span class="hljs-string">&quot;------gc after内存不够用: &quot;</span> + softReference.get());        &#125;    &#125;&#125;</code></pre><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用会被gc回收，不管内存空间是否充足</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyObject</span><span class="hljs-params">()</span>&#123;&#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-built_in">super</span>.finalize();        System.out.println(<span class="hljs-string">&quot;-----该对象被gc了&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//弱引用会被回收，不管内存空间是否充足</span>        <span class="hljs-comment">//-Xms10m -Xmx10m 最大内存为10m</span>        WeakReference&lt;MyObject&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());        System.out.println(<span class="hljs-string">&quot;内存够用: &quot;</span> + weakReference.get());        System.gc();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><ul><li>虚引用必须和引用队列(ReferenceQueue)联合使用<br>虚引用需要java.lang.ref.PhantomReference类来实现，顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队(ReferenceQueue)联合使用。</li><li>PhantomReference的get方法总是返回null<br>虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize以后，做某些事情的通知机制。PhantomReference的get方法总是返回null，因此无法访问对应的引用对象。</li><li>处理监控通知使用<br>换句话说，设置虚引用关联对象的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理，用来实现比finalize机制更灵活的回收操作</li></ul><h4 id="为什么ThreadLocal-ThreadMap-Entry使用弱引用"><a href="#为什么ThreadLocal-ThreadMap-Entry使用弱引用" class="headerlink" title="为什么ThreadLocal.ThreadMap.Entry使用弱引用"></a>为什么ThreadLocal.ThreadMap.Entry使用弱引用</h4><blockquote><p>强引用（new的），弱引用（ThreadLocalMap key指向）都指向ThreadLocal对象，强引用销毁了，弱引用就会被gc回收。</p></blockquote><p>当function01方法执行完毕后，栈帧销毁强引用tl也就没有了。但此时线程的ThreadLocalMap里某个entry的key引用还指向这个对象，若这个key引用是强引用，就会导致key指向的ThreadLocal对象及v指向的对象不能被gc回收，造成内存泄漏：若这个key引用是弱引用就大概率会减少内存泄漏的问题（还有一个key为null的雷，第2个坑后面讲）。使用弱引用，就可以使ThreadLocal对象在方法执行完毕后顺利被回收且Entry的key用指向为null。（解决了ThreadLocal对象的回收问题，但是没有解决Map中的value的回收问题）</p><img src="\images\Snipaste_2023-11-24_17-15-55.png" style="zoom:50%;" /><p>当我们为threadLocal变量赋值，实际上就是当前的Entry（threadLocal实例为key，值为value）往这个threadLocalMap中存放。Entry中的key是弱引用，当threadLocal外部强引用被置为null（tl&#x3D;null），那么系统GC的时候，根据可达性分析，这个threadLocal实例就没有任何一条链路能够引用至它，这个ThreadLoca势必会被回收。这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。如果当前线程再迟迟不结束的话，这key为null的Entry的value就会一直存在一条强引用链：Thread Ref-&gt;Thread-&gt;ThreaLocalMap-&gt;Entry</p><blockquote><p>此后我们调用get，set或remove方法时，就会尝试删除key为null的entry，可以释放value对象所占用的内存。</p></blockquote><p>虽然弱引用，保证了key指向的ThreadLocal对象能被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、set时发现key为null时才会去回收整个entry、value，因此弱引用不能100%保证内存不泄露。我们要在不使用某个ThreadLocal对象后，手动调用remoev方法来删除它，尤其是在线程池中，不仅仅是内存泄露的问题，因为线程池中的线程是重复使用的，意味着这个线程的ThreadLocalMap对象也是重复使用的，如果我们不手动调用remove方法，那么后面的线程就有可能获取倒上个线程遗留下来的value值，造成bug。</p><h4 id="清除脏的Entry"><a href="#清除脏的Entry" class="headerlink" title="清除脏的Entry"></a>清除脏的Entry</h4><p>&lt;null, value&gt;</p><p>set()，get()，remove()方法被调用时，key为null的会被清除。</p><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p><a href="https://blog.csdn.net/qq_41929714/article/details/131421540">JVM：Java对象内存布局</a></p><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头(Header) 、实例数据(Instance Data)和对齐填充(Padding)。</p><blockquote><p>对其填充：保证java字节是8的倍数</p></blockquote><img src="\images\Snipaste_2023-11-28_11-09-33.png" style="zoom:50%;" /><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><img src="D:/hexo_Blog/source/_posts/images/images_20221020200008.png"><p><strong>组成：</strong></p><ul><li><p>对象标记Mark Word</p><p>默认存储对象的HashCode、 分代年龄和锁标志位等信息。<br>这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化时变化。</p></li><li><p>类元信息（类型指针）</p><p>对象指向它的类元数据的指针（方法区），虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>默认启用压缩指针。</p></li></ul><h4 id="对象中的实际数据"><a href="#对象中的实际数据" class="headerlink" title="对象中的实际数据"></a>对象中的实际数据</h4><p>存放类的属性(Field)数据信息，包括父类的属性信息</p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐这部分内存按8字节补充对齐。</p><blockquote><p>64位处理器每次处理8字节的数据，并且只能按照一种特殊的方式进行访问，要么是0-7，要么是8-F，这个是硬件造成的，没有办法，也就是按照固定的索引从0开始，每次访问8个偏移量。那么如果没有对齐填充就可能会存在数据跨内存地址区域存储的情况。32位也是一样的，只不过是每次读取4字节的数据。<br><strong>对齐填充存在的意义就是为了提高CPU访问数据的效率，这是一种以空间换时间的做法；虽然访问效率提高了(减少了内存访问次数)，但是在0x07处产生了1bit的空间浪费</strong>。</p></blockquote><h4 id="JOL工具"><a href="#JOL工具" class="headerlink" title="JOL工具"></a>JOL工具</h4><p>分析对象在JVM虚拟机的大小和布局</p><pre><code class="hljs java">&lt;!-- JOL工具 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;&lt;artifactId&gt;jol-core&lt;/artifactId&gt;&lt;version&gt;<span class="hljs-number">0.9</span>&lt;/version&gt;&lt;/dependency&gt;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;    <span class="hljs-type">int</span> id;    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//16 bytes</span>        <span class="hljs-comment">//System.out.println(ClassLayout.parseInstance(o).toPrintable());</span>        <span class="hljs-comment">//1. Customer 只有对象头没有任何Field 16 bytes</span>        <span class="hljs-comment">//2. int+boolean 默认满足对齐填充24</span>        <span class="hljs-type">Customer</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();        System.out.println(ClassLayout.parseInstance(c1).toPrintable());    &#125;&#125;</code></pre><h3 id="Synchronized与锁升级"><a href="#Synchronized与锁升级" class="headerlink" title="Synchronized与锁升级"></a>Synchronized与锁升级</h3><p>锁的升级过程</p><p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p><img src="D:/hexo_Blog/source/_posts/images/images_20221020200008.png"><blockquote><p>重量级锁，假如锁的竞争比较激烈的话，性能减低</p><blockquote><p>java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在用户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。<br>在Java早期版本中，<strong>synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock（系统互斥量）来实现的</strong>，挂起线程和恢复线程都需要转入内核态去完成，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，时间成本相对较高，这也是为什么早期的synchronized效率低的原因Java6之后，为了减少获得锁和释放锁所带来的性能消耗，<strong>引入了轻量级锁和偏向锁</strong>  </p><img src="\images\Snipaste_2023-11-29_13-54-32.png" style="zoom:50%;" /></blockquote></blockquote><h4 id="锁指向"><a href="#锁指向" class="headerlink" title="锁指向"></a>锁指向</h4><p>偏向锁：MarkWord存储的是偏向的线程ID。<br>轻量锁：MarkWord存储的是指向线程栈中LockRecord的指针。<br>重量锁：MarkWord存储的是指向堆中的monitor对象的指针。</p><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor可以理解为一种同步工具，也可理解为一种同步机制， 常常被描述为一个Java对 象。Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。</p><h4 id="Mutex-Lock"><a href="#Mutex-Lock" class="headerlink" title="Mutex Lock"></a>Mutex Lock</h4><p>Monitor是在jvm底层实现的，底层代码是c++。本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，状态转换需要耗费很多的处理器时间成本非常高。所synchronized是Java语言中的一个重量级操作。</p><p>Monitor与java对象以及线程是如何关联?<br>1.如果一个java对象被某个线程锁住，则该java对象的Mark Word字段中LockWord指向monitor的起始地址<br>2.Monitor的Owner字段会存放拥有相关联对象锁的线程id</p><p>synchronized用的锁是存在Java对象头里的Mark Word中锁升级功能主要依赖MarkWord中锁标志位和释放偏向锁标志位</p><p><img src="/%5Cimages%5CSnipaste_2023-11-29_15-02-09.png"></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p><strong>单线程竞争</strong></p><p>当线程A第一次竞争到锁时，通过操作修改Mark Word中的偏向线程ID、偏向模式。如果不存在其他线程竞争，那么持有偏向锁的线程将永远不需要进行同步</p><p>Hotspot的作者经过研究发现，大多数情况下:<br>多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一个线程多次获得的情况，偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。</p><p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也即偏向锁在资源没有竞争情况下消除了同步语句，懒的连CAS操作都不做了，直接提高程序性能。</p><blockquote><p>在实际应用运行过程中发现，“锁总是同一个线程持有，很少发生竞争”，也就是说锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。</p><p>那么只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁（后续这个线程进入和退出这段加了同出锁的代码块时，不需要再次加锁和释放锁。而是直接会去检查锁的MarkWord.里面是不是放的自己的线程ID）。</p><p>如果相等，表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。如果自始至终使用锁的线程只有一个，很显偏向锁几乎没有额外开销，性能极高。</p><p>如果不等，表示发生了竞争，锁已经不是总是偏向于同一个线程了，这个时候会尝试使用CAS来替换MarkWord.里面的线程ID为新线程的ID</p><ul><li><p>竞争成功，表示之前的线程不存在了，MarkWord.里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁；</p></li><li><p>竞争失败，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。</p><ul><li>竞争失败表示，当前线程在操作某一个同步代码块时，上一个线程也在使用，这时候需要进行自旋访问，根据锁升级原理，最好使用轻量级锁</li></ul></li></ul><p>注意，偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。<br>技术实现：<br>一个synchronized方法被一个线程抢到了锁时，那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位，同时还会有占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word中去类断一下是否有偏向锁指向本身的ID，无需再进入Monitor去竞争对象了。</p></blockquote><p><strong>偏向锁的持有</strong></p><p>一个synchronized方法被一个线程抢到 了锁时，那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位，同时还会有占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word中去判断一下是否有偏向锁指向本身的ID，无需再进入Monitor去竞争对象了。</p><p>偏向锁，不主动释放锁，偏向指向的ID，如果是当前指向线程ID，当前线程就会直接进入临界区，无需加锁操作，无需沟通内核。</p><blockquote><p>参数说明：<br>偏向锁在JDK1.6以上默认开启，开启后程序启动几秒后才会被激活，可以使用JVM参数来关闭延迟-XX:BiasedLocking StartupDelay&#x3D;O如果确定锁通常处于竞争状态则可通过JVM参数-x:-UseBiasedLocking关闭偏向锁，那么默认会进入轻量级锁</p></blockquote><p><strong>偏向锁撤销</strong></p><p>竞争激烈，其他线程CAS操作替换线程ID，原持有偏向锁的线程未执行完毕，则升级轻量级锁</p><p>Java15后废弃偏向锁</p><p><img src="/%5Cimages%5C20200602120540100.jpg"></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>多线程竞争，但是任意时刻最多只有一个线程竞争，即不存在锁竞争太过激烈的情况，也就没有线程阻塞。 本质就是 CAS 锁</p><p>轻量级锁是为了在线程近乎交替执行同步块时提高性能。<br>主要目的：在没有多线程竞争的前提下，通过CAS减少重量级锁使用操作系统互斥量产生的性能消耗，说白了先自旋，不行才升级阻塞。<br>升级时机：当关闭偏向锁功能或多线程竞争偏向锁会导致偏向锁升级为轻量级锁</p><p>假如线程A已经拿到锁，这时线程B又来抢该对象的锁，由于该对象的锁已经被线程A拿到，当前该锁已是偏向锁了。而线程B在争抢时发现对象头Mark Word中的线程ID不是线程B自己的线程ID(而是线程A)，并且获取偏向锁失败，那线程B就会进行CAS操作希望能获得锁。</p><p><strong>此时线程B操作中有两种情况:</strong></p><p>如果锁获取成功，直接替换Mark Word中的线程ID为B自己的ID(A→B)，重新偏向于其他线程(即将偏向锁交给其他线程，相当于当前线程”被”释放了锁)，该锁会保持偏向锁状态，A线程Over，B线程上位;</p><p>如果锁获取失败，则偏向锁升级为轻量级锁(设置偏向锁标识为0并设置锁标志位为00)，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。</p><p><strong>轻量级锁的加锁</strong></p><p>JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，官方成为Displaced Mark Word。若一个线程获得锁时发现是轻量级锁，会把锁的Mark Word复制到自己的Displaced Mark Word里面。然后线程尝试用CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p><p><strong>轻量级锁的释放</strong></p><p>在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。</p><blockquote><p>轻量级锁和偏向锁的区别：</p><p>争夺轻量级锁失败时，自旋尝试抢占锁轻量级锁每次退出同步块都需要释放锁，</p><p>而偏向锁是在竞争发生时才释放锁</p></blockquote><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>自旋达到一定次数（自适应调节次数）时，升级锁。</p><p><strong>自适应：</strong>线程如果自旋成功了，那下次自旋的最大次数会增加，因为JVM认为既然上次成功了，那么这一次也很大概率会成功。</p><p>Java中synchronized的重量级锁，是基于进入和退出Monitor对象实现的。在编译时会将同步块的开始位置插入monitor enter指令，在结束位置插入monitor exit指令。<br>当线程执行到monitor enter指令时，会尝试获取对象所对应的Monitor所有权，如果获取到了，即获取到了锁，会在Monitor的owner中存放当前线程的id，这样它将处于锁定状态，除非退出同步块，否则其他线程无法获取到这个Monitor。</p><p>升级为轻量级锁时，JVM会在当前线程的栈帧中创建个锁记录(<strong>Lock Record</strong>)空间，用于存储锁对象的Mark Word拷贝，该拷贝中可以包含identity hash code，所以轻量级锁可以和identity hash code共存，哈希码和GC年龄自然保存在此，释放锁后会将这些信息写回到对象头。</p><p>一个对象计算过hash code时无法进入偏向锁，直接进入轻量级锁</p><h4 id="锁升级发生后，hashcode去哪啦"><a href="#锁升级发生后，hashcode去哪啦" class="headerlink" title="锁升级发生后，hashcode去哪啦"></a>锁升级发生后，hashcode去哪啦</h4><p>锁升级为轻量级或重量级锁后，Mark Word中保存的分别是线程栈帧里的锁记录指针和重量级锁指针，己经没有位置再保存哈希码，GC年龄了，那么这些信息被移动到哪里去了呢？</p><ul><li>锁和hashcode的关系：<ul><li>在java语言中，一个对象如果已经计算过哈希值，就应该一直保持不变，绝大多数对象哈希值来源就时Object.HashCode，它通过在对象头中存储计算结果来保证第一次计算后，再次调用该方法湖区道德hash值不会发生改变。所以，当一个对象已经获取对应的HashCode后，他就再也无法进入到偏向锁的状态了，如果一个对象进入到偏向锁的状态之后，有收到计算其哈希值的要求，会直接退出偏向锁的状态，直接进入到重量锁状态。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类中有字段可以记录非加锁状态下的Mark Word，其中自然可以存储原来的哈希码。</li><li>对于偏向锁，在线程获取偏向锁时，会用Thread ID和epoch值覆盖identity hash code所在的位置。如果一个对象的hashCode（O方法己经被调用过一次之后，这个对象不能被设置偏向锁。因为如果可以的话，那Mark Word中的identity hash code必然会被偏向线程ld给覆盖，这就会造成同一个对象前后两次调用hashCode（）方法得到的结果不一致。</li><li>升级为轻量级锁时，JVM会在当前线程的栈帧中创建一个锁记录（Lock Record空间，用于存储锁对象的Mark Word拷贝，该拷贝中可以包含identity hash code，所以轻量级锁可以和identity hash code共存，哈希码和GC年龄自然保存在此，释放锁后会将这些信息写回到对象头。</li><li>升级为重量级锁后，Mark Word保存的重量级锁指针，代表重量级锁的ObjectMonitor类里有字段记录非加锁状态下的Mark Wo，锁释放后也会将信息写回到对象头。</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>synchronized锁升级过程总结：一句话，就是先自旋，不行再阻塞。</p><p><img src="/%5Cimages%5CSnipaste_2023-11-29_20-11-05.png"></p><h4 id="JIT编译器对锁的优化"><a href="#JIT编译器对锁的优化" class="headerlink" title="JIT编译器对锁的优化"></a>JIT编译器对锁的优化</h4><p>JIT即时编译器会优化无效的锁（<strong>锁消除</strong>）</p><p>JIT会融合一些锁（<strong>锁粗化</strong>）</p><blockquote><p>没有锁：自由自在<br>偏向锁：唯我独尊<br>轻量锁：楚汉争霸<br>重量锁：群雄逐鹿</p></blockquote><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><blockquote><p>就是一套线程阻塞等待以及唤醒时锁分配的机制</p></blockquote><p>AQS 抽象的队列同步器</p><p><a href="https://blog.csdn.net/mulinsen77/article/details/84583716">AQS详解（面试）-CSDN博客</a></p><p><a href="https://juejin.cn/post/7006895386103119908">Java并发之AQS详解 - 掘金 (juejin.cn)</a></p><p><img src="/%5Cimages%5CSnipaste_2023-11-30_13-58-56.png"></p><p><code>AQS是juc内容中的重要基石</code></p><blockquote><p><strong>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</strong></p></blockquote><p>AbstractQueuedSynchronizer简称为AQS，抽象的对列同步器。</p><p>是用来实现锁或者其它同步器组件的公共基础部分的抽象实现，是<strong>重量级基础框架及整个JUC体系的基石</strong>，<strong>主要用于解决锁分配给”谁”的问题。</strong></p><p>整体就是一个抽象的FIFO<strong>队列</strong>（双向循环列表）来完成资源获取线程的排队工作，并通过一个<strong>int类变量</strong>表示持有锁的状态。</p><blockquote><p>AQA靠一个 先进先出的队列，和一个 资源状态值state 来实现</p></blockquote><img src="D:/hexo_Blog/source/_posts/images/images_20221023162015.png"><blockquote><p>CLH队列：Craig、Landin and Hagersten队列，是一个单项列表，AQS中的队列时CLH变体的虚拟双向队列FIFO</p></blockquote><p>AbstractQueuedSynchronizer类内部类Node，属性state为同步状态。</p><blockquote><p>Java并发大神DougLee，提出统一规范并简化了锁的实现，将其抽象出来屏蔽了同步状态管理、同步队列的管理和维护、阻塞线程排队和通知、唤醒机制等，是一切锁和同步组件实现的–公共基础部分   AQS</p><p>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS同步队列的抽象表现。它将要请求共享资源的线程及自身的等待状态封装成队列的结点对象（Node），通过CAS、自旋以及LockSupport.park（）的方式，维护state变量的状态，使并发达到同步的效果。</p><p>AQS使用一个volatile的it类型的成员变量来表示同步状态，通过内置的FIFo队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值的修改。</p></blockquote><blockquote><p>Lock接口的实现类，基本都是通过【聚合】了一个【队列同步器】的子类完成线程访问控制的</p></blockquote><h4 id="AQS-源码分析"><a href="#AQS-源码分析" class="headerlink" title="AQS 源码分析"></a>AQS 源码分析</h4><p>从ReentrantLock开始解读AQS源码</p><p>从最简单的lock方法开始看看公平和非公平</p><p><img src="D:/hexo_Blog/source/_posts/images/Snipaste_2023-12-03_12-07-07.png"></p><p><img src="/%5Cimages%5CSnipaste_2023-12-03_12-18-04.png"></p><p><img src="/%5Cimages%5CSnipaste_2023-12-03_12-20-02.png"></p><p><img src="/%5Cimages%5CSnipaste_2023-12-03_12-20-56.png"></p><p><strong>以非公平锁作为案例突破口</strong></p><p><img src="/%5Cimages%5CSnipaste_2023-12-03_12-47-35.png"></p><p>双向链表中，第一个节点为虚节点（也叫哨兵节点），其实并不存储任何信息，只是占位。<br>真正的第一个有数据的节点，是从第二个节点开始的。</p><p><code>等待队列</code></p><p><img src="/%5Cimages%5CSnipaste_2023-12-03_14-34-35.png"></p><p><img src="/%5Cimages%5CSnipaste_2023-12-03_15-19-41.png"></p><p>上锁 阻塞</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;        sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Performs lock.  Try immediate barge, backing up to normal</span><span class="hljs-comment">         * acquire on failure.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;            <span class="hljs-comment">// 第一个线程进入，抢占</span>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))                <span class="hljs-comment">// set 独占所有者线程  将当前线程独占该资源</span>                setExclusiveOwnerThread(Thread.currentThread());            <span class="hljs-keyword">else</span>                <span class="hljs-comment">// 第二个线程以及后续线程抢占 </span>                acquire(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;            <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);        &#125;                       <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;            <span class="hljs-comment">// 获取当前线程</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();            <span class="hljs-comment">// h获取当前锁的状态 （1：被占用   0：空闲）</span>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;                    setExclusiveOwnerThread(current);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;            &#125;            <span class="hljs-comment">// 如果当前线城是 独占所有者线程 </span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);                setState(nextc);                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;            &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io. Serializable &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;      <span class="hljs-comment">// 进行抢锁， 如果成功直接进入 selfInterrupt();   如果失败，则进入等待区间addWaiter(Node.EXCLUSIVE), arg)</span>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))            selfInterrupt();    &#125;       <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();    &#125;          <span class="hljs-comment">// mode 排他模式</span>     <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);        <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span>        <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;         <span class="hljs-comment">// 判断尾指针是否为null 正常情况下，第一次应该为null</span>        <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;            node.prev = pred;            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;                pred.next = node;                <span class="hljs-keyword">return</span> node;            &#125;        &#125;        <span class="hljs-comment">// 第一次入队的时候掉用</span>        enq(node);        <span class="hljs-keyword">return</span> node;    &#125;         <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;            <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span>                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))                    tail = head;            &#125; <span class="hljs-keyword">else</span> &#123;                node.prev = t;                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;                    t.next = node;                    <span class="hljs-keyword">return</span> t;                &#125;            &#125;        &#125;            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                    setHead(node);                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span>                    failed = <span class="hljs-literal">false</span>;                    <span class="hljs-keyword">return</span> interrupted;                &#125;                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                    interrupted = <span class="hljs-literal">true</span>;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (failed)                cancelAcquire(node);        &#125;    &#125;             <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)                       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;                      <span class="hljs-keyword">do</span> &#123;                node.prev = pred = pred.prev;            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);            pred.next = node;        &#125; <span class="hljs-keyword">else</span> &#123;             compareAndSetWaitStatus(pred, ws, Node.SIGNAL);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;                        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 使得该线程停留在该队列中，等待资源的释放</span>        LockSupport.park(<span class="hljs-built_in">this</span>);        <span class="hljs-keyword">return</span> Thread.interrupted();    &#125;&#125;</code></pre><p>unlock 释放</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;        sync.release(<span class="hljs-number">1</span>);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)                unparkSuccessor(h);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;  <span class="hljs-comment">//  1 - 1</span>        <span class="hljs-comment">// 当前线程不是 占用资源独占锁的线程</span>            <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();            <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;                free = <span class="hljs-literal">true</span>;                <span class="hljs-comment">// 释放锁</span>                setExclusiveOwnerThread(<span class="hljs-literal">null</span>);            &#125;        <span class="hljs-comment">// 修改当前锁的状态为零 ，标识没有线程占用</span>            setState(c);            <span class="hljs-keyword">return</span> free;        &#125;    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)            compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;            s = <span class="hljs-literal">null</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)                <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)                    s = t;        &#125;        <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)            LockSupport.unpark(s.thread);    &#125;&#125;</code></pre><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><img src="D:/hexo_Blog/source/_posts/images/Snipaste_2023-12-05_12-16-03.png"></p><blockquote></blockquote><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>悲观锁</p><p>读写锁定义为：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。</p><ul><li>读读可以共享，多线程并发可以访问，大面积的可以容许多个线程来读取读多写少的时候，读写锁优先。</li><li>读写、写写互斥</li></ul><p>readLock()</p><p>writeLock()</p><p><img src="/%5Cimages%5CSnipaste_2023-12-05_12-17-25.png"></p><p>缺点：</p><ul><li><p>写饥饿:  在线程拥有读锁的时候无法在获取写锁，写锁的线程只能一直等待，造成饥饿</p></li><li><p>锁降级（不算缺点吧）</p><pre><code>写锁降级为读锁</code></pre><ul><li>如果同一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁。这就是写锁的降级，降级成为了读锁。</li><li>规则惯例，先获取写锁，然后获取读锁，再释放写锁的次序。</li><li>如果释放了写锁，那么就完全转换为读锁。</li></ul></li></ul><img src="D:/hexo_Blog/source/_posts/images/images_20221024093400.png"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();        ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> readWriteLock.readLock();        ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> readWriteLock.writeLock();        writeLock.lock();        System.out.println(<span class="hljs-string">&quot;----wirte&quot;</span>);                readLock.lock();        System.out.println(<span class="hljs-string">&quot;----read&quot;</span>);        writeLock.unlock();        readLock.unlock();    &#125;&#125;</code></pre><p><strong>锁降级设计思想</strong></p><pre><code class="hljs java"><span class="hljs-comment">//锁降级设计思想，保证数据可见性。写锁降级为读锁，本质相当于重入，这种机制专门为缓存设计的。</span>Object data;<span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> cacheValid;<span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<span class="hljs-keyword">void</span> <span class="hljs-title function_">processCachedData</span><span class="hljs-params">()</span> &#123;    rwl.readLock().lock();    <span class="hljs-keyword">if</span> (!cacheValid) &#123;        <span class="hljs-comment">// Must release read lock before acquiring write lock</span>        rwl.readLock().unlock();        rwl.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// Recheck state because another thread might have</span>        <span class="hljs-comment">// acquired write lock and changed state before we did.</span>        <span class="hljs-keyword">if</span> (!cacheValid) &#123;        data = ...        cacheValid = <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-comment">// Downgrade by acquiring read lock before releasing write lock</span>        rwl.readLock().lock();        &#125; <span class="hljs-keyword">finally</span> &#123;        rwl.writeLock().unlock(); <span class="hljs-comment">// Unlock write, still hold read</span>        &#125;    &#125;    <span class="hljs-keyword">try</span> &#123;    use(data);    &#125; <span class="hljs-keyword">finally</span> &#123;        rwl.readLock().unlock();    &#125;&#125;</code></pre><p><img src="/%5Cimages%5CSnipaste_2023-12-05_13-52-06.png"><img src="/%5Cimages%5CSnipaste_2023-12-05_13-52-24.png"></p><h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><p>是一种乐观锁</p><p>ReentrantReadWriteLock的读锁被占用的时候，其他线程尝试获取写锁的时候会被阻塞。但是，StampedLock采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞，这其实是对读锁的优化，所以，在获取乐观读锁后，还需要对结果进行校验。</p><p><strong>解决锁饥饿问题</strong></p><ul><li>公平锁，牺牲吞吐量</li><li>乐观读锁（读的过程允许写的介入）</li></ul><p><strong>缺点</strong></p><ul><li>StampedLock不支特重入，没有Re开头</li><li>StampedLock的悲观读锁和写锁都不支持条件变量（Condition），这个也需要注意。</li><li>使用StampedLock一定不要调用中断操作，即不要调用interrupt（）方法</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JucTest</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">nuumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">17</span>;    <span class="hljs-keyword">static</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">stampedLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;wirte thread prepare to wirte&quot;</span>);        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.writeLock();        <span class="hljs-keyword">try</span> &#123;            nuumber = nuumber + <span class="hljs-number">13</span>;        &#125; <span class="hljs-keyword">finally</span> &#123;            stampedLock.unlockWrite(stamp);        &#125;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;wirte thread end to wirte&quot;</span>);    &#125;    <span class="hljs-comment">//悲观读</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;wirte thread prepare to read&quot;</span>);        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.readLock();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);                System.out.println(<span class="hljs-string">&quot;reading...&quot;</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> nuumber;            System.out.println(<span class="hljs-string">&quot;read: &quot;</span> + result);        &#125; <span class="hljs-keyword">finally</span> &#123;            stampedLock.unlockRead(stamp);        &#125;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;wirte thread end to read&quot;</span>);    &#125;    <span class="hljs-comment">//乐观读</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryOptimisticRead</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.tryOptimisticRead();        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> nuumber;        System.out.println(<span class="hljs-string">&quot;判断是否有修改&quot;</span> + <span class="hljs-string">&quot;\t&quot;</span> + stampedLock.validate(stamp));        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);                System.out.println(<span class="hljs-string">&quot;reading stampedLockValidate: &quot;</span> + stampedLock.validate(stamp));            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">if</span> (!stampedLock.validate(stamp)) &#123;            System.out.println(<span class="hljs-string">&quot;value modified by someone&quot;</span>);            stamp = stampedLock.readLock();            <span class="hljs-keyword">try</span> &#123;                System.out.println(<span class="hljs-string">&quot;乐观读升级为悲观读&quot;</span>);                result = nuumber;                System.out.println(<span class="hljs-string">&quot;悲观读后: &quot;</span> + result);            &#125; <span class="hljs-keyword">finally</span> &#123;                stampedLock.unlockRead(stamp);            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;finally value: &quot;</span> + result);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">JucTest</span> <span class="hljs-variable">jucTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JucTest</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            jucTest.tryOptimisticRead();        &#125;, <span class="hljs-string">&quot;readThread&quot;</span>).start();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            jucTest.write();        &#125;, <span class="hljs-string">&quot;writeThread&quot;</span>).start();        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + nuumber);    &#125;&#125;</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.bilibili.com/video/BV1ar4y1x727?share_source=copy_web&vd_source=6164cc1e15b15d47186e6ecfe12edef8">https://www.bilibili.com/video/BV1ar4y1x727?share_source=copy_web&amp;vd_source=6164cc1e15b15d47186e6ecfe12edef8</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zhaojianting/article/details/97664370&quot;&gt;彻底理解Runnable和Thread的区别_thread runnable</summary>
      
    
    
    
    
    <category term="JUC" scheme="http://example.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JVM指令手册</title>
    <link href="http://example.com/2023/05/30/JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <id>http://example.com/2023/05/30/JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/</id>
    <published>2023-05-30T05:17:08.000Z</published>
    <updated>2024-03-12T12:18:07.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM指令手册"><a href="#JVM指令手册" class="headerlink" title="JVM指令手册"></a>JVM指令手册</h1><h2 id="一、栈和局部变量操作"><a href="#一、栈和局部变量操作" class="headerlink" title="一、栈和局部变量操作"></a>一、栈和局部变量操作</h2><h3 id="将常量压入栈的指令"><a href="#将常量压入栈的指令" class="headerlink" title="将常量压入栈的指令"></a>将常量压入栈的指令</h3><p>aconst_null 将null对象引用压入栈<br>iconst_m1 将int类型常量-1压入栈<br>iconst_0 将int类型常量0压入栈<br>iconst_1 将int类型常量1压入栈<br>iconst_2 将int类型常量2压入栈<br>iconst_3 将int类型常量3压入栈<br>iconst_4 将int类型常量4压入栈<br>iconst_5 将int类型常量5压入栈<br>lconst_0 将long类型常量0压入栈<br>lconst_1 将long类型常量1压入栈<br>fconst_0 将float类型常量0压入栈<br>fconst_1 将float类型常量1压入栈<br>dconst_0 将double类型常量0压入栈<br>dconst_1 将double类型常量1压入栈<br>bipush 将一个8位带符号整数压入栈<br>sipush 将16位带符号整数压入栈<br>ldc 把常量池中的项压入栈<br>ldc_w 把常量池中的项压入栈（使用宽索引）<br>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）</p><h3 id="从栈中的局部变量中装载值的指令"><a href="#从栈中的局部变量中装载值的指令" class="headerlink" title="从栈中的局部变量中装载值的指令"></a>从栈中的局部变量中装载值的指令</h3><p>iload 从局部变量中装载int类型值<br>lload 从局部变量中装载long类型值<br>fload 从局部变量中装载float类型值<br>dload 从局部变量中装载double类型值<br>aload 从局部变量中装载引用类型值（refernce）<br>iload_0 从局部变量0中装载int类型值<br>iload_1 从局部变量1中装载int类型值<br>iload_2 从局部变量2中装载int类型值<br>iload_3 从局部变量3中装载int类型值<br>lload_0 从局部变量0中装载long类型值<br>lload_1 从局部变量1中装载long类型值<br>lload_2 从局部变量2中装载long类型值<br>lload_3 从局部变量3中装载long类型值<br>fload_0 从局部变量0中装载float类型值<br>fload_1 从局部变量1中装载float类型值<br>fload_2 从局部变量2中装载float类型值<br>fload_3 从局部变量3中装载float类型值<br>dload_0 从局部变量0中装载double类型值<br>dload_1 从局部变量1中装载double类型值<br>dload_2 从局部变量2中装载double类型值<br>dload_3 从局部变量3中装载double类型值<br>aload_0 从局部变量0中装载引用类型值<br>aload_1 从局部变量1中装载引用类型值<br>aload_2 从局部变量2中装载引用类型值<br>aload_3 从局部变量3中装载引用类型值<br>iaload 从数组中装载int类型值<br>laload 从数组中装载long类型值<br>faload 从数组中装载float类型值<br>daload 从数组中装载double类型值<br>aaload 从数组中装载引用类型值<br>baload 从数组中装载byte类型或boolean类型值<br>caload 从数组中装载char类型值<br>saload 从数组中装载short类型值</p><h3 id="将栈中的值存入局部变量的指令"><a href="#将栈中的值存入局部变量的指令" class="headerlink" title="将栈中的值存入局部变量的指令"></a>将栈中的值存入局部变量的指令</h3><p>istore 将int类型值存入局部变量<br>lstore 将long类型值存入局部变量<br>fstore 将float类型值存入局部变量<br>dstore 将double类型值存入局部变量<br>astore 将将引用类型或returnAddress类型值存入局部变量<br>istore_0 将int类型值存入局部变量0<br>istore_1 将int类型值存入局部变量1<br>istore_2 将int类型值存入局部变量2<br>istore_3 将int类型值存入局部变量3<br>lstore_0 将long类型值存入局部变量0<br>lstore_1 将long类型值存入局部变量1<br>lstore_2 将long类型值存入局部变量2<br>lstore_3 将long类型值存入局部变量3<br>fstore_0 将float类型值存入局部变量0<br>fstore_1 将float类型值存入局部变量1<br>fstore_2 将float类型值存入局部变量2<br>fstore_3 将float类型值存入局部变量3<br>dstore_0 将double类型值存入局部变量0<br>dstore_1 将double类型值存入局部变量1<br>dstore_2 将double类型值存入局部变量2<br>dstore_3 将double类型值存入局部变量3<br>astore_0 将引用类型或returnAddress类型值存入局部变量0<br>astore_1 将引用类型或returnAddress类型值存入局部变量1<br>astore_2 将引用类型或returnAddress类型值存入局部变量2<br>astore_3 将引用类型或returnAddress类型值存入局部变量3<br>iastore 将int类型值存入数组中<br>lastore 将long类型值存入数组中<br>fastore 将float类型值存入数组中<br>dastore 将double类型值存入数组中<br>aastore 将引用类型值存入数组中<br>bastore 将byte类型或者boolean类型值存入数组中<br>castore 将char类型值存入数组中<br>sastore 将short类型值存入数组中<br>wide指令<br>wide 使用附加字节扩展局部变量索引</p><h3 id="通用-无类型）栈操作"><a href="#通用-无类型）栈操作" class="headerlink" title="通用(无类型）栈操作"></a>通用(无类型）栈操作</h3><p>nop 不做任何操作<br>pop 弹出栈顶端一个字长的内容<br>pop2 弹出栈顶端两个字长的内容<br>dup 复制栈顶部一个字长内容<br>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈<br>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2 复制栈顶部两个字长内容<br>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈<br>swap 交换栈顶部两个字长内容</p><h2 id="二、类型转换"><a href="#二、类型转换" class="headerlink" title="二、类型转换"></a>二、类型转换</h2><p>i2l 把int类型的数据转化为long类型<br>i2f 把int类型的数据转化为float类型<br>i2d 把int类型的数据转化为double类型<br>l2i 把long类型的数据转化为int类型<br>l2f 把long类型的数据转化为float类型<br>l2d 把long类型的数据转化为double类型<br>f2i 把float类型的数据转化为int类型<br>f2l 把float类型的数据转化为long类型<br>f2d 把float类型的数据转化为double类型<br>d2i 把double类型的数据转化为int类型<br>d2l 把double类型的数据转化为long类型<br>d2f 把double类型的数据转化为float类型<br>i2b 把int类型的数据转化为byte类型<br>i2c 把int类型的数据转化为char类型<br>i2s 把int类型的数据转化为short类型</p><h2 id="三、整数运算"><a href="#三、整数运算" class="headerlink" title="三、整数运算"></a>三、整数运算</h2><p>iadd 执行int类型的加法<br>ladd 执行long类型的加法<br>isub 执行int类型的减法<br>lsub 执行long类型的减法<br>imul 执行int类型的乘法<br>lmul 执行long类型的乘法<br>idiv 执行int类型的除法<br>ldiv 执行long类型的除法<br>irem 计算int类型除法的余数<br>lrem 计算long类型除法的余数<br>ineg 对一个int类型值进行取反操作<br>lneg 对一个long类型值进行取反操作<br>iinc 把一个常量值加到一个int类型的局部变量上</p><h2 id="四、逻辑运算"><a href="#四、逻辑运算" class="headerlink" title="四、逻辑运算"></a>四、逻辑运算</h2><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p>ishl 执行int类型的向左移位操作<br>lshl 执行long类型的向左移位操作<br>ishr 执行int类型的向右移位操作<br>lshr 执行long类型的向右移位操作<br>iushr 执行int类型的向右逻辑移位操作<br>lushr 执行long类型的向右逻辑移位操作</p><h3 id="按位布尔运算"><a href="#按位布尔运算" class="headerlink" title="按位布尔运算"></a>按位布尔运算</h3><p>iand 对int类型值进行“逻辑与”操作<br>land 对long类型值进行“逻辑与”操作<br>ior 对int类型值进行“逻辑或”操作<br>lor 对long类型值进行“逻辑或”操作<br>ixor 对int类型值进行“逻辑异或”操作<br>lxor 对long类型值进行“逻辑异或”操作</p><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>fadd 执行float类型的加法<br>dadd 执行double类型的加法<br>fsub 执行float类型的减法<br>dsub 执行double类型的减法<br>fmul 执行float类型的乘法<br>dmul 执行double类型的乘法<br>fdiv 执行float类型的除法<br>ddiv 执行double类型的除法<br>frem 计算float类型除法的余数<br>drem 计算double类型除法的余数<br>fneg 将一个float类型的数值取反<br>dneg 将一个double类型的数值取反</p><h2 id="五、对象和数组"><a href="#五、对象和数组" class="headerlink" title="五、对象和数组"></a>五、对象和数组</h2><h3 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h3><p>new 创建一个新对象<br>checkcast 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。如果不是便抛出异常<br>getfield 从对象中获取字段<br>putfield 设置对象中字段的值<br>getstatic 从类中获取静态字段<br>putstatic 设置类中静态字段的值<br>instanceof 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。是则压入 1，否则压入 0</p><h3 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h3><p>newarray 分配数据成员类型为基本上数据类型的新数组<br>anewarray 分配数据成员类型为引用类型的新数组<br>arraylength 获取数组长度<br>multianewarray 分配新的多维数组</p><h2 id="六、控制流"><a href="#六、控制流" class="headerlink" title="六、控制流"></a>六、控制流</h2><h3 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h3><p>ifeq 如果等于0，则跳转<br>ifne 如果不等于0，则跳转<br>iflt 如果小于0，则跳转<br>ifge 如果大于等于0，则跳转<br>ifgt 如果大于0，则跳转<br>ifle 如果小于等于0，则跳转<br>if_icmpcq 如果两个int值相等，则跳转<br>if_icmpne 如果两个int类型值不相等，则跳转<br>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转<br>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转<br>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转<br>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转<br>ifnull 如果等于null，则跳转<br>ifnonnull 如果不等于null，则跳转<br>if_acmpeq 如果两个对象引用相等，则跳转<br>if_acmpnc 如果两个对象引用不相等，则跳转</p><h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><p>lcmp 比较long类型值<br>fcmpl 比较float类型值（当遇到NaN时，返回-1）<br>fcmpg 比较float类型值（当遇到NaN时，返回1）<br>dcmpl 比较double类型值（当遇到NaN时，返回-1）<br>dcmpg 比较double类型值（当遇到NaN时，返回1）</p><h3 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h3><p>goto 无条件跳转<br>goto_w 无条件跳转（宽索引）</p><h3 id="表跳转指令"><a href="#表跳转指令" class="headerlink" title="表跳转指令"></a>表跳转指令</h3><p>tableswitch 通过索引访问跳转表，并跳转<br>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>athrow 抛出异常或错误。将栈顶异常抛出<br>finally子句<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>rct 从子例程返回</p><h2 id="七、方法调用与返回"><a href="#七、方法调用与返回" class="headerlink" title="七、方法调用与返回"></a>七、方法调用与返回</h2><h3 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><p>invokcvirtual 运行时按照对象的类来调用实例方法<br>invokespecial 根据编译时类型来调用实例方法<br>invokestatic 调用类（静态）方法<br>invokcinterface 调用接口方法</p><h3 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h3><p>ireturn 从方法中返回int类型的数据<br>lreturn 从方法中返回long类型的数据<br>freturn 从方法中返回float类型的数据<br>dreturn 从方法中返回double类型的数据<br>areturn 从方法中返回引用类型的数据<br>return 从方法中返回，返回值为void</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>montiorenter 进入并获取对象监视器。即：为栈顶对象加锁<br>monitorexit 释放并退出对象监视器。即：为栈顶对象解锁</p><h2 id="八、JVM指令助记符"><a href="#八、JVM指令助记符" class="headerlink" title="八、JVM指令助记符"></a>八、JVM指令助记符</h2><p>变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_<br>操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_<br>常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_<br>加：iadd,ladd,fadd,dadd<br>减：isub,lsub,fsub,dsub<br>乘：imul,lmul,fmul,dmul<br>除：idiv,ldiv,fdiv,ddiv<br>余数：irem,lrem,frem,drem<br>取负：ineg,lneg,fneg,dneg<br>移位：ishl,lshr,iushr,lshl,lshr,lushr<br>按位或：ior,lor<br>按位与：iand,land<br>按位异或：ixor,lxor<br>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)<br>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)<br>创建类实便：new<br>创建新数组：newarray,anewarray,multianwarray<br>访问类的域和类实例域：getfield,putfield,getstatic,putstatic<br>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload<br>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore<br>获取数组长度：arraylength<br>检相类实例或数组属性：instanceof,checkcast<br>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap<br>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,<br>if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl<br>fcmpg,dcmpl,dcmpg<br>复合条件转移：tableswitch,lookupswitch<br>无条件转移：goto,goto_w,jsr,jsr_w,ret<br>调度对象的实便方法：invokevirtual<br>调用由接口实现的方法：invokeinterface<br>调用需要特殊处理的实例方法：invokespecial<br>调用命名类中的静态方法：invokestatic<br>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return<br>异常：athrow<br>finally关键字的实现使用：jsr,jsr_w,ret</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM指令手册&quot;&gt;&lt;a href=&quot;#JVM指令手册&quot; class=&quot;headerlink&quot; title=&quot;JVM指令手册&quot;&gt;&lt;/a&gt;JVM指令手册&lt;/h1&gt;&lt;h2 id=&quot;一、栈和局部变量操作&quot;&gt;&lt;a href=&quot;#一、栈和局部变量操作&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>12.JVM系列-垃圾回收器</title>
    <link href="http://example.com/2023/05/10/JVM%E7%B3%BB%E5%88%97-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://example.com/2023/05/10/JVM%E7%B3%BB%E5%88%97-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</id>
    <published>2023-05-10T09:23:38.000Z</published>
    <updated>2024-03-12T09:44:24.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC-分类与性能指标"><a href="#GC-分类与性能指标" class="headerlink" title="GC 分类与性能指标"></a>GC 分类与性能指标</h2><h3 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h3><ol><li><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p></li><li><p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p></li><li><p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p></li></ol><p><strong>Java不同版本新特性</strong></p><ol><li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum、泛型</li><li>API层面：Stream API、新的日期时间、Optional、String、集合框架</li><li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池等</li></ol><h3 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h3><p><strong>按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</strong></p><img src="\chapter_012\0001.png"><ol><li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ol><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li><li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器</li></ol></li><li>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</li></ol><p><strong>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</strong></p><ol><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。 注重暂停时间</li><li>独占式垃圾回收器（Stop the World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。   注重吞吐量</li></ol><img src="\chapter_012\0002.png"><p><strong>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</strong></p><ol><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。再分配对象空间使用指针碰撞</li><li>非压缩式的垃圾回收器不进行这步操作，分配对象空间使用空闲列表</li></ol><p><strong>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</strong></p><h3 id="评估-GC-的性能指标"><a href="#评估-GC-的性能指标" class="headerlink" title="评估 GC 的性能指标"></a>评估 GC 的性能指标</h3><p><strong>指标</strong></p><ol><li><p><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</p></li><li><p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</p></li><li><p><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</p></li><li><p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p></li><li><p><strong>内存占用</strong>：Java堆区所占的内存大小。</p></li><li><p>快速：一个对象从诞生到被回收所经历的时间。</p></li><li><p>吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p></li><li><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p></li><li><p>简单来说，主要抓住两点：</p><ul><li>吞吐量</li><li>暂停时间</li></ul></li></ol><p><strong>吞吐量（throughput）</strong></p><ol><li>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间 &#x2F;（运行用户代码时间+垃圾收集时间）<ul><li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li></ul></li><li>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</li><li>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2&#x3D;0.4</li></ol><img src="\chapter_012\0003.png"><p><strong>暂停时间（pause time）</strong></p><ol><li>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。<ul><li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的</li></ul></li><li>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1&#x3D;0.5，但是总的GC时间可能会长</li></ol><img src="\chapter_012\0004.png"><p><strong>吞吐量 vs 暂停时间</strong></p><ol><li><p><strong>高吞吐量较好</strong>因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p></li><li><p>低暂停时间（低延迟）较好，是从最终用户的角度来看，不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有较低的暂停时间是非常重要的，特别是对于一个交互式应用程序（就是和用户交互比较多的场景）。</p></li><li><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><ul><li>因为如果选择以吞吐量优先，那么<strong>必然需要降低内存回收的执行频率</strong>，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul></li><li><p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p></li><li><p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p></li></ol><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><ol><li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</li><li>那么，Java常见的垃圾收集器有哪些？</li></ol><h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p><ol><li>1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li><li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布</li><li>Parallel GC在JDK6之后成为HotSpot默认GC。</li><li>2012年，在JDK1.7u4版本中，G1可用。</li><li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li><li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。</li><li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li><li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</li></ol><h3 id="7款经典的垃圾收集器"><a href="#7款经典的垃圾收集器" class="headerlink" title="7款经典的垃圾收集器"></a>7款经典的垃圾收集器</h3><ol><li>串行回收器：Serial、Serial old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G1</li></ol><img src="\chapter_012\0005.png"><p><strong>官方文档</strong></p><img src="\chapter_012\0006.jpg"><p><strong>7款经典回收器与垃圾分代之间的关系</strong></p><img src="\chapter_012\0007.png"><ol><li><p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p></li><li><p>老年代收集器：Serial old、Parallel old、CMS；</p></li><li><p>整堆收集器：G1；</p></li></ol><h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><img src="\chapter_012\0008.png"><ol><li><p>两个收集器间有连线，表明它们可以搭配使用：</p><ul><li>Serial&#x2F;Serial old</li><li>Serial&#x2F;CMS    （JDK9废弃）</li><li>ParNew&#x2F;Serial Old （JDK9废弃）</li><li>ParNew&#x2F;CMS</li><li>Parallel Scavenge&#x2F;Serial Old  （预计废弃）</li><li>Parallel Scavenge&#x2F;Parallel Old  jdk8默认</li><li>G1</li></ul></li><li><p>其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。</p></li><li><p>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</p></li><li><p>（绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366）</p></li><li><p>（青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）</p></li><li><p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p></li><li><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<strong>我们选择的只是对具体应用最合适的收集器</strong>。</p></li></ol><h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><ol><li>-XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</li><li>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</li></ol><h4 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h4><p><strong>在 JDK 8 下，设置 JVM 参数</strong></p><p>-XX:+PrintCommandLineFlags</p><p>程序打印输出：-XX:+UseParallelGC 表示使用使用 ParallelGC ，ParallelGC 默认和 Parallel Old 绑定使用</p><pre><code class="hljs java">-XX:InitialHeapSize=<span class="hljs-number">266620736</span> -XX:MaxHeapSize=<span class="hljs-number">4265931776</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</code></pre><p><strong>通过命令行指令查看</strong></p><p>命令行命令</p><pre><code class="hljs java">jpsjinfo -flag UseParallelGC 进程idjinfo -flag UseParallelOldGC 进程id</code></pre><p>JDK 8 中默认使用 ParallelGC 和 ParallelOldGC 的组合</p><img src="\chapter_012\0009.png"><h4 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h4><img src="\chapter_012\0010.png"><h2 id="Serial-回收器：串行回收"><a href="#Serial-回收器：串行回收" class="headerlink" title="Serial 回收器：串行回收"></a>Serial 回收器：串行回收</h2><p><strong>Serial 回收器：串行回收</strong></p><ol><li><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p></li><li><p>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。</p></li><li><p>Serial收集器采用复制算法、串行回收和”Stop-the-World”机制的方式执行内存回收。</p></li><li><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial old收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</p></li><li><p>Serial Old是运行在Client模式下默认的老年代的垃圾回收器，Serial Old在Server模式下主要有两个用途：①与新生代的Parallel Scavenge配合使用②作为老年代CMS收集器的后备垃圾收集方案</p></li></ol><p>这个收集器是一个单线程的收集器，“单线程”的意义：它只会使用一个CPU（串行）或一条收集线程去完成垃圾收集工作。更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><img src="\chapter_012\0011.png"><p><strong>Serial 回收器的优势</strong></p><ol><li>优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。</li><li>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</li></ol><p><strong>总结</strong></p><ol><li><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核CPU才可以用。现在都不是单核的了。</p></li><li><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java Web应用程序中是不会采用串行垃圾收集器的。</p></li></ol><blockquote><p>设置使用Serial垃圾回收器</p><ol><li>在HotSpot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。<ul><li>等价于新生代用Serial GC，且老年代用Serial Old GC</li></ul></li></ol></blockquote><h2 id="ParNew-回收器：并行回收"><a href="#ParNew-回收器：并行回收" class="headerlink" title="ParNew 回收器：并行回收"></a>ParNew 回收器：并行回收</h2><ol><li>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。<ul><li>Par是Parallel的缩写，New：只能处理新生代</li></ul></li><li>ParNew 收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”Stop-the-World”机制。</li><li>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</li></ol><img src="\chapter_012\0012.png"><ol><li><strong>对于新生代，回收次数频繁，使用并行方式高效。</strong></li><li><strong>对于老年代，回收次数少，使用串行方式节省资源。</strong>（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ol><p><strong>ParNew 回收器与 Serial 回收器比较</strong></p><p>Q：由于ParNew收集器基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p><p>A：<strong>不能</strong></p><ol><li>ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li><li>除Serial外，目前只有ParNew GC能与CMS收集器配合工作</li></ol><p><strong>设置 ParNew 垃圾回收器</strong></p><ol><li><p>在程序中，开发人员可以通过选项”-XX:+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p></li><li><p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</p></li></ol><h2 id="Parallel-回收器：吞吐量优先"><a href="#Parallel-回收器：吞吐量优先" class="headerlink" title="Parallel 回收器：吞吐量优先"></a>Parallel 回收器：吞吐量优先</h2><p><strong>Parallel Scavenge 回收器：吞吐量优先</strong></p><ol><li><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p></li><li><p>那么Parallel收集器的出现是否多此一举？</p><ul><li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。（动态调整内存分配情况，以达到一个最优的吞吐量或低延迟）</li></ul></li><li><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，<strong>主要适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p></li><li><p>Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。</p></li><li><p>Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-World”机制。</p></li></ol><img src="\chapter_012\0013.png"><ol><li>在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在server模式下的内存回收性能很不错。</li><li><strong>在Java8中，默认是此垃圾收集器。</strong></li></ol><p><strong>Parallel Scavenge 回收器参数设置</strong></p><ol><li><p>-XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p></li><li><p>-XX:+UseParallelOldGC：手动指定老年代都是使用并行回收收集器。</p><ul><li><p>分别适用于新生代和老年代</p></li><li><p>上面两个参数分别适用于新生代和老年代。默认jdk8是开启的。默认开启一个，另一个也会被开启。（互相激活）</p></li></ul></li><li><p>-XX:ParallelGCThreads：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><ol><li><p>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。</p></li><li><p>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]&#x2F;8]</p></li></ol></li><li><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。</p><ol><li>为了尽可能地把停顿时间控制在XX:MaxGCPauseMillis 以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li><li>该参数使用需谨慎。</li></ol></li><li><p>-XX:GCTimeRatio垃圾收集时间占总时间的比例，即等于 1 &#x2F; (N+1) ，用于衡量吞吐量的大小。</p><ol><li><p>取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1。</p></li><li><p>与前一个-XX:MaxGCPauseMillis参数有一定矛盾性，STW暂停时间越长，Radio参数就容易超过设定的比例。</p></li></ol></li><li><p>-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong></p><ol><li><p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p></li><li><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</p></li></ol></li></ol><h2 id="CMS-回收器：低延迟"><a href="#CMS-回收器：低延迟" class="headerlink" title="CMS 回收器：低延迟"></a>CMS 回收器：低延迟</h2><h3 id="CMS-回收器"><a href="#CMS-回收器" class="headerlink" title="CMS 回收器"></a>CMS 回收器</h3><ol><li>在JDK1.5时期，Hotspot推出了一款在<strong>强交互应用中（就是和用户打交道的引用）</strong>几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<strong>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</strong></li><li>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。<ul><li>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li></ul></li><li>CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-World”</li><li>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作（因为实现的框架不一样，没办法兼容使用），所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</li><li>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</li></ol><h3 id="CMS-工作原理（过程）"><a href="#CMS-工作原理（过程）" class="headerlink" title="CMS 工作原理（过程）"></a>CMS 工作原理（过程）</h3><img src="\chapter_012\0014.png"><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)</p><ol><li><p>初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，<strong>这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</p></li><li><p>并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是<strong>不需要停顿用户线程</strong>，<strong>可以与垃圾收集线程一起并发运行</strong>。</p></li><li><p>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，<strong>因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，</strong>这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致“Stop-the-World”的发生，但也远比并发标记阶段的时间短。</p><blockquote><p>CMS垃圾回收器引入了“重新标记”这个过程，它会在CMS垃圾回收的最后一个阶段进行。在重新标记过程中，CMS会暂停所有的应用线程，然后重新扫描一遍old generation中已经被标记的对象，找出在标记期间因为对象引用的变化而发生变化的对象，将其重新标记为不可达对象。这样可以保证回收器能够更加准确地判断出哪些是可达对象，哪些是不可达对象，确保垃圾回收的正确性。</p></blockquote></li><li><p>并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。<strong>由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</strong></p></li></ol><p>初始标记—&gt; 并发标记–&gt; 重新标记–&gt; 并发清除</p><h3 id="CMS分析"><a href="#CMS分析" class="headerlink" title="CMS分析"></a>CMS分析</h3><ol><li>尽管CMS收集器采用的是并发回收（非独占式），<strong>但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</strong>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</li><li><strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</strong>。</li><li>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，<strong>CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集</strong>，<strong>而是当堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次<strong>“Concurrent Mode Failure”</strong> 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li><li>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，<strong>不可避免地将会产生一些内存碎片</strong>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</li></ol><img src="\chapter_012\0015.png"><p><strong>为什么 CMS 不采用标记-压缩算法呢？</strong></p><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”这种场景下使用</p><h3 id="CMS-的优点与弊端"><a href="#CMS-的优点与弊端" class="headerlink" title="CMS 的优点与弊端"></a>CMS 的优点与弊端</h3><p><strong>优点</strong></p><ol><li>并发收集</li><li>低延迟</li></ol><p><strong>弊端</strong></p><ol><li><strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</li><li><strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li><strong>CMS收集器无法处理浮动垃圾</strong>。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，<strong>那么在并发清除阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，</strong>从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ol><h3 id="CMS-参数配置"><a href="#CMS-参数配置" class="headerlink" title="CMS 参数配置"></a>CMS 参数配置</h3><ul><li><p>-XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务。</p><p>开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew（Young区）+CMS（Old区）+Serial Old（Old区备选方案）的组合。</p></li><li><p>-XX:CMSInitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p></li></ul><ol><li><p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</p></li><li><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。</p></li></ol><ul><li><p>-XX:+UseCMSCompactAtFullCollection：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p></li><li><p>-XX:CMSFullGCsBeforeCompaction：设置在执行多少次Full GC后对内存空间进行压缩整理。</p></li><li><p>-XX:ParallelCMSThreads：设置CMS的线程数量。</p></li></ul><ol><li>CMS默认启动的线程数是 (ParallelGCThreads + 3) &#x2F; 4，ParallelGCThreads是年轻代并行收集器的线程数，可以当做是 CPU 最大支持的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</p><ol><li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li><li>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</li></ol><h3 id="JDK-后续版本中-CMS-的变化"><a href="#JDK-后续版本中-CMS-的变化" class="headerlink" title="JDK 后续版本中 CMS 的变化"></a>JDK 后续版本中 CMS 的变化</h3><ol><li>JDK9新特性：CMS被标记为Deprecate了（JEP291）<ul><li>如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li></ul></li><li>JDK14新特性：删除CMS垃圾回收器（JEP363）移除了CMS垃圾收集器，<ul><li>如果在JDK14中使用XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li></ul></li></ol><h2 id="G1-回收器：区域化分代式"><a href="#G1-回收器：区域化分代式" class="headerlink" title="G1 回收器：区域化分代式"></a>G1 回收器：区域化分代式</h2><p>区域化：g1的主要原理进行优化</p><p>分代式：垃圾回收器主要针对堆空间 对空间又分为新生代和老年代</p><h3 id="为什么还需要G1"><a href="#为什么还需要G1" class="headerlink" title="为什么还需要G1"></a>为什么还需要G1</h3><p><strong>既然我们已经有了前面几个强大的 GC ，为什么还要发布 Garbage First（G1）GC？</strong></p><ol><li>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。 现有的垃圾回收器无法满足实际需求</li><li>G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</li><li>与此同时，<strong>为了适应现在不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</li><li>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</li></ol><h3 id="为什么名字叫Garbage-First-G1-呢？"><a href="#为什么名字叫Garbage-First-G1-呢？" class="headerlink" title="为什么名字叫Garbage First(G1)呢？"></a>为什么名字叫Garbage First(G1)呢？</h3><ol><li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li><li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region。</strong></li><li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</li><li>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</li><li>在JDK1.7版本正式启用，移除了Experimental的标识，<strong>是JDK9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为<strong>“全功能的垃圾收集器”</strong>。</li><li>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。<strong>G1在JDK8中还不是默认的垃圾回收器</strong>，需要使用-XX:+UseG1GC来启用。</li></ol><h3 id="G1-回收器的优势"><a href="#G1-回收器的优势" class="headerlink" title="G1 回收器的优势"></a>G1 回收器的优势</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><ol><li><strong>并行与并发兼备</strong><ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW<ul><li>STW     并行式垃圾回收器（Parallel Garbage Collector）是一种使用多线程并行执行垃圾回收的垃圾回收器。在执行垃圾回收时，由于需要对整个堆空间进行扫描、标记和整理等操作，而多个线程可能需要对同一块内存区域进行修改，为了保证数据一致性和垃圾回收的正确性，可能会产生STW暂停，以禁止新的对象的分配和原有对象的修改，确保进行垃圾回收的一系列操作不会被干扰。</li></ul></li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul></li><li><strong>分代收集</strong><ul><li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul></li></ol><p>G1的分代，已经不是下面这样的了</p><img src="\chapter_012\0016.png"><p>G1的分区是这样的一个区域</p><img src="\chapter_012\0017.png"><p><strong>空间整合</strong></p><ol><li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li><li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。<strong>Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ol><h3 id="可预测的停顿时间模型"><a href="#可预测的停顿时间模型" class="headerlink" title="可预测的停顿时间模型"></a>可预测的停顿时间模型</h3><p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong></p><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ol><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong>。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ol><h3 id="G1-回收器的缺点"><a href="#G1-回收器的缺点" class="headerlink" title="G1 回收器的缺点"></a>G1 回收器的缺点</h3><ol><li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</li><li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</li></ol><h3 id="G1-参数设置"><a href="#G1-参数设置" class="headerlink" title="G1 参数设置"></a>G1 参数设置</h3><ul><li><p>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</p></li><li><p>-XX:G1HeapRegionSize：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</p></li><li><p>-XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标，JVM会尽力实现，但不保证达到。默认值是200ms</p></li><li><p>-XX:+ParallelGCThread：设置STW时GC线程数的值。最多设置为8</p></li><li><p>-XX:ConcGCThreads：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1&#x2F;4左右。</p></li><li><p>-XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p></li></ul><h3 id="G1-收集器的常见操作步骤"><a href="#G1-收集器的常见操作步骤" class="headerlink" title="G1 收集器的常见操作步骤"></a>G1 收集器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ol><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ol><p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。</p><h3 id="G1-的适用场景"><a href="#G1-的适用场景" class="headerlink" title="G1 的适用场景"></a>G1 的适用场景</h3><ol><li>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</li><li>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</li><li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li><li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：<ul><li>超过50%的Java堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC停顿时间过长（长于0.5至1秒）</li></ul></li><li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li></ol><h3 id="分区-Region"><a href="#分区-Region" class="headerlink" title="分区 Region"></a>分区 Region</h3><p><strong>分区 Region：化整为零</strong></p><ol><li><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p></li><li><p>XX:G1HeapRegionSize设定。<strong>所有的Region大小相同，且在JVM生命周期内不会被改变。</strong></p></li><li><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p></li><li><p>一个Region有可能属于Eden，Survivor或者Old&#x2F;Tenured内存区域。但是一个Region只可能属于一个角色。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p></li><li><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过0.5个Region，就放到H。</p></li></ol><blockquote><p>纠错：尚硅谷视频里这里写的是超过1.5个region。根据<a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">官方文档</a>:  <strong>The G1 Garbage Collector Step by Step</strong></p><p>As shown regions can be allocated into Eden, survivor, and old generation regions. In addition, there is a fourth type of object known as Humongous regions. These regions are designed to hold objects that are 50% the size of a standard region or larger. They are stored as a set of contiguous regions. Finally the last type of regions would be the unused areas of the heap.</p><p>翻译：</p><p>如图所示，可以将区域分配到Eden，幸存者和旧时代区域。 此外，还有第四种类型的物体被称为巨大区域。 这些区域旨在容纳标准区域大小的50％或更大的对象。 它们存储为一组连续区域。 最后，最后一种区域类型是堆的未使用区域。</p></blockquote><img src="\chapter_012\0018.png"><p><strong>设置 H 的原因</strong></p><p>对于堆中的大对象，默认直接会被分配到老年代，但是如果<strong>它是一个短期存在的大对象</strong>就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如<strong>果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p><strong>Region的细节</strong></p><img src="\chapter_012\0019.png"><ol><li>每个Region都是通过指针碰撞来分配空间</li><li>G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li><li>TLAB还是用来保证并行性</li></ol><h3 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h3><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li><li>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li></ul><img src="\chapter_012\0020.png"><p>顺时针，Young GC –&gt; Young GC+Concurrent Marking –&gt; Mixed GC顺序，进行垃圾回收</p><p>独占式（STW）：是指在执行垃圾回收任务的时候，需要暂时停止应用程序的执行，直到垃圾回收任务完成</p><p><strong>回收流程</strong></p><ol><li>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</li><li>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</li><li>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了</strong>。同时，这个老年代Region是和年轻代一起被回收的。</li><li>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li></ol><h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><blockquote><p>之前讲过</p></blockquote><ol><li><p>一个对象被不同区域引用的问题</p></li><li><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p></li><li><p>在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆）</p></li><li><p>回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率</p></li></ol><p><strong>解决方法：</strong></p><ol><li><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全堆扫描；</p></li><li><p>每个Region都有一个对应的Remembered Set</p></li><li><p>每次Reference类型数据写操作时，都会产生一个Write Barrier(写屏障)暂时中断操作；</p></li><li><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p></li><li><p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</p></li><li><p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p></li></ol><img src="\chapter_012\0021.png"><ol><li>在回收 Region 时，为了不进行全堆的扫描，引入了 Remembered Set</li><li>Remembered Set 记录了当前 Region 中的对象被哪个对象引用了</li><li>这样在进行 Region 复制时，就不要扫描整个堆，只需要去 Remembered Set 里面找到引用了当前 Region 的对象</li><li>Region 复制完毕后，修改 Remembered Set 中对象的引用即可</li></ol><h3 id="G1回收过程一：年轻代-GC"><a href="#G1回收过程一：年轻代-GC" class="headerlink" title="G1回收过程一：年轻代 GC"></a>G1回收过程一：年轻代 GC</h3><ol><li>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</li><li>年轻代回收只回收Eden区和Survivor区</li><li>YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</li></ol><img src="\chapter_012\0022.png"><p>图的大致意思就是：  </p><p>1、回收完E和S区，剩余存活的对象会复制到新的S区</p><p>2、S区达到一定的阈值可以晋升为O区</p><p><strong>细致过程：</strong></p><p><strong>然后开始如下回收过程：</strong></p><ol><li><p>第一阶段，扫描根</p><p>根是指GC Roots，根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p></li><li><p>第二阶段，更新RSet</p><p>处理dirty card queue的card 跟新Rset。此阶段完成后，Rset可以准确的反映老年代对所在的内存分段中对象的引用</p></li></ol><blockquote><p>RSet是通过DirtyCardQueue来实现的，在引用赋值的时候先将引用信息存在队列中，回收的时候再遍历card来更新RSet</p><p>对于应用程序的引用赋值语句obiect.field&#x3D;object ,JWM会在之前和之后执行特殊的操作以在ditycard queue中入队一个保存了对象引用信息的card。在年轻代回收的时候,G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关氛。<br>那为什么不在引用赋值语句处直接更新RSet呢?这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</p></blockquote><ol><li><p>第三阶段，处理RSet</p><p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p></li><li><p>第四阶段，复制对象。</p><ul><li>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象</li><li>如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。</li><li>如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li></ul></li><li><p>第五阶段，处理引用</p><p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p></li></ol><h3 id="G1回收过程二：并发标记过程"><a href="#G1回收过程二：并发标记过程" class="headerlink" title="G1回收过程二：并发标记过程"></a>G1回收过程二：并发标记过程</h3><ol><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。正是由于该阶段时STW的，所以我们只扫描根节点可达的对象，以节省时间。</li><li>根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC。</li><li>并发标记（Concurrent Marking）：<ol><li>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断。</li><li><strong>在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。</strong></li><li>同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li></ol></li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的原始快照算法：Snapshot-At-The-Beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ol><h3 id="G1回收过程三：混合回收过程"><a href="#G1回收过程三：混合回收过程" class="headerlink" title="G1回收过程三：混合回收过程"></a>G1回收过程三：混合回收过程</h3><p>当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><img src="\chapter_012\0023.png"><p><strong>混合回收的细节</strong></p><ol><li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。【意思就是一个Region会被分为8个内存段】</li><li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li><li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收。XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li><li>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li></ol><h3 id="G1-回收可选的过程四：Full-GC"><a href="#G1-回收可选的过程四：Full-GC" class="headerlink" title="G1 回收可选的过程四：Full GC"></a>G1 回收可选的过程四：Full GC</h3><ol><li><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用<strong>单线程</strong>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p></li><li><p>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生FullGC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</p></li></ol><p>导致G1 Full GC的原因可能有两个：</p><ol><li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ol><h3 id="G1补充"><a href="#G1补充" class="headerlink" title="G1补充"></a>G1补充</h3><p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，<strong>而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。</strong>另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><p><strong>G1 回收器的优化建议</strong></p><ol><li>年轻代大小<ul><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让G1自己去调整</li></ul></li><li>暂停时间目标不要太过严苛<ul><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul></li></ol><h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><h3 id="7-种垃圾回收器的比较"><a href="#7-种垃圾回收器的比较" class="headerlink" title="7 种垃圾回收器的比较"></a>7 种垃圾回收器的比较</h3><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><img src="\chapter_012\0034.jpg"><img src="\chapter_012\0024.png"><h3 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a>怎么选择垃圾回收器</h3><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p><ol><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li><li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ol><p>最后需要明确一个观点：</p><ol><li>没有最好的收集器，更没有万能的收集算法</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><p><strong>面试</strong></p><ol><li>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。</li><li>这里较通用、基础性的部分如下：<ul><li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li><li>垃圾收集器工作的基本流程。</li></ul></li><li>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</li></ol><h2 id="GC-日志分析"><a href="#GC-日志分析" class="headerlink" title="GC 日志分析"></a>GC 日志分析</h2><h3 id="常用参数配置"><a href="#常用参数配置" class="headerlink" title="常用参数配置"></a>常用参数配置</h3><blockquote><p><strong>GC 日志参数设置</strong></p></blockquote><p><strong>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</strong></p><p>内存分配与垃圾回收的参数列表</p><ol><li>-XX:+PrintGC ：输出GC日志。类似：-verbose:gc</li><li>-XX:+PrintGCDetails ：输出GC的详细日志</li><li>-XX:+PrintGCTimestamps ：输出GC的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDatestamps ：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</li><li>-XX:+PrintHeapAtGC ：在进行GC的前后打印出堆的信息</li><li>-Xloggc:…&#x2F;logs&#x2F;gc.log ：日志文件的输出路径</li></ol><blockquote><p><strong>verbose:gc</strong></p></blockquote><p>1、JVM 参数</p><p><code>-verbose:gc</code></p><p>2、这个只会显示总的GC堆的变化，如下：</p><img src="\chapter_012\0025.png"><p>3、参数解析</p><img src="\chapter_012\0026.png"><blockquote><p><strong>PrintGCDetails</strong></p></blockquote><p>1、JVM 参数</p><p><code>-XX:+PrintGCDetails</code></p><p>2、输入信息如下</p><img src="\chapter_012\0027.png"><p>3、参数解析</p><img src="\chapter_012\0028.png"><blockquote><p><strong>PrintGCTimestamps 和 PrintGCDatestamps</strong></p></blockquote><p>1、JVM 参数</p><p><code>-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</code></p><p>2、输出信息如下</p><img src="\chapter_012\0029.png"><p>3、说明：日志带上了日期和时间</p><h3 id="GC-日志补充说明"><a href="#GC-日志补充说明" class="headerlink" title="GC 日志补充说明"></a>GC 日志补充说明</h3><ol><li><p>“[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World”</p></li><li><p>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</p></li><li><p>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</p></li><li><p>使用Parallel scavenge收集器在新生代的名字是”[PSYoungGen”</p></li><li><p>老年代的收集和新生代道理一样，名字也是收集器决定的</p></li><li><p>使用G1收集器的话，会显示为”garbage-first heap”</p></li><li><p>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p></li><li><p>[ PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)</p><ul><li>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li><li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li></ul></li><li><p>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核线程切换的原因，时间总和可能会超过real时间</p></li></ol><h4 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h4><img src="\chapter_012\0030.png"><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><img src="\chapter_012\0031.png"><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 在jdk7 和 jdk8中分别执行</span><span class="hljs-comment"> * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCLogTest1</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAllocation</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">byte</span>[] allocation1, allocation2, allocation3, allocation4;        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span> * _1MB];        allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span> * _1MB];        allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span> * _1MB];        allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">4</span> * _1MB];    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] agrs)</span> &#123;        testAllocation();    &#125;&#125;</code></pre><p><strong>JDK7 中的情况</strong></p><p>1、首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p><img src="\chapter_012\0032.png"><p>2、然后我们将4M对象存入到Eden区中</p><img src="\chapter_012\0033.png"><p>老年代图画的有问题，free应该是4M</p><p><strong>JDK8 中的情况</strong></p><pre><code class="hljs java">com.atguigu.java.GCLogTest1[GC (Allocation Failure) [DefNew: 6322K-&gt;668K(9216K), <span class="hljs-number">0.0034812</span> secs] 6322K-&gt;4764K(19456K), <span class="hljs-number">0.0035169</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] Heap def <span class="hljs-keyword">new</span> <span class="hljs-title class_">generation</span>   total 9216K, used 7050K [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ff600000</span>)  eden space 8192K,  <span class="hljs-number">77</span>% used [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff23b668</span>, <span class="hljs-number">0x00000000ff400000</span>)  from space 1024K,  <span class="hljs-number">65</span>% used [<span class="hljs-number">0x00000000ff500000</span>, <span class="hljs-number">0x00000000ff5a71d8</span>, <span class="hljs-number">0x00000000ff600000</span>)  to   space 1024K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff500000</span>) tenured generation   total 10240K, used 4096K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)   the space 10240K,  <span class="hljs-number">40</span>% used [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ffa00020</span>, <span class="hljs-number">0x00000000ffa00200</span>, <span class="hljs-number">0x0000000100000000</span>) Metaspace       used 3469K, capacity 4496K, committed 4864K, reserved 1056768K  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 381K, capacity 388K, committed 512K, reserved 1048576KProcess finished with exit code <span class="hljs-number">0</span></code></pre><img src="\chapter_012\0035.jpg"><p>与 JDK7 不同的是，JDK8 直接判定 4M 的数组为大对象，直接怼到老年区去了</p><h3 id="常用日志分析工具"><a href="#常用日志分析工具" class="headerlink" title="常用日志分析工具"></a>常用日志分析工具</h3><p><strong>保存日志文件</strong></p><p><strong>JVM参数</strong>：<code>-XLoggc:./logs/gc.log</code>，  .&#x2F; 表示当前目录，在 IDEA中程序运行的当前目录是工程的根目录，而不是模块的根目录</p><p>可以用一些工具去分析这些GC日志，常用的日志分析工具有：</p><p>GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p><p><strong>推荐：GCeasy</strong></p><p>在线分析网址：gceasy.io</p><img src="\chapter_012\0036.jpg"><img src="\chapter_012\0037.png"><img src="\chapter_012\0038.png"><h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><h3 id="垃圾回收器的发展过程"><a href="#垃圾回收器的发展过程" class="headerlink" title="垃圾回收器的发展过程"></a>垃圾回收器的发展过程</h3><ol><li>GC仍然处于飞速发展之中，目前的默认选项G1 GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</li><li>即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。</li><li>比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</li><li>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12），其特点：主打低停顿时间</li></ol><h3 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h3><p><strong>Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）</strong></p><ol><li><p>Shenandoah无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</p></li><li><p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</p></li><li><p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p></li></ol><p>这是RedHat在2016年发表的论文数据，测试内容是使用ES对200GB的维基百科数据进行索引。从结果看：</p><ol><li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ol><img src="\chapter_012\0039.png"><p>总结</p><ol><li>Shenandoah GC的弱项：高运行负担下的吞吐量下降。</li><li>Shenandoah GC的强项：低延迟时间。</li></ol><h3 id="令人震惊、革命性的-ZGC"><a href="#令人震惊、革命性的-ZGC" class="headerlink" title="令人震惊、革命性的 ZGC"></a>令人震惊、革命性的 ZGC</h3><ol><li><p>官方文档：<a href="https://docs.oracle.com/en/java/javase/12/gctuning/">https://docs.oracle.com/en/java/javase/12/gctuning/</a></p></li><li><p>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p></li><li><p>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p></li><li><p>ZGC的工作过程可以分为4个阶段：并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射 等。</p></li><li><p>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p></li></ol><p><strong>吞吐量</strong></p><img src="\chapter_012\0040.png"><p>max-JOPS：以低延迟为首要前提下的数据</p><p>critical-JOPS：不考虑低延迟下的数据</p><p><strong>低延迟</strong></p><img src="\chapter_012\0041.png"><p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95%停顿、998停顿、99. 98停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。</p><p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p><ol><li><p>JDK14之前，ZGC仅Linux才支持。</p></li><li><p>尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOS上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</p></li><li><p>现在mac或Windows上也能使用ZGC了，示例如下：</p><p>-XX:+UnlockExperimentalVMOptions-XX：+UseZGC</p></li></ol><h3 id="面向大堆的-AliGC"><a href="#面向大堆的-AliGC" class="headerlink" title="面向大堆的 AliGC"></a>面向大堆的 AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p><img src="\chapter_012\0043.png">X </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收器&quot;&gt;&lt;a href=&quot;#垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收器&quot;&gt;&lt;/a&gt;垃圾回收器&lt;/h1&gt;&lt;h2 id=&quot;GC-分类与性能指标&quot;&gt;&lt;a href=&quot;#GC-分类与性能指标&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>11.JVM系列-垃圾回收相关概念</title>
    <link href="http://example.com/2023/04/25/11-JVM%E7%B3%BB%E5%88%97-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2023/04/25/11-JVM%E7%B3%BB%E5%88%97-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2023-04-25T03:23:24.000Z</published>
    <updated>2024-03-12T09:43:31.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc() 的理解"></a>System.gc() 的理解</h2><ol><li><p>在默认情况下，通过System.gc()者Runtime.getRuntime().gc() 的调用，<strong>会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p></li><li><p>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(不能确保立即生效)</p></li><li><p>JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了。</strong>在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p></li></ol><blockquote><p>JVM中的<code>System.gc()</code>方法表示建议JVM立即执行垃圾回收，但并不能保证立即执行。这是因为JVM内部有一个垃圾收集器线程，它负责定期存活对象的回收操作，当需要释放内存或系统空闲时，该线程才会被调度执行。</p><p>虽然可以使用<code>System.gc()</code>来建议JVM执行垃圾回收，但在实际情况下，这种方式并不总能起到作用。因为它们可能处于死亡状态（dead state），或无法触发full GC。</p><p>综上所述，尽管使用<code>System.gc()</code>可能会建议JVM执行垃圾回收，但不应该过于依赖它来管理内存。最好的方法是设计良好的应用程序代码，并让JVM自己进行垃圾回收处理。</p></blockquote><p><strong>代码示例：手动执行 GC 操作</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemGCTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemGCTest</span>();        System.gc();<span class="hljs-comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span>        <span class="hljs-comment">//与Runtime.getRuntime().gc();的作用一样。</span><span class="hljs-comment">//        System.runFinalization();//强制调用使用引用的对象的finalize()方法</span>    &#125;    <span class="hljs-comment">//如果发生了GC，这个finalize()一定会被调用</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-built_in">super</span>.finalize();        System.out.println(<span class="hljs-string">&quot;SystemGCTest 重写了finalize()&quot;</span>);    &#125;&#125;</code></pre><p>输出结果不确定：有时候会调用 finalize() 方法，有时候并不会调用</p><pre><code class="hljs java">SystemGCTest 重写了finalize()或空</code></pre><h3 id="手动-GC-理解不可达对象的回收行为"><a href="#手动-GC-理解不可达对象的回收行为" class="headerlink" title="手动 GC 理解不可达对象的回收行为"></a>手动 GC 理解不可达对象的回收行为</h3><pre><code class="hljs java"><span class="hljs-comment">//加上参数：  -XX:+PrintGCDetails</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVarGC</span> &#123;    <span class="hljs-comment">// 存在引用有GCRoot 回收不了 垃圾回收器执行之后直接晋升到老年代</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC1</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<span class="hljs-comment">//10MB</span>        System.gc();    &#125;    <span class="hljs-comment">//不存在Gcroot buffer回收掉了</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC2</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];        buffer = <span class="hljs-literal">null</span>;        System.gc();    &#125;    <span class="hljs-comment">//不会回收 局部变量表中还有buffer的槽位 buffer</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC3</span><span class="hljs-params">()</span> &#123;        &#123;            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];        &#125;        System.gc();    &#125;    <span class="hljs-comment">// 回收 槽位被占用了</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC4</span><span class="hljs-params">()</span> &#123;        &#123;            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;        System.gc();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC5</span><span class="hljs-params">()</span> &#123;        localvarGC1();        System.gc();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">LocalVarGC</span> <span class="hljs-variable">local</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVarGC</span>();        <span class="hljs-comment">//通过在main方法调用这几个方法进行测试</span>        local.localvarGC1();    &#125;&#125;栈帧中的局部变量表中的槽位是可以重复的，如果一个局部变量过了其作用域，那么其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位，从而达到节省资源的目的</code></pre><p>JVM参数：</p><p><code>-Xms256m -Xmx256m -XX:+PrintGCDetails -XX:PretenureSizeThreshold=15m</code></p><p>1、第四个参数是设置大对象直接进入老年代的阈值，由于我的电脑8G和视频里老师的电脑16G不太一样。我测试的时候10M的数组都是直接进入到了老年代，为了保持一样的效果，我同时设置了堆内存和大对象阈值，尽量和宋红康老师保持一致</p><p>2、我也查过了大对象阈值的默认值</p><img src="\chapter_011\0001.png"><blockquote><p>看不懂GC日志请看笔者的  <strong>堆</strong>那篇文章</p></blockquote><p><strong>1、调用 localvarGC1() 方法</strong></p><p>执行 System.gc() 仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象仍然没有回收</p><pre><code class="hljs java">[GC (System.gc()) [PSYoungGen: 15492K-&gt;10728K(76288K)] 15492K-&gt;11000K(251392K), <span class="hljs-number">0.0066473</span> secs] [Times: user=<span class="hljs-number">0.08</span> sys=<span class="hljs-number">0.02</span>, real=<span class="hljs-number">0.01</span> secs] [Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 10728K-&gt;0K(76288K)] [ParOldGen: 272K-&gt;10911K(175104K)] 11000K-&gt;10911K(251392K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="hljs-number">0.0097940</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] Heap PSYoungGen      total 76288K, used 655K [<span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)  eden space 65536K, <span class="hljs-number">1</span>% used [<span class="hljs-number">0x00000000fab00000</span>,<span class="hljs-number">0x00000000faba3ee8</span>,<span class="hljs-number">0x00000000feb00000</span>)  from space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000ff580000</span>)  to   space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x0000000100000000</span>) ParOldGen       total 175104K, used 10911K [<span class="hljs-number">0x00000000f0000000</span>, <span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x00000000fab00000</span>)  object space 175104K, <span class="hljs-number">6</span>% used [<span class="hljs-number">0x00000000f0000000</span>,<span class="hljs-number">0x00000000f0aa7d08</span>,<span class="hljs-number">0x00000000fab00000</span>) Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 387K, capacity 390K, committed 512K, reserved 1048576K</code></pre><p><strong>2、调用 localvarGC2() 方法</strong></p><p>由于 buffer 数组对象没有引用指向它，执行 System.gc() 将被回收</p><pre><code class="hljs java">[GC (System.gc()) [PSYoungGen: 15492K-&gt;808K(76288K)] 15492K-&gt;816K(251392K), <span class="hljs-number">0.0294475</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.04</span> secs] [Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 808K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;640K(175104K)] 816K-&gt;640K(251392K), [Metaspace: 3385K-&gt;3385K(1056768K)], <span class="hljs-number">0.0054210</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] Heap PSYoungGen      total 76288K, used 1966K [<span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)  eden space 65536K, <span class="hljs-number">3</span>% used [<span class="hljs-number">0x00000000fab00000</span>,<span class="hljs-number">0x00000000faceb9e0</span>,<span class="hljs-number">0x00000000feb00000</span>)  from space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000ff580000</span>)  to   space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x0000000100000000</span>) ParOldGen       total 175104K, used 640K [<span class="hljs-number">0x00000000f0000000</span>, <span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x00000000fab00000</span>)  object space 175104K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000f0000000</span>,<span class="hljs-number">0x00000000f00a01a8</span>,<span class="hljs-number">0x00000000fab00000</span>) Metaspace       used 3392K, capacity 4496K, committed 4864K, reserved 1056768K  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 379K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p><strong>3、调用 localvarGC3() 方法</strong></p><p>虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收</p><pre><code class="hljs java">[GC (System.gc()) [PSYoungGen: 15492K-&gt;840K(76288K)] 15492K-&gt;11088K(251392K), <span class="hljs-number">0.0070281</span> secs] [Times: user=<span class="hljs-number">0.08</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] [Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 840K-&gt;0K(76288K)] [ParOldGen: 10248K-&gt;10900K(175104K)] 11088K-&gt;10900K(251392K), [Metaspace: 3386K-&gt;3386K(1056768K)], <span class="hljs-number">0.0084464</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] Heap PSYoungGen      total 76288K, used 1966K [<span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)  eden space 65536K, <span class="hljs-number">3</span>% used [<span class="hljs-number">0x00000000fab00000</span>,<span class="hljs-number">0x00000000faceb9e0</span>,<span class="hljs-number">0x00000000feb00000</span>)  from space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000ff580000</span>)  to   space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x0000000100000000</span>) ParOldGen       total 175104K, used 10900K [<span class="hljs-number">0x00000000f0000000</span>, <span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x00000000fab00000</span>)  object space 175104K, <span class="hljs-number">6</span>% used [<span class="hljs-number">0x00000000f0000000</span>,<span class="hljs-number">0x00000000f0aa52e8</span>,<span class="hljs-number">0x00000000fab00000</span>) Metaspace       used 3393K, capacity 4496K, committed 4864K, reserved 1056768K  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 379K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p><strong>原因：</strong></p><p>1、来看看字节码：实例方法局部变量表第一个变量肯定是 this</p><img src="\chapter_011\0002.png"><p>2、你有没有看到，局部变量表的大小是 2。但是局部变量表里只有一个索引为0的啊？那索引为1的是哪个局部变量呢？实际上索引为1的位置是buffer在占用着，执行 System.gc() 时，栈中还有 buffer 变量指向堆中的字节数组，所以没有进行GC</p><img src="\chapter_011\0003.png"><p>3、那么这种代码块的情况，什么时候会被GC呢？我们来看第四个方法</p><p><strong>4、调用 localvarGC4() 方法</strong></p><pre><code class="hljs java">[GC (System.gc()) [PSYoungGen: 15492K-&gt;776K(76288K)] 15492K-&gt;784K(251392K), <span class="hljs-number">0.0009430</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] [Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 776K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;646K(175104K)] 784K-&gt;646K(251392K), [Metaspace: 3485K-&gt;3485K(1056768K)], <span class="hljs-number">0.0065829</span> secs] [Times: user=<span class="hljs-number">0.02</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] Heap PSYoungGen      total 76288K, used 1966K [<span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)  eden space 65536K, <span class="hljs-number">3</span>% used [<span class="hljs-number">0x00000000fab00000</span>,<span class="hljs-number">0x00000000faceb9f8</span>,<span class="hljs-number">0x00000000feb00000</span>)  from space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000ff580000</span>)  to   space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x0000000100000000</span>) ParOldGen       total 175104K, used 646K [<span class="hljs-number">0x00000000f0000000</span>, <span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x00000000fab00000</span>)  object space 175104K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000f0000000</span>,<span class="hljs-number">0x00000000f00a1b88</span>,<span class="hljs-number">0x00000000fab00000</span>) Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 387K, capacity 390K, committed 512K, reserved 1048576K</code></pre><p>Q：就多定义了一个局部变量 value ，就可以把字节数组回收了呢？</p><p>A：局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行 System.gc() 时被回收。看，value 位于局部变量表中索引为 1 的位置。value这个局部变量把原本属于buffer的slot给占用了，这样栈上就没有buffer变量指向<code>new byte[10 * 1024 * 1024]</code>实例了。</p><blockquote><p>这点看不懂的可以看我前面的文章：虚拟机栈 –&gt; Slot的重复利用</p></blockquote><img src="\chapter_011\0004.png"><img src="\chapter_011\0005.png"><p><strong>调用 localvarGC5() 方法</strong></p><p>局部变量除了方法范围就是失效了，堆中的字节数组铁定被回收</p><pre><code class="hljs java">[GC (System.gc()) [PSYoungGen: 15492K-&gt;840K(76288K)] 15492K-&gt;11088K(251392K), <span class="hljs-number">0.0070281</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] [Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 840K-&gt;0K(76288K)] [ParOldGen: 10248K-&gt;10911K(175104K)] 11088K-&gt;10911K(251392K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="hljs-number">0.0082011</span> secs] [Times: user=<span class="hljs-number">0.03</span> sys=<span class="hljs-number">0.03</span>, real=<span class="hljs-number">0.01</span> secs] [GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] 10911K-&gt;10911K(251392K), <span class="hljs-number">0.0004440</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] [Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10911K-&gt;671K(175104K)] 10911K-&gt;671K(251392K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="hljs-number">0.0108555</span> secs] [Times: user=<span class="hljs-number">0.08</span> sys=<span class="hljs-number">0.02</span>, real=<span class="hljs-number">0.01</span> secs] Heap PSYoungGen      total 76288K, used 655K [<span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)  eden space 65536K, <span class="hljs-number">1</span>% used [<span class="hljs-number">0x00000000fab00000</span>,<span class="hljs-number">0x00000000faba3ee8</span>,<span class="hljs-number">0x00000000feb00000</span>)  from space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x0000000100000000</span>)  to   space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000ff580000</span>) ParOldGen       total 175104K, used 671K [<span class="hljs-number">0x00000000f0000000</span>, <span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x00000000fab00000</span>)  object space 175104K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000f0000000</span>,<span class="hljs-number">0x00000000f00a7cf8</span>,<span class="hljs-number">0x00000000fab00000</span>) Metaspace       used 3499K, capacity 4502K, committed 4864K, reserved 1056768K  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 387K, capacity 390K, committed 512K, reserved 1048576K</code></pre><h2 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ol><li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li><li>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</li><li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</li><li>Javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</li></ol><p><strong>内存溢出（OOM）原因分析</strong></p><p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p><ol><li><p>Java虚拟机的堆内存设置不够。</p><ul><li>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</li></ul></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p><ul><li>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</li><li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</li></ul></li><li><p>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ul><li>例如：在引用机制分析中，涉及到JVM会去尝试<strong>回收软引用指向的对象</strong>等。</li><li>在java.nio.Bits.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li></ul></li><li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><ul><li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</li></ul></li></ol><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ol><li><p>也称作“存储渗漏”。严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</strong></p></li><li><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p></li><li><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。</p></li><li><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p></li></ol><p><strong>内存泄露官方例子</strong></p><p>左边的图：Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的对象。</p><p>右边的图：后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开（图示中的Forgotten Reference Memory Leak），从而导致没有办法被回收。</p><img src="\chapter_011\0006.png"><blockquote><p>忘记断开就是根节点无法被消除，或者他的子节点没赋值成NULL</p></blockquote><p><strong>常见例子</strong></p><ol><li>单例模式<ul><li>单例的生命周期和应用程序是一样长的，所以在单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</li></ul></li><li>一些提供close()的资源未关闭导致内存泄漏<ul><li>数据库连接 dataSourse.getConnection()，网络连接socket和io连接必须手动close，否则是不能被回收的。</li></ul></li></ol><h2 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop the World"></a>Stop the World</h2><ol><li><p>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW。</p></li><li><p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所有 Java 执行线程呢？</p><ul><li><p>分析工作必须在一个能确保一致性的快照中进行</p></li><li><p>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</p></li><li><p><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></p></li></ul></li><li><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p></li><li><p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p></li><li><p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p></li><li><p>STW是JVM在<strong>后台自动发起和自动完成</strong>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p></li><li><p>开发中不要用System.gc() ，这会导致Stop-the-World的发生。</p></li></ol><h3 id="代码感受-Stop-the-World"><a href="#代码感受-Stop-the-World" class="headerlink" title="代码感受 Stop the World"></a>代码感受 Stop the World</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopTheWorldDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;        List&lt;<span class="hljs-type">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">byte</span>[]&gt;();        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">1000</span>;i++)&#123;                        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];                        list.add(buffer);                    &#125;                    <span class="hljs-keyword">if</span>(list.size() &gt; <span class="hljs-number">10000</span>)&#123;                        list.clear();                        System.gc();<span class="hljs-comment">//会触发full gc，进而会出现STW事件</span>                                         &#125;                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;                ex.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                    <span class="hljs-comment">// 每秒打印时间信息</span>                    <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - startTime;                    System.out.println(t / <span class="hljs-number">1000</span> + <span class="hljs-string">&quot;.&quot;</span> + t % <span class="hljs-number">1000</span>);                    Thread.sleep(<span class="hljs-number">1000</span>);                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;                ex.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">WorkThread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkThread</span>();        <span class="hljs-type">PrintThread</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintThread</span>();        w.start();        p.start();    &#125;&#125;</code></pre><p>关闭工作线程 w ，观察输出：当前时间间隔与上次时间间隔<strong>基本</strong>是每隔1秒打印一次</p><pre><code class="hljs java"><span class="hljs-number">0.1</span><span class="hljs-number">1.1</span><span class="hljs-number">2.2</span><span class="hljs-number">3.2</span><span class="hljs-number">4.3</span><span class="hljs-number">5.3</span><span class="hljs-number">6.3</span><span class="hljs-number">7.3</span>Process finished with exit code -<span class="hljs-number">1</span></code></pre><p>开启工作线程 w ，观察打印输出：当前时间间隔与上次时间间隔相差 1.3s ，可以明显感受到 Stop the World 的存在</p><pre><code class="hljs java"><span class="hljs-number">0.1</span><span class="hljs-number">1.4</span><span class="hljs-number">2.7</span><span class="hljs-number">3.8</span><span class="hljs-number">4.12</span><span class="hljs-number">5.13</span>Process finished with exit code -<span class="hljs-number">1</span></code></pre><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发的概念"><a href="#并发的概念" class="headerlink" title="并发的概念"></a>并发的概念</h3><ol><li><p>在操作系统中，是指<strong>一个时间段</strong>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</p></li><li><p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换。由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行</p></li></ol><img src="\chapter_011\0007.png"><h3 id="并行的概念"><a href="#并行的概念" class="headerlink" title="并行的概念"></a>并行的概念</h3><ol><li><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以<strong>同时</strong>进行，我们称之为并行（Parallel）</p></li><li><p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行</p></li><li><p>适合科学计算，后台处理等弱交互场景</p></li></ol><img src="\chapter_011\0008.png"><blockquote><p><strong>并发与并行的对比</strong></p></blockquote><ol><li>并发，指的是多个事情，在同一时间段内同时发生了。</li><li>并行，指的是多个事情，在同一时间点上（或者说同一时刻）同时发生了。</li><li>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</li><li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li></ol><h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><ol><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<ul><li>如ParNew、Parallel Scavenge、Parallel Old</li></ul></li><li>串行（Serial）<ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收（单线程）</li></ul></li></ol><img src="\chapter_011\0009.png"><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><ol><li>并发（Concurrent）：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。<ul><li>比如用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li></ul></li><li>典型垃圾回收器：CMS、G1</li></ol><img src="\chapter_011\0010.png"><blockquote><ul><li>串行是单线程的，而并发可以是多线程的。</li><li>串行只能完成一个任务后才能开始下一个任务，而并发可以同时处理多个任务。<ul><li>这个同时是宏观上查看</li></ul></li><li>串行是按照固定顺序执行任务，而并发是根据任务的优先级和可利用的资源来决定处理顺序。</li><li>并发需要考虑数据共享和同步问题，而串行则不需要。</li><li>并发需要更多的资源开销，例如线程同步、通信等，而串行则不需要。</li></ul></blockquote><h2 id="HotSpot的算法实现细节"><a href="#HotSpot的算法实现细节" class="headerlink" title="HotSpot的算法实现细节"></a>HotSpot的算法实现细节</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p>1、固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。 </p><p>2、迄今为止，<strong>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong>，因此毫无疑问根节点 枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。现在可达性分析算法耗时 最长的查找引用链的过程已经可以做到与用户线程一起并发，<strong>但根节点枚举始终还 是必须在一个能保障一致性的快照中才得以进行</strong>——这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化 的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有 用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。</p><p>3、由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有 执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为<strong>OopMap的数据结构</strong>来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也 会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信 息了，<strong>并不需要真正一个不漏地从方法区等GC Roots开始查找</strong>。</p><p>4、Exact VM因它使用<strong>准确式内存管理</strong>（Exact Memory Management，也可以叫Non-Con- servative&#x2F;Accurate Memory Management）而得名。准确式内存管理是指虚拟机可以知道内存中某个位 置的数据具体是什么类型。譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一 个指向了123456的内存地址的引用类型还是一个数值为123456的整数，准确分辨出哪些内存是引用类 型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。【<strong>这个不是特别重要，了解一下即可</strong>】</p><blockquote><p><strong>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举</strong></p></blockquote><h3 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h3><p><strong>安全点（Safepoint）</strong></p><ol><li><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p></li><li><p>Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。比如：选择一些执行时间较长的指令作为Safe Point，<strong>如方法调用、循环跳转和异常跳转等</strong>。</p></li></ol><blockquote><p>这里应该是，长时间执行代码块的开头或结尾设置安全点，一旦进入这种长时间执行的代码块会改变对象引用关系就不能停，导致无法快速进入安全点，其它线程要一直等它一起gc</p></blockquote><p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p><ol><li>抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li>主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候<strong>主动轮询</strong>这个标志，如果中断标志为真，则将自己进行中断挂起。</li></ol><blockquote><p>在这个机制中，设置一个中断标志，当需要中断线程时，将中断标志设置为真。而每个线程在运行到“Safe Point”时，都会主动轮询这个中断标志，一旦发现中断标志为真，就会将自己进行中断挂起。Safe Point是指程序在执行期间的某个控制点，执行线程在安全点处挂起是安全的，因为此时它不会破坏 JVM 内部数据结构的一致性和状态。</p></blockquote><p><strong>安全区域（Safe Region）</strong></p><ol><li>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？</li><li>例如线程处于Sleep状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</li><li><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把Safe Region看做是被扩展了的Safepoint。</li></ol><p><strong>安全区域的执行流程</strong></p><ol><li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举），如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li></ol><h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><h4 id="什么是跨代引用？"><a href="#什么是跨代引用？" class="headerlink" title="什么是跨代引用？"></a>什么是跨代引用？</h4><p>1、一般的垃圾回收算法至少会划分出两个年代，年轻代和老年代。但是单纯的分代理论在垃圾回收的时候存在一个巨大的缺陷：为了找到年轻代中的存活对象，却不得不遍历整个老年代，反过来也是一样的。</p><img src="\chapter_011\0011.png"><p>2、如果我们从年轻代开始遍历，那么可以断定N, S, P, Q都是存活对象。但是，V却不会被认为是存活对象，其占据的内存会被回收了。这就是一个惊天的大漏洞！因为U本身是老年代对象，而且有外部引用指向它，也就是说U是存活对象，而U指向了V，也就是说V也应该是存活对象才是！而这都是因为我们只遍历年轻代对象！</p><p>3、所以，为了解决这种跨代引用的问题，最笨的办法就是遍历老年代的对象，找出这些跨代引用来。这种方案存在极大的性能浪费。因为从两个分代假说里面，其实隐含了一个推论：跨代引用是极少的。也就是为了找出那么一点点跨代引用，我们却得遍历整个老年代！从上图来说，很显然的是，我们根本不必遍历R。</p><p>4、因此，为了避免这种遍历老年代的性能开销，通常的分代垃圾回收器会引入一种称为<strong>记忆集</strong>的技术。<strong>简单来说，记忆集就是用来记录跨代引用的表。</strong></p><h4 id="记忆集与卡表-1"><a href="#记忆集与卡表-1" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h4><p>1、为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建 立了名为<strong>记忆集（Remembered Set）的数据结构</strong>，用以避免把整个老年代加进GC Roots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的 垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题，因此我们有必要进一步 理清记忆集的原理和实现方式，以便在后续章节里介绍几款最新的收集器相关知识时能更好地理解。</p><p>2、记忆集是一种用于记录<strong>从非收集区域指向收集区域的指针集合的抽象数据结构</strong>。如果我们不考虑效率和成本的话，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构。</p><blockquote><p>比如说我们有老年代（非收集区域）和年轻代（收集区域）的对象之间有一条引用链</p></blockquote><p>3、这种记录全部含跨代引用对象的实现方案，无论是空间占用还是维护成本都相当高昂。而在垃圾 收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针 就可以了，并不需要了解这些跨代指针的全部细节。那设计者在实现记忆集的时候，便可以选择更为 粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范 围以外的）的记录精度：</p><ul><li>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。 </li><li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。 </li><li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li></ul><p>4、其中，第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这也是 目前最常用的一种记忆集实现形式，一些资料中甚至直接把它和记忆集混为一谈。前面定义中提到记 忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的 具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。 关于卡表与记忆集的关系，读者不妨按照Java语言中HashMap与Map的关系来类比理解。 卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的</p><blockquote><p>读者只需要知道有这个东西，面试的时候能说出来，再细致一点的就需要看周志明老师的第三版书了</p></blockquote><h2 id="再谈引用概述"><a href="#再谈引用概述" class="headerlink" title="再谈引用概述"></a>再谈引用概述</h2><ol><li><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p></li><li><p>既偏门又非常高频的面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p></li><li><p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p><ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）</li></ul></li><li><p>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p></li></ol><img src="\chapter_011\0012.png" ><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ol><li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>object obj=new Object()</code>”这种引用关系。<span style="color:red">无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁可报OOM，也不会GC</span>     死也不回收</li><li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。    在gc回收时 内存不足才回收 内存足够就不回收</li><li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，<span style="color:red">无论内存空间是否足够，都会回收掉被弱引用关联的对象</span>。   在gc回收时  内存不论够不够都会进行回收</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<span style="color:red">为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</span>。</li></ol><h2 id="再谈引用：强引用"><a href="#再谈引用：强引用" class="headerlink" title="再谈引用：强引用"></a>再谈引用：强引用</h2><ol><li><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong>。</p></li><li><p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p></li><li><p><strong>只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong>只要强引用的对象是可达的，jvm宁可报OOM，也不会回收强引用。</p></li><li><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p></li><li><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p></li></ol><p><strong>强引用代码举例</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrongReferenceTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span> (<span class="hljs-string">&quot;Hello,尚硅谷&quot;</span>);        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> str;        str = <span class="hljs-literal">null</span>;        System.gc();        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">3000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(str1);    &#125;&#125;</code></pre><p>输出</p><pre><code class="hljs java">Hello,尚硅谷</code></pre><p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p><p><code>StringBuffer str = new StringBuffer(&quot;hello,尚硅谷&quot;);</code></p><img src="\chapter_011\0013.png"><p><strong>总结</strong></p><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p><ol><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ol><h2 id="再谈引用：软引用"><a href="#再谈引用：软引用" class="headerlink" title="再谈引用：软引用"></a>再谈引用：软引用</h2><p><strong>软引用（Soft Reference）：内存不足即回收</strong></p><ol><li><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的第一次回收是不可达的对象</p></li><li><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p></li><li><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p></li><li><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p></li><li><p>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</p></li></ol><p>在JDK1.2版之后提供了SoftReference类来实现软引用</p><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">// 声明强引用</span>SoftReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(obj);obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">//销毁强引用</span></code></pre><p>必须销毁强引用！！！</p><p><strong>软引用代码举例</strong></p><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftReferenceTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;            <span class="hljs-built_in">this</span>.id = id;            <span class="hljs-built_in">this</span>.name = name;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;        <span class="hljs-keyword">public</span> String name;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[id=&quot;</span> + id + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;] &quot;</span>;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//创建对象，建立软引用</span><span class="hljs-comment">//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, &quot;songhk&quot;));</span>        <span class="hljs-comment">//上面的一行代码，等价于如下的三行代码</span>        <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;songhk&quot;</span>);        SoftReference&lt;User&gt; userSoftRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;User&gt;(u1);        u1 = <span class="hljs-literal">null</span>;<span class="hljs-comment">//取消强引用</span>        <span class="hljs-comment">//从软引用中重新获得强引用对象</span>        System.out.println(userSoftRef.get());        System.out.println(<span class="hljs-string">&quot;---目前内存还不紧张---&quot;</span>);        System.gc();        System.out.println(<span class="hljs-string">&quot;After GC:&quot;</span>);<span class="hljs-comment">//        //垃圾回收之后获得软引用中的对象</span>        System.out.println(userSoftRef.get());<span class="hljs-comment">//由于堆空间内存足够，所有不会回收软引用的可达对象。</span>        System.out.println(<span class="hljs-string">&quot;---下面开始内存紧张了---&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//让系统认为内存资源紧张、不够</span>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">7</span>];            <span class="hljs-comment">//byte[] b = new byte[1024 * 7168 - 635 * 1024];</span>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//再次从软引用中获取数据</span>            System.out.println(userSoftRef.get());<span class="hljs-comment">//在报OOM之前，垃圾回收器会回收软引用的可达对象。</span>        &#125;    &#125;&#125;</code></pre><p>JVM参数</p><p><code>-Xms10m -Xmx10m</code></p><p>在 JVM 内存不足时，会清理软引用对象</p><p>输出结果：</p><pre><code class="hljs java">[id=<span class="hljs-number">1</span>, name=songhk] ---目前内存还不紧张---After GC:[id=<span class="hljs-number">1</span>, name=songhk] ---下面开始内存紧张了---java.lang.OutOfMemoryError: Java heap spaceat com.atguigu.java1.SoftReferenceTest.main(SoftReferenceTest.java:<span class="hljs-number">48</span>)<span class="hljs-literal">null</span>Process finished with exit code <span class="hljs-number">0</span></code></pre><h2 id="再谈引用：弱引用"><a href="#再谈引用：弱引用" class="headerlink" title="再谈引用：弱引用"></a>再谈引用：弱引用</h2><blockquote><p><strong>弱引用（Weak Reference）发现即回收</strong></p></blockquote><ol><li>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</strong>。</li><li>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</li><li>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</li><li>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</li></ol><blockquote><p>三级缓存     内存–&gt;本地–&gt;网络</p></blockquote><p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p><pre><code class="hljs java"><span class="hljs-comment">// 声明强引用</span><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();WeakReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(obj);obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">//销毁强引用</span></code></pre><p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p><p><strong>面试题：你开发中使用过WeakHashMap吗？</strong></p><p><strong>弱引用代码举例</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakReferenceTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;            <span class="hljs-built_in">this</span>.id = id;            <span class="hljs-built_in">this</span>.name = name;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;        <span class="hljs-keyword">public</span> String name;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[id=&quot;</span> + id + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;] &quot;</span>;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//构造了弱引用</span>        WeakReference&lt;User&gt; userWeakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;User&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;songhk&quot;</span>));        <span class="hljs-comment">//从弱引用中重新获取对象</span>        System.out.println(userWeakRef.get());        System.gc();        <span class="hljs-comment">// 不管当前内存空间足够与否，都会回收它的内存</span>        System.out.println(<span class="hljs-string">&quot;After GC:&quot;</span>);        <span class="hljs-comment">//重新尝试从弱引用中获取对象</span>        System.out.println(userWeakRef.get());    &#125;&#125;</code></pre><p>执行垃圾回收后，软引用对象必定被清除</p><pre><code class="hljs java">[id=<span class="hljs-number">1</span>, name=songhk] After GC:<span class="hljs-literal">null</span>Process finished with exit code <span class="hljs-number">0</span></code></pre><h2 id="再谈引用：虚引用"><a href="#再谈引用：虚引用" class="headerlink" title="再谈引用：虚引用"></a>再谈引用：虚引用</h2><p><strong>虚引用（Phantom Reference）：对象回收跟踪</strong></p><ol><li><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p></li><li><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p></li><li><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null 。<strong>即通过虚引用无法获取到我们的数据</strong></p></li><li><p><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></p></li><li><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。 </p></li><li><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p></li></ol><p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p><pre><code class="hljs java"><span class="hljs-comment">// 声明强引用</span><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">// 声明引用队列</span><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">phantomQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<span class="hljs-comment">// 声明虚引用（还需要传入引用队列）</span>PhantomReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);obj = <span class="hljs-literal">null</span>;</code></pre><p><strong>虚引用代码示例</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhantomReferenceTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PhantomReferenceTest obj;<span class="hljs-comment">//当前类对象的声明</span>    <span class="hljs-keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="hljs-literal">null</span>;<span class="hljs-comment">//引用队列</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckRefQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                <span class="hljs-keyword">if</span> (phantomQueue != <span class="hljs-literal">null</span>) &#123;                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="hljs-literal">null</span>;                    <span class="hljs-keyword">try</span> &#123;                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    <span class="hljs-keyword">if</span> (objt != <span class="hljs-literal">null</span>) &#123;                        System.out.println(<span class="hljs-string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; <span class="hljs-comment">//finalize()方法只能被调用一次！</span>        <span class="hljs-built_in">super</span>.finalize();        System.out.println(<span class="hljs-string">&quot;调用当前类的finalize()方法&quot;</span>);        obj = <span class="hljs-built_in">this</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckRefQueue</span>();        t.setDaemon(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span>        t.start();        phantomQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;PhantomReferenceTest&gt;();        obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReferenceTest</span>();        <span class="hljs-comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span>        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;PhantomReferenceTest&gt;(obj, phantomQueue);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//不可获取虚引用中的对象</span>            System.out.println(phantomRef.get());System.out.println(<span class="hljs-string">&quot;第 1 次 gc&quot;</span>);            <span class="hljs-comment">//将强引用去除</span>            obj = <span class="hljs-literal">null</span>;            <span class="hljs-comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span>            System.gc();            Thread.sleep(<span class="hljs-number">1000</span>);            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;                System.out.println(<span class="hljs-string">&quot;obj 是 null&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                System.out.println(<span class="hljs-string">&quot;obj 可用&quot;</span>);            &#125;            System.out.println(<span class="hljs-string">&quot;第 2 次 gc&quot;</span>);            obj = <span class="hljs-literal">null</span>;            System.gc(); <span class="hljs-comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span>            Thread.sleep(<span class="hljs-number">1000</span>);            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;                System.out.println(<span class="hljs-string">&quot;obj 是 null&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                System.out.println(<span class="hljs-string">&quot;obj 可用&quot;</span>);            &#125;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>1、第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次GC，因为会调用finalize方法，将对象复活了，所以对象没有被回收</p><p>2、但是调用第二次GC操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是将待回收的对象存入到引用队列中。</p><p>输出结果：</p><pre><code class="hljs java"><span class="hljs-literal">null</span>第 <span class="hljs-number">1</span> 次 gc调用当前类的finalize()方法obj 可用第 <span class="hljs-number">2</span> 次 gc追踪垃圾回收过程：PhantomReferenceTest实例被GC了obj 是 <span class="hljs-literal">null</span>Process finished with exit code <span class="hljs-number">0</span></code></pre><h2 id="再谈引用：终结器引用（了解）"><a href="#再谈引用：终结器引用（了解）" class="headerlink" title="再谈引用：终结器引用（了解）"></a>再谈引用：终结器引用（了解）</h2><ol><li><p>它用于实现对象的finalize() 方法，也可以称为终结器引用</p></li><li><p>无需手动编码，其内部配合引用队列使用</p></li><li><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收相关概念&quot;&gt;&lt;a href=&quot;#垃圾回收相关概念&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收相关概念&quot;&gt;&lt;/a&gt;垃圾回收相关概念&lt;/h1&gt;&lt;h2 id=&quot;System-gc-的理解&quot;&gt;&lt;a href=&quot;#System-gc-的理解&quot; c</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>10.JVM系列-垃圾回收概述和相关算法</title>
    <link href="http://example.com/2023/04/21/10-JVM%E7%B3%BB%E5%88%97-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%92%8C%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/04/21/10-JVM%E7%B3%BB%E5%88%97-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%92%8C%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</id>
    <published>2023-04-21T12:56:00.000Z</published>
    <updated>2024-03-12T09:43:26.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><img src="/chapter_010/0001.png"><ol><li><p>Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C++语言没有垃圾收集技术，需要程序员手动的收集。</p></li><li><p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</p></li><li><p>关于垃圾收集有三个经典问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul></li><li><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p></li></ol><h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><h3 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h3><ol><li><p>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？</p><ul><li>垃圾回收器 CMS G1</li><li>CMS垃圾回收器主要采用标记-清除算法进行垃圾回收，在垃圾回收回收期间stw较短，并且算法实现简单，但会产生浮动垃圾，导致空间的浪费</li><li>G1垃圾回收器，采用分区算法进行垃圾回收，将整个堆空间分成多个小空间，每次垃圾回收只在一个小分区中进行， 降低了STW，提高了系统吞吐量</li></ul></li><li><p>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</p><ul><li>垃圾回收算法有 标记-清除算法，复制算法，标记-压缩算法</li><li>目前jdk采用分区算法，不同的分区采用不同的垃圾回收算法<ul><li>新生代采用复制算法，新生代中存在s0和s1区进行对杨的清除和复制</li><li>老年代采用标记-压缩算法  将有用的对象进行标记后，删除没有标记的垃圾，在将对象一用到逻辑上相邻的区域</li></ul></li></ul></li><li><p>G1回收器讲下回收过程GC是什么？为什么要有GC？</p><ul><li>GC是垃圾回收器，用于将没有引用的对象进行回收</li><li>对于高级语言来说，如果不进行垃圾回收，内存迟早都会被填满，GC垃圾回收器通过对垃圾回收，实现内存空间的释放</li></ul></li><li><p>GC的两种判定方法？CMS收集器与G1收集器的特点</p></li></ol><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ol><li>说一下GC算法，分代回收说下<ul><li>在堆空间中，不同的对象生命周期不同，不同的生命周期需要不同的垃圾回收算法，在java中将器分为新生代和老年代，根据不同分区的特点，选用不同的算法从而提高垃圾回收效率，减少stw时间</li></ul></li><li>垃圾收集策略和算法</li></ol><h3 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h3><ol><li><p>JVM GC原理，JVM怎么回收内存</p><ul><li>在jvm回收时会先用可达性分析算判断该对象是否还有引用引用，如果还有就不进行垃圾回收，没有进行垃圾回收，在垃圾回收的时候，如果重写finalzation方法，并且是第一次访问，在该方法中有堆该对象的引用，就将该对象复活</li><li>在回收内存时，有三中常见的垃圾回收算法，即标记清除算法 标记压缩算法，复制算法，在不同的堆分区中采用不用的算法。基本实现 经常处理新生代，很少处理老年代，基本不处理原空间</li></ul></li><li><p>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</p><ul><li>cms特点 采用标记-清除算法，算法实现较为简单，回收速度较快，但会产生大量的内存碎片空间，堆内存的利用效率不高</li></ul></li></ol><h3 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h3><ol><li>Java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的</li></ol><h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><ol><li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1，</li><li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li></ol><h3 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h3><ol><li>讲一讲垃圾回收算法。</li><li>什么情况下触发垃圾回收？</li><li>如何选择合适的垃圾收集算法？</li><li>JVM有哪三种垃圾回收器？</li></ol><h3 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h3><ol><li>常见的垃圾回收器算法有哪些，各有什么优劣？</li><li>System.gc()和Runtime.gc()会做什么事情？</li><li>Java GC机制？GC Roots有哪些？</li><li>Java对象的回收方式，回收算法。</li><li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li><li>CMS回收停顿了几次，为什么要停顿两次?</li></ol><h2 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h2><ol><li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li><li>外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.</li><li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致<strong>内存溢出</strong>。</li><li>对象已经不再使用 但引用依旧指向该对象 造成内存泄漏</li></ol><h2 id="为什么需要GC？"><a href="#为什么需要GC？" class="headerlink" title="为什么需要GC？"></a>为什么需要GC？</h2><p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p><ol><li><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p></li><li><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</p></li><li><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p><blockquote><p>当java应用程序运行时，jvm会自动进行垃圾回收以释放未使用的内存空间。在这个过程中可能会发生一种称为“stw”（stop-the-world，全局停顿）的现象。</p><p>stw是指当jvm执行<strong>回收时，它将暂停应用程序的所有线程。这是必需的，因为在清理无用的对象和释放内存时，需要对整个堆进行遍历。如果有线程继续创建新的对象和修改堆内容，那么就有可能导致</strong>回收器将新分配的内存错误地认为是无用的，并将其清理掉。这会导致代码不一致、数据损坏或内存泄漏。</p><p>因此，在stw期间，应用程序暂停了。一旦<strong>回收完成，jvm会恢复所有线程的执行。stw的时间通常很短，但是如果堆非常大，则可能需要较长的时间来进行</strong>回收。stw可能会对应用程序的性能产生影响。为了尽可能减少stw时间，可以使用不同的垃圾收集算法和优化设置。</p><blockquote><p>在JVM中，全局停顿是中断的一种形式。这种中断称为“Stop The World”（STW）。当Java应用程序中的线程需要执行一些特殊操作，例如垃圾回收或类加载时，JVM会发出一个命令，要求所有线程都暂停执行。这样做是为了确保数据结构能够被正确更新以及对象被正确回收。</p></blockquote><blockquote><p>在全局停顿期间，所有线程都被挂起，除了执行java虚拟机本身工作的线程。因此，这个过程会严重影响应用程序的性能和响应时间，特别是在大型和高并发的应用程序中。</p></blockquote></blockquote></li></ol><h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><ol><li>在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</li></ol>  <pre><code class="hljs c++">MibBridge *pBridge= <span class="hljs-keyword">new</span> cmBaseGroupBridge（）；<span class="hljs-comment">//如果注册失败，使用Delete释放该对象所占内存区域</span><span class="hljs-keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）<span class="hljs-keyword">delete</span> pBridge;</code></pre><ol start="2"><li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p></li><li><p>有了垃圾回收机制后，上述代码极有可能变成这样</p></li></ol>  <pre><code class="hljs c++">MibBridge *pBridge=<span class="hljs-keyword">new</span> <span class="hljs-built_in">cmBaseGroupBridge</span>(); pBridge-&gt;<span class="hljs-built_in">Register</span>(kDestroy);</code></pre><ol start="4"><li>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。</li></ol><h2 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h2><h3 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h3><blockquote><p><strong>官网介绍</strong>：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p></blockquote><p><strong>自动内存管理的优点</strong></p><ol><li><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p></li><li><p>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</p></li><li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p></li></ol><p><strong>关于自动内存管理的担忧</strong></p><ol><li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</li><li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li><li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li></ol><h3 id="应该关心哪些区域的回收？"><a href="#应该关心哪些区域的回收？" class="headerlink" title="应该关心哪些区域的回收？"></a>应该关心哪些区域的回收？</h3><img src="/chapter_010/0003.png"><ol><li><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，</p></li><li><p>其中，<strong>Java堆是垃圾收集器的工作重点</strong></p></li><li><p>从次数上讲：</p><ol><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ol></li></ol><h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><p>如何寻找垃圾？ 标记阶段</p><p>如何回收垃圾？ 清除阶段</p><h2 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h2><h3 id="标记阶段的目的"><a href="#标记阶段的目的" class="headerlink" title="标记阶段的目的"></a>标记阶段的目的</h3><p><strong>垃圾标记阶段：主要是为了判断对象是否存活</strong></p><ol><li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。</strong>只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</li><li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li><li>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</li></ol><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ol><li>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</li><li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li><li>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li><li>缺点：<ol><li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li><li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li></ol></li></ol><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><img src="/chapter_010/0004.png"><p>当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏</p><h3 id="证明：java使用的不是引用计数算法"><a href="#证明：java使用的不是引用计数算法" class="headerlink" title="证明：java使用的不是引用计数算法"></a>证明：java使用的不是引用计数算法</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * -XX:+PrintGCDetails</span><span class="hljs-comment"> * 证明：java使用的不是引用计数算法</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCountGC</span> &#123;    <span class="hljs-comment">//这个成员属性唯一的作用就是占用一点内存</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] bigSize = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">5</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<span class="hljs-comment">//5MB</span>    <span class="hljs-type">Object</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">RefCountGC</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefCountGC</span>();        <span class="hljs-type">RefCountGC</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefCountGC</span>();        obj1.reference = obj2;        obj2.reference = obj1;        obj1 = <span class="hljs-literal">null</span>;        obj2 = <span class="hljs-literal">null</span>;        <span class="hljs-comment">//显式的执行垃圾回收行为</span>        <span class="hljs-comment">//这里发生GC，obj1和obj2能否被回收？</span>        System.gc();    &#125;&#125;</code></pre><img src="/chapter_010/0005.png"><ul><li>如果不小心直接把<code>obj1.reference</code>和<code>obj2.reference</code>置为null。则在Java堆中的两块内存依然保持着互相引用，无法被回收</li></ul><p><strong>没有进行GC时</strong></p><p>把下面的几行代码注释掉，让它来不及</p><pre><code class="hljs java">System.gc();<span class="hljs-comment">//把这行代码注释掉</span></code></pre><pre><code class="hljs java">Heap PSYoungGen      total 38400K, used 14234K [<span class="hljs-number">0x00000000d5f80000</span>, <span class="hljs-number">0x00000000d8a00000</span>, <span class="hljs-number">0x0000000100000000</span>)  eden space 33280K, <span class="hljs-number">42</span>% used [<span class="hljs-number">0x00000000d5f80000</span>,<span class="hljs-number">0x00000000d6d66be8</span>,<span class="hljs-number">0x00000000d8000000</span>)  from space 5120K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000d8500000</span>,<span class="hljs-number">0x00000000d8500000</span>,<span class="hljs-number">0x00000000d8a00000</span>)  to   space 5120K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000d8000000</span>,<span class="hljs-number">0x00000000d8000000</span>,<span class="hljs-number">0x00000000d8500000</span>) ParOldGen       total 87552K, used 0K [<span class="hljs-number">0x0000000081e00000</span>, <span class="hljs-number">0x0000000087380000</span>, <span class="hljs-number">0x00000000d5f80000</span>)  object space 87552K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x0000000081e00000</span>,<span class="hljs-number">0x0000000081e00000</span>,<span class="hljs-number">0x0000000087380000</span>) Metaspace       used 3496K, capacity 4498K, committed 4864K, reserved 1056768K  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 387K, capacity 390K, committed 512K, reserved 1048576KProcess finished with exit code <span class="hljs-number">0</span></code></pre><p><strong>进行GC</strong></p><p>打开那行代码的注释</p><pre><code class="hljs java">[GC (System.gc()) [PSYoungGen: 13569K-&gt;808K(38400K)] 13569K-&gt;816K(125952K), <span class="hljs-number">0.0012717</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] [Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 808K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;670K(87552K)] 816K-&gt;670K(125952K), [Metaspace: 3491K-&gt;3491K(1056768K)], <span class="hljs-number">0.0051769</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] Heap PSYoungGen      total 38400K, used 333K [<span class="hljs-number">0x00000000d5f80000</span>, <span class="hljs-number">0x00000000d8a00000</span>, <span class="hljs-number">0x0000000100000000</span>)  eden space 33280K, <span class="hljs-number">1</span>% used [<span class="hljs-number">0x00000000d5f80000</span>,<span class="hljs-number">0x00000000d5fd34a8</span>,<span class="hljs-number">0x00000000d8000000</span>)  from space 5120K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000d8000000</span>,<span class="hljs-number">0x00000000d8000000</span>,<span class="hljs-number">0x00000000d8500000</span>)  to   space 5120K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000d8500000</span>,<span class="hljs-number">0x00000000d8500000</span>,<span class="hljs-number">0x00000000d8a00000</span>) ParOldGen       total 87552K, used 670K [<span class="hljs-number">0x0000000081e00000</span>, <span class="hljs-number">0x0000000087380000</span>, <span class="hljs-number">0x00000000d5f80000</span>)  object space 87552K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x0000000081e00000</span>,<span class="hljs-number">0x0000000081ea7990</span>,<span class="hljs-number">0x0000000087380000</span>) Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 387K, capacity 390K, committed 512K, reserved 1048576KProcess finished with exit code <span class="hljs-number">0</span></code></pre><p>1、从打印日志就可以明显看出来，已经进行了GC</p><p>2、如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li><li>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li><li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li><li>Python如何解决循环引用？<ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li><li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</li></ul></li></ol><h2 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h2><p><strong>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</strong></p><ol><li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</li><li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</li></ol><h3 id="可达性分析实现思路"><a href="#可达性分析实现思路" class="headerlink" title="可达性分析实现思路"></a>可达性分析实现思路</h3><ul><li><p>所谓”GCRoots”根集合就是一组必须活跃的引用</p></li><li><p>其基本思路如下：</p></li></ul><ol><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ol><img src="/chapter_010/0006.png"><h3 id="GC-Roots可以是哪些元素？"><a href="#GC-Roots可以是哪些元素？" class="headerlink" title="GC Roots可以是哪些元素？"></a>GC Roots可以是哪些元素？</h3><ol><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如：Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（StringTable）里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。</li></ul></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ol><img src="/chapter_010/0007.png"><ol><li>总结一句话就是，，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</li><li>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和局部回收（PartialGC）。<ul><li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li></ul></li></ol><p><strong>小技巧</strong></p><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><blockquote><p>可达性分析算法用于判断内存中哪些对象是可达的（reachable），即哪些对象可以被程序访问到，哪些对象已经不可被访问，因此需要回收。</p><p>如果进行可达性分析时内存状态没有保持一致性，那么可能会出现一些无法预测的问题。比如，某个对象的引用已经被删除了，但是这个引用在快照被创建之前并没有被更新，而在快照被创建后才被更新，那么这个对象将被错误地判断为可达，从而导致它不会被回收，浪费了内存资源。</p><p>为了避免这种情况发生，可达性分析算法要求需要在一个能够保障一致性的快照中进行分析，在这个快照中所有对象的引用关系与当前运行时状态相同，即该快照能够反映出内存中的实际对象引用关系。这样依据该快照，可达性分析算法才能够正确地判断哪些对象是可达的，哪些对象是不可达的，以便进行内存的垃圾回收。</p></blockquote></li><li><p>这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</p></li></ol><h2 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h2><h3 id="finalize-方法机制"><a href="#finalize-方法机制" class="headerlink" title="finalize() 方法机制"></a>finalize() 方法机制</h3><p><strong>对象销毁前的回调函数：finalize()</strong></p><ol><li><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</p></li><li><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p></li><li><p>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p></li></ol><p>Object 类中 finalize() 源码</p><pre><code class="hljs java"><span class="hljs-comment">// 等待被重写</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;</code></pre><ol><li>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：<ol><li>在finalize()时可能会导致对象复活。</li><li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li><li>一个糟糕的finalize()会严重影响GC的性能。比如finalize是个死循环</li></ol></li><li>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在<strong>本质上不同于C++中的析构函数</strong>。</li><li>finalize()方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ol><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态。</strong></p><ol><li>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：<ol><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li><li>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</li></ol></li><li>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</li></ol><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ol><li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行finalize()方法<ol><li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li><li>finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。</li></ol></li></ol><p><strong>通过 JVisual VM 查看 Finalizer 线程</strong></p><img src="/chapter_010/0008.png"><h3 id="代码演示-finalize-方法可复活对象"><a href="#代码演示-finalize-方法可复活对象" class="headerlink" title="代码演示 finalize() 方法可复活对象"></a>代码演示 finalize() 方法可复活对象</h3><p>我们重写 CanReliveObj 类的 finalize()方法，在调用其 finalize()方法时，将 obj 指向当前类对象 this</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CanReliveObj</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CanReliveObj obj;<span class="hljs-comment">//类变量，属于 GC Root</span>    <span class="hljs-comment">//此方法只能被调用一次</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-built_in">super</span>.finalize();        System.out.println(<span class="hljs-string">&quot;调用当前类重写的finalize()方法&quot;</span>);        obj = <span class="hljs-built_in">this</span>;<span class="hljs-comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanReliveObj</span>();            <span class="hljs-comment">// 对象第一次成功拯救自己</span>            obj = <span class="hljs-literal">null</span>;            System.gc();<span class="hljs-comment">//调用垃圾回收器</span>            System.out.println(<span class="hljs-string">&quot;第1次 gc&quot;</span>);            <span class="hljs-comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span>            Thread.sleep(<span class="hljs-number">2000</span>);            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;                System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);            &#125;            System.out.println(<span class="hljs-string">&quot;第2次 gc&quot;</span>);            <span class="hljs-comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span>            obj = <span class="hljs-literal">null</span>;            System.gc();            <span class="hljs-comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span>            Thread.sleep(<span class="hljs-number">2000</span>);            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;                System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);            &#125;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><strong>如果注释掉finalize()方法</strong></p><pre><code class="hljs java"><span class="hljs-comment">//此方法只能被调用一次</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;       <span class="hljs-built_in">super</span>.finalize();       System.out.println(<span class="hljs-string">&quot;调用当前类重写的finalize()方法&quot;</span>);       obj = <span class="hljs-built_in">this</span>;<span class="hljs-comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span>   &#125;</code></pre><p>输出结果：</p><pre><code class="hljs java">第<span class="hljs-number">1</span>次 gcobj is dead <span class="hljs-comment">//第一次已经死亡，第二次的system.gc已经没用了</span>第<span class="hljs-number">2</span>次 gcobj is dead</code></pre><p><strong>放开finalize()方法</strong></p><p>输出结果：</p><pre><code class="hljs java">第<span class="hljs-number">1</span>次 gc<span class="hljs-comment">//调用当前类重写的finalize()方法</span>obj is still alive第<span class="hljs-number">2</span>次 gcobj is dead</code></pre><p>第一次自救成功，但由于 finalize() 方法只会执行一次，所以第二次自救失败</p><h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><h3 id="MAT-介绍"><a href="#MAT-介绍" class="headerlink" title="MAT 介绍"></a>MAT 介绍</h3><ol><li>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</li><li>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</li><li>大家可以在<a href="http://www.eclipse.org/mat/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E4%BD%BF%E7%94%A8MAT">http://www.eclipse.org/mat/下载并使用MAT</a></li></ol><blockquote><p>1、虽然Jvisualvm很强大，但是在内存分析方面，还是MAT更好用一些</p><p>2、此小节主要是为了实时分析GC Roots是哪些东西，中间需要用到一个dump的文件</p></blockquote><h3 id="获取-dump-文件方式"><a href="#获取-dump-文件方式" class="headerlink" title="获取 dump 文件方式"></a>获取 dump 文件方式</h3><p><strong>方式一：命令行使用 jmap</strong></p><img src="/chapter_010/0009.png"><p><strong>方式二：使用JVisualVM</strong></p><ol><li>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</li><li>操作步骤下面演示</li></ol><h3 id="捕捉-dump-示例"><a href="#捕捉-dump-示例" class="headerlink" title="捕捉 dump 示例"></a>捕捉 dump 示例</h3><h4 id="使用JVisualVM捕捉-heap-dump"><a href="#使用JVisualVM捕捉-heap-dump" class="headerlink" title="使用JVisualVM捕捉 heap dump"></a>使用JVisualVM捕捉 heap dump</h4><p>代码：</p><ul><li>numList 和 birth 在第一次捕捉内存快照的时候，为 GC Roots</li><li>之后 numList 和 birth 置为 null ，对应的引用对象被回收，在第二次捕捉内存快照的时候，就不再是 GC Roots</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCRootsTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        List&lt;Object&gt; numList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-type">Date</span> <span class="hljs-variable">birth</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            numList.add(String.valueOf(i));            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">10</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;数据添加完毕，请操作：&quot;</span>);        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).next();        numList = <span class="hljs-literal">null</span>;        birth = <span class="hljs-literal">null</span>;        System.out.println(<span class="hljs-string">&quot;numList、birth已置空，请操作：&quot;</span>);        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).next();        System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);    &#125;&#125;</code></pre><p><strong>如何捕捉堆内存快照</strong></p><p>1、先执行第一步，然后停下来，去生成此步骤dump文件</p><img src="/chapter_010/0010.png"><p>2、 点击【堆 Dump】</p><img src="/chapter_010/0011.png"><p>3、右键 –&gt; 另存为即可</p><img src="/chapter_010/0012.jpg"><p>4、输入命令，继续执行程序</p><img src="/chapter_010/0013.png"><p>5、我们接着捕获第二张堆内存快照</p><img src="/chapter_010/0014.jpg"><h4 id="使用-MAT-查看堆内存快照"><a href="#使用-MAT-查看堆内存快照" class="headerlink" title="使用 MAT 查看堆内存快照"></a>使用 MAT 查看堆内存快照</h4><p>1、打开 MAT ，选择File –&gt; Open File，打开刚刚的两个dump文件，<strong>我们先打开第一个dump文件</strong></p><blockquote><p>点击Open Heap Dump也行</p></blockquote><img src="/chapter_010/0015.png"><p>2、选择Java Basics –&gt; GC Roots</p><img src="/chapter_010/0016.png"><p>3、第一次捕捉堆内存快照时，GC Roots 中包含我们定义的两个局部变量，类型分别为 ArrayList 和 Date，Total:21</p><img src="/chapter_010/0017.jpg"><p>4、打开第二个dump文件，第二次捕获内存快照时，由于两个局部变量引用的对象被释放，所以这两个局部变量不再作为 GC Roots ，从 Total Entries &#x3D; 19 也可以看出（少了两个 GC Roots）</p><img src="/chapter_010/0018.jpg"><h3 id="JProfiler-GC-Roots-溯源"><a href="#JProfiler-GC-Roots-溯源" class="headerlink" title="JProfiler GC Roots 溯源"></a>JProfiler GC Roots 溯源</h3><p>1、在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫<strong>GC Roots 溯源</strong></p><p>2、下面我们使用使用 JProfiler 进行 GC Roots 溯源演示</p><p>依然用下面这个代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCRootsTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        List&lt;Object&gt; numList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-type">Date</span> <span class="hljs-variable">birth</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            numList.add(String.valueOf(i));            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">10</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;数据添加完毕，请操作：&quot;</span>);        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).next();        numList = <span class="hljs-literal">null</span>;        birth = <span class="hljs-literal">null</span>;        System.out.println(<span class="hljs-string">&quot;numList、birth已置空，请操作：&quot;</span>);        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).next();        System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);    &#125;&#125;</code></pre><p>1、</p><img src="/chapter_010/0019.jpg"><p>2、</p><img src="/chapter_010/0020.png"><img src="/chapter_010/0021.jpg"><p>可以发现颜色变绿了，可以动态的看变化</p><p>3、右击对象，选择 Show Selection In Heap Walker，单独的查看某个对象</p><img src="/chapter_010/0022.png"><img src="/chapter_010/0023.png"><p>4、选择Incoming References，表示追寻 GC Roots 的源头</p><p>点击Show Paths To GC Roots，在弹出界面中选择默认设置即可</p><img src="/chapter_010/0024.jpg"><img src="/chapter_010/0025.png"><img src="/chapter_010/0026.png"><h3 id="JProfiler-分析-OOM"><a href="#JProfiler-分析-OOM" class="headerlink" title="JProfiler 分析 OOM"></a>JProfiler 分析 OOM</h3><blockquote><p>这里是简单的讲一下，后面篇章会详解</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * -Xms8m -Xmx8m </span><span class="hljs-comment"> * -XX:+HeapDumpOnOutOfMemoryError  这个参数的意思是当程序出现OOM的时候就会在当前工程目录生成一个dump文件</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapOOM</span> &#123;    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<span class="hljs-comment">//1MB</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        ArrayList&lt;HeapOOM&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span>&#123;            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;                list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapOOM</span>());                count++;            &#125;        &#125;<span class="hljs-keyword">catch</span> (Throwable e)&#123;            System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>程序输出日志</p><pre><code class="hljs java">com.atguigu.java.HeapOOMjava.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid14608.hprof ...java.lang.OutOfMemoryError: Java heap spaceat com.atguigu.java.HeapOOM.&lt;init&gt;(HeapOOM.java:<span class="hljs-number">12</span>)at com.atguigu.java.HeapOOM.main(HeapOOM.java:<span class="hljs-number">20</span>)Heap dump file created [<span class="hljs-number">7797849</span> bytes in <span class="hljs-number">0.010</span> secs]count = <span class="hljs-number">6</span></code></pre><p>打开这个dump文件</p><p>1、看这个超大对象</p><img src="/chapter_010/0027.png"><p>2、揪出 main() 线程中出问题的代码</p><img src="/chapter_010/0028.png"><h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><p><strong>垃圾清除阶段</strong></p><ul><li>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</li></ul><ol><li>标记-清除算法（Mark-Sweep）</li><li>复制算法（Copying）</li><li>标记-压缩算法（Mark-Compact）</li></ol><p><strong>背景</strong></p><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p><p><strong>执行过程</strong></p><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ol><li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<ul><li>注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</li></ul></li><li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ol><img src="/chapter_010/0029.png"><p><strong>标记-清除算法的缺点</strong></p><ol><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序(STW)，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ol><p><strong>注意：何为清除？</strong></p><p><strong>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里</strong>。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。</p><p>关于空闲列表是在为对象分配内存的时候提过：</p><ol><li>如果内存规整<ul><li>采用指针碰撞的方式进行内存分配</li></ul></li><li>如果内存不规整<ul><li>虚拟机需要维护一个空闲列表</li><li>采用空闲列表分配内存</li></ul></li></ol><h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><p><strong>背景</strong></p><ol><li>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</li></ol><p><strong>核心思想</strong></p><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><img src="/chapter_010/0030.png"><p>新生代里面就用到了复制算法，Eden区和S0区存活对象整体复制到S1区</p><p><strong>复制算法的优缺点</strong></p><p><strong>优点</strong></p><ol><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ol><p><strong>缺点</strong></p><ol><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ol><p><strong>复制算法的应用场景</strong></p><ol><li><p>如果复制算法需要复制的存活对象数量并不太大，效率才会较高</p><blockquote><p>如果需要复制的对象数量较多，导致复制次数较多 开销较大 效率低</p></blockquote></li><li><p>老年代大量的对象存活，那么复制的对象将会有很多，效率会很低</p></li><li><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p></li></ol><img src="/chapter_010/0031.png"><h2 id="清除阶段：标记-压缩算法"><a href="#清除阶段：标记-压缩算法" class="headerlink" title="清除阶段：标记-压缩算法"></a>清除阶段：标记-压缩算法</h2><p><strong>标记-压缩（或标记-整理、Mark - Compact）算法</strong></p><p><strong>背景</strong></p><ol><li><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法。</strong></p></li><li><p>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p></li><li><p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p></li></ol><p><strong>执行过程</strong></p><ol><li><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p></li><li><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p></li></ol><img src="/chapter_010/0032.png"><p><strong>标记-压缩算法与标记-清除算法的比较</strong></p><ol><li><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p></li><li><p>二者的本质差异在于标记-清除算法是一种<strong>非移动式的回收算法</strong>，标记-压缩是<strong>移动式的</strong>。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p></li><li><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p></li></ol><p><strong>标记-压缩算法的优缺点</strong></p><p><strong>优点</strong></p><ol><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ol><p><strong>缺点</strong></p><ol><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ol><h2 id="垃圾回收算法小结"><a href="#垃圾回收算法小结" class="headerlink" title="垃圾回收算法小结"></a>垃圾回收算法小结</h2><blockquote><p><strong>对比三种清除阶段的算法</strong></p></blockquote><ol><li><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p></li><li><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p></li></ol><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>没有最好的算法，只有最合适的算法</p><p><strong>为什么要使用分代收集算法</strong></p><ol><li><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p></li><li><p>分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</strong>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p></li><li><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关:</p><ul><li>比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。</li><li>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li></ul></li></ol><p><strong>目前几乎所有的GC都采用分代收集算法执行垃圾回收的</strong></p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ol><li><p>年轻代（Young Gen）</p><ul><li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li></ul></li><li><p>老年代（Tenured Gen）</p><ul><li><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p></li><li><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li><p>Mark阶段的开销与存活对象的数量成正比。</p></li><li><p>Sweep阶段的开销与所管理区域的大小成正相关。</p></li><li><p>Compact阶段的开销与存活对象的数据成正比。</p></li></ul></li></ul></li><li><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p></li><li><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p></li></ol><h2 id="增量收集算法和分区算法"><a href="#增量收集算法和分区算法" class="headerlink" title="增量收集算法和分区算法"></a>增量收集算法和分区算法</h2><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World</strong>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p><strong>增量收集算法基本思想</strong></p><ol><li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以选择让垃圾收集线程和应用程序线程交替执行。<strong>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></li><li>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></li></ol><p><strong>增量收集算法的缺点</strong></p><p>使用这种方式，由于在垃圾回收过程中，间断性地执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><blockquote><p>主要针对G1收集器来说的</p></blockquote><ol><li>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li><li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li></ol><img src="/chapter_010/0033.png"><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收概述&quot;&gt;&lt;a href=&quot;#垃圾回收概述&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收概述&quot;&gt;&lt;/a&gt;垃圾回收概述&lt;/h1&gt;&lt;img src=&quot;/chapter_010/0001.png&quot;&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Java 和 C++</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>9.JVM系列-StringTable</title>
    <link href="http://example.com/2023/04/16/9-JVM%E7%B3%BB%E5%88%97-StringTable/"/>
    <id>http://example.com/2023/04/16/9-JVM%E7%B3%BB%E5%88%97-StringTable/</id>
    <published>2023-04-16T06:22:45.000Z</published>
    <updated>2024-03-12T09:43:21.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringTable（字符串常量池）"><a href="#StringTable（字符串常量池）" class="headerlink" title="StringTable（字符串常量池）"></a>StringTable（字符串常量池）</h1><p>String在new后 会创建两个对象 分别为new出来的对象和堆空间中字符串常量的对象，创建完成之后 String对象引用会指向堆空间中的对象地址，堆空间中的对象地址指向字符串常量中的字符串</p><p>在字符串拼接的时候(存在变量拼接)对象只会在堆中，字符串常量中没有拼接后的字符串</p><h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><ol><li>String：字符串，使用一对 “” 引起来表示</li></ol>  <pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu&quot;</span> ;   <span class="hljs-comment">// 字面量的定义方式</span><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);     <span class="hljs-comment">// new 对象的方式</span></code></pre><ol start="2"><li><p>String被声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</p></li><li><p>String在jdk8及以前内部定义了<code>final char value[]</code>用于存储字符串数据。JDK9时改为<code>byte[]</code></p></li></ol><h2 id="为什么-JDK9-改变了-String-的结构"><a href="#为什么-JDK9-改变了-String-的结构" class="headerlink" title="为什么 JDK9 改变了 String 的结构"></a>为什么 JDK9 改变了 String 的结构</h2><blockquote><p> <strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/254">http://openjdk.java.net/jeps/254</a></p></blockquote><p><strong>为什么改为 byte[] 存储？</strong></p><ol><li>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。</li><li>从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。</li><li>之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 byte[] 数组 外加一个编码标识存储。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是其它字符集，比如UTF-8，你仍然用两个字节存</li><li>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</li><li>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 之前</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<span class="hljs-comment">// 之后</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] value</code></pre><h3 id="String-的基本特性"><a href="#String-的基本特性" class="headerlink" title="String 的基本特性"></a>String 的基本特性</h3><p>String（字符串）是一个特殊的对象，一旦初始化就不可以被改变。</p><ul><li>String：代表不可变的字符序列。简称：不可变性。</li></ul><ol><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ol><ul><li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li></ul><p><strong>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</strong></p><p>代码</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;       <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span>       <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;       s1 = <span class="hljs-string">&quot;hello&quot;</span>;       System.out.println(s1 == s2);<span class="hljs-comment">//判断地址：true  --&gt; false</span>       System.out.println(s1);<span class="hljs-comment">//</span>       System.out.println(s2);<span class="hljs-comment">//abc</span>   &#125;</code></pre><p>字节码指令</p><ul><li>取字符串 “abc” 时，使用的是同一个符号引用：#2</li><li>取字符串 “hello” 时，使用的是另一个符号引用：#3</li></ul><p><strong>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;       <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;       <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;       s2 += <span class="hljs-string">&quot;def&quot;</span>;       System.out.println(s2);<span class="hljs-comment">//abcdef</span>       System.out.println(s1);<span class="hljs-comment">//abc</span>   &#125;</code></pre><p><strong>当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>);    System.out.println(s1);<span class="hljs-comment">//abc</span>    System.out.println(s2);<span class="hljs-comment">//mbc</span>&#125;</code></pre><p><strong>一道笔试题</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExer</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;good&quot;</span>);    <span class="hljs-type">char</span>[] ch = &#123;<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>&#125;;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(String str, <span class="hljs-type">char</span> ch[])</span> &#123;        str = <span class="hljs-string">&quot;test ok&quot;</span>;        ch[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">StringExer</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringExer</span>();        ex.change(ex.str, ex.ch);        System.out.println(ex.str);<span class="hljs-comment">//good</span>        System.out.println(ex.ch);<span class="hljs-comment">//best</span>    &#125;&#125;</code></pre><p>str 的内容并没有变：“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容</p><p>没有返回值 即成员变量中的String的引用内容没有改变</p><p>java方法中的参数传递只有值传递</p><ul><li><strong>java没有引用传递，值传递复制的是堆地址，是拷贝了一个副本。</strong>  java值传递的是堆空间中存储的数值 对于基本类型来说堆空间存储的是数据值本身，将数据值本身拷贝进行传递   对于非基本类型参数来说 堆空间内存储的数据是应用地址，将地址进行拷贝传递。</li></ul><blockquote><ul><li>值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li><li>引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li></ul></blockquote><h3 id="String-的底层结构"><a href="#String-的底层结构" class="headerlink" title="String 的底层结构"></a>String 的底层结构</h3><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p><ol><li>String的String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。</li><li>使用-XX:StringTablesize可设置StringTable的长度</li><li>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求</li><li>在JDK7中，StringTable的长度默认值是60013，StringTablesize设置没有要求</li><li>在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009</li></ol><img src="/chapter_009/0001.png"><img src="/chapter_009/0002.png"><p><strong>测试不同 StringTable 长度下，程序的性能</strong></p><p>代码</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 产生10万个长度不超过10的字符串，包含a-z,A-Z</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenerateString</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;words.txt&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;            <span class="hljs-comment">//1 - 10</span>           <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random() * (<span class="hljs-number">10</span> - <span class="hljs-number">1</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);            fw.write(getString(length) + <span class="hljs-string">&quot;\n&quot;</span>);        &#125;        fw.close();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getString</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span>&#123;        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;            <span class="hljs-comment">//65 - 90, 97-122</span>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random() * (<span class="hljs-number">90</span> - <span class="hljs-number">65</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">65</span>) + (<span class="hljs-type">int</span>)(Math.random() * <span class="hljs-number">2</span>) * <span class="hljs-number">32</span>;            str += (<span class="hljs-type">char</span>)num;        &#125;        <span class="hljs-keyword">return</span> str;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest2</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;words.txt&quot;</span>));            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();            String data;            <span class="hljs-keyword">while</span>((data = br.readLine()) != <span class="hljs-literal">null</span>)&#123;                data.intern(); <span class="hljs-comment">//如果字符串常量池中没有对应data的字符串的话，则在常量池中生成</span>            &#125;            <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();            System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="hljs-comment">//1009:143ms  100009:47ms</span>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span>(br != <span class="hljs-literal">null</span>)&#123;                <span class="hljs-keyword">try</span> &#123;                    br.close();                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><ul><li><p>-XX:StringTableSize&#x3D;1009 ：程序耗时 143ms</p></li><li><p>-XX:StringTableSize&#x3D;100009 ：程序耗时 47ms</p></li></ul><h2 id="String-的内存分配"><a href="#String-的内存分配" class="headerlink" title="String 的内存分配"></a>String 的内存分配</h2><ol><li><p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p></li><li><p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p><ul><li><p>直接使用双引号声明出来的String对象会直接存储在常量池中。比如：<code>String info=&quot;atguigu.com&quot;;</code></p></li><li><p>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈</p></li></ul></li><li><p>Java 6及以前，字符串常量池存放在永久代</p></li><li><p>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p><ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。</li></ul></li><li><p>Java8元空间，字符串常量在堆</p></li></ol><img src="/chapter_009/0003.png"><img src="/chapter_009/0004.png"><h3 id="StringTable-为什么要调整？"><a href="#StringTable-为什么要调整？" class="headerlink" title="StringTable 为什么要调整？"></a>StringTable 为什么要调整？</h3><blockquote><p><strong>官方文档</strong>:<a href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes</a></p></blockquote><ol><li>为什么要调整位置？<ul><li>永久代的默认空间大小比较小</li><li>永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space</li><li>堆中空间足够大，字符串可被及时回收</li></ul></li><li>在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。</li><li>此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</li></ol><p><strong>代码示例</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * jdk6中：</span><span class="hljs-comment"> * -XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * jdk8中：</span><span class="hljs-comment"> * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest3</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//使用Set保持着常量池引用，避免full gc回收常量池行为</span>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();        <span class="hljs-comment">//在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。</span>        <span class="hljs-type">short</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            set.add(String.valueOf(i++).intern());        &#125;    &#125;&#125;</code></pre><p>输出结果：我真没骗你，字符串真的在堆中（JDK8）</p><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap spaceat java.util.HashMap.resize(HashMap.java:<span class="hljs-number">703</span>)at java.util.HashMap.putVal(HashMap.java:<span class="hljs-number">662</span>)at java.util.HashMap.put(HashMap.java:<span class="hljs-number">611</span>)at java.util.HashSet.add(HashSet.java:<span class="hljs-number">219</span>)at com.atguigu.java.StringTest3.main(StringTest3.java:<span class="hljs-number">22</span>)Process finished with exit code <span class="hljs-number">1</span></code></pre><h2 id="String-的基本操作"><a href="#String-的基本操作" class="headerlink" title="String 的基本操作"></a>String 的基本操作</h2><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p><h3 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest4</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println();<span class="hljs-comment">//2293</span>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//2294</span>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);        System.out.println(<span class="hljs-string">&quot;3&quot;</span>);        System.out.println(<span class="hljs-string">&quot;4&quot;</span>);        System.out.println(<span class="hljs-string">&quot;5&quot;</span>);        System.out.println(<span class="hljs-string">&quot;6&quot;</span>);        System.out.println(<span class="hljs-string">&quot;7&quot;</span>);        System.out.println(<span class="hljs-string">&quot;8&quot;</span>);        System.out.println(<span class="hljs-string">&quot;9&quot;</span>);        System.out.println(<span class="hljs-string">&quot;10&quot;</span>);<span class="hljs-comment">//2303</span>        <span class="hljs-comment">//如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载</span>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//2304</span>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<span class="hljs-comment">//2304</span>        System.out.println(<span class="hljs-string">&quot;3&quot;</span>);        System.out.println(<span class="hljs-string">&quot;4&quot;</span>);        System.out.println(<span class="hljs-string">&quot;5&quot;</span>);        System.out.println(<span class="hljs-string">&quot;6&quot;</span>);        System.out.println(<span class="hljs-string">&quot;7&quot;</span>);        System.out.println(<span class="hljs-string">&quot;8&quot;</span>);        System.out.println(<span class="hljs-string">&quot;9&quot;</span>);        System.out.println(<span class="hljs-string">&quot;10&quot;</span>);<span class="hljs-comment">//2304</span>    &#125;&#125;</code></pre><p>分析字符串常量池的变化</p><p>1、程序启动时已经加载了 2293 个字符串常量</p><img src="/chapter_009/0005.png"><p>2、加载了一个换行符（println），所以多了一个</p><img src="/chapter_009/0006.jpg"><p>3、加载了字符串常量 “1”~“9”</p><img src="/chapter_009/0007.jpg"><p>4、加载字符串常量 “10”</p><img src="/chapter_009/0008.jpg"><p>5、之后的字符串”1” 到 “10”不会再次加载</p><img src="/chapter_009/0009.png"><h3 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h3><pre><code class="hljs java"><span class="hljs-comment">//官方示例代码</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memory</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<span class="hljs-comment">//line 1</span>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//line 2</span>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//line 3</span>        <span class="hljs-type">Memory</span> <span class="hljs-variable">mem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memory</span>();<span class="hljs-comment">//line 4</span>        mem.foo(obj);<span class="hljs-comment">//line 5</span>    &#125;<span class="hljs-comment">//line 9</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(Object param)</span> &#123;<span class="hljs-comment">//line 6</span>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> param.toString();<span class="hljs-comment">//line 7</span>        System.out.println(str);    &#125;<span class="hljs-comment">//line 8</span>&#125;</code></pre><p>分析运行时内存（foo() 方法是实例方法，其实图中少了一个 this 局部变量）</p><img src="/chapter_009/0010.png"><h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><h3 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h3><ol><li><p>常量与常量的拼接结果在常量池，原理是前期编译期优化</p></li><li><p>常量池中不会存在相同内容的变量</p></li><li><p>拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</p><blockquote><p>则相当于在堆空间中new String()</p></blockquote></li><li><p>如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为：</p><ul><li>如果存在，则返回字符串在常量池中的地址</li><li>如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址</li></ul></li></ol><p><strong>1、常量与常量的拼接结果在常量池，原理是编译期优化</strong></p><p>代码</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>;<span class="hljs-comment">//编译期优化：等同于&quot;abc&quot;</span>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>; <span class="hljs-comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">         * 最终.java编译成.class,再执行.class</span><span class="hljs-comment">         * String s1 = &quot;abc&quot;;</span><span class="hljs-comment">         * String s2 = &quot;abc&quot;</span><span class="hljs-comment">         */</span>        System.out.println(s1 == s2); <span class="hljs-comment">//true</span>        System.out.println(s1.equals(s2)); <span class="hljs-comment">//true</span>    &#125;</code></pre><p>从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”</p><pre><code class="hljs java"><span class="hljs-number">0</span> ldc #<span class="hljs-number">2</span> &lt;abc&gt;<span class="hljs-number">2</span> astore_1<span class="hljs-number">3</span> ldc #<span class="hljs-number">2</span> &lt;abc&gt;<span class="hljs-number">5</span> astore_2<span class="hljs-number">6</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">9</span> aload_1<span class="hljs-number">10</span> aload_2<span class="hljs-number">11</span> if_acmpne <span class="hljs-number">18</span> (+<span class="hljs-number">7</span>)<span class="hljs-number">14</span> iconst_1<span class="hljs-number">15</span> goto <span class="hljs-number">19</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">18</span> iconst_0<span class="hljs-number">19</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">22</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">25</span> aload_1<span class="hljs-number">26</span> aload_2<span class="hljs-number">27</span> invokevirtual #<span class="hljs-number">5</span> &lt;java/lang/String.equals&gt;<span class="hljs-number">30</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">33</span> <span class="hljs-keyword">return</span></code></pre><p>IDEA 反编译 class 文件后，来看这个问题</p><img src="/chapter_009/0011.png"><p><strong>2、拼接前后，只要其中有一个是变量，结果就在堆中</strong></p><p>在字符串常量池中没有生成对应的字符串（拼接后的字符串）</p><p><strong>调用 intern() 方法，则主动将字符串对象存入字符串常量池中，并将其地址返回</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEE&quot;</span>;        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hadoop&quot;</span>;        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEEhadoop&quot;</span>;        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEE&quot;</span> + <span class="hljs-string">&quot;hadoop&quot;</span>;<span class="hljs-comment">//编译期优化</span>        <span class="hljs-comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span>        <span class="hljs-comment">//在如果拼接符号的前后出现了变量，会在堆空间中创建StringBuilder(),在拼接完成之后，回调用toString()toString底层会调用 new String</span>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> s1 + <span class="hljs-string">&quot;hadoop&quot;</span>;        <span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEE&quot;</span> + s2;        <span class="hljs-type">String</span> <span class="hljs-variable">s7</span> <span class="hljs-operator">=</span> s1 + s2;        System.out.println(s3 == s4);<span class="hljs-comment">//true</span>        System.out.println(s3 == s5);<span class="hljs-comment">//false</span>        System.out.println(s3 == s6);<span class="hljs-comment">//false</span>        System.out.println(s3 == s7);<span class="hljs-comment">//false</span>        System.out.println(s5 == s6);<span class="hljs-comment">//false</span>        System.out.println(s5 == s7);<span class="hljs-comment">//false</span>        System.out.println(s6 == s7);<span class="hljs-comment">//false</span>        <span class="hljs-comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span>        <span class="hljs-comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回此对象的地址。</span>        <span class="hljs-type">String</span> <span class="hljs-variable">s8</span> <span class="hljs-operator">=</span> s6.intern();        System.out.println(s3 == s8);<span class="hljs-comment">//true</span>    &#125;</code></pre><p>从字节码角度来看：拼接前后有变量，都会使用到 StringBuilder 类</p><pre><code class="hljs java"><span class="hljs-number">0</span> ldc #<span class="hljs-number">6</span> &lt;javaEE&gt;<span class="hljs-number">2</span> astore_1<span class="hljs-number">3</span> ldc #<span class="hljs-number">7</span> &lt;hadoop&gt;<span class="hljs-number">5</span> astore_2<span class="hljs-number">6</span> ldc #<span class="hljs-number">8</span> &lt;javaEEhadoop&gt;<span class="hljs-number">8</span> astore_3<span class="hljs-number">9</span> ldc #<span class="hljs-number">8</span> &lt;javaEEhadoop&gt;<span class="hljs-number">11</span> astore <span class="hljs-number">4</span><span class="hljs-number">13</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder&gt;<span class="hljs-number">16</span> dup<span class="hljs-number">17</span> invokespecial #<span class="hljs-number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;<span class="hljs-number">20</span> aload_1<span class="hljs-number">21</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<span class="hljs-number">24</span> ldc #<span class="hljs-number">7</span> &lt;hadoop&gt;<span class="hljs-number">26</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<span class="hljs-number">29</span> invokevirtual #<span class="hljs-number">12</span> &lt;java/lang/StringBuilder.toString&gt;<span class="hljs-number">32</span> astore <span class="hljs-number">5</span><span class="hljs-number">34</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder&gt;<span class="hljs-number">37</span> dup<span class="hljs-number">38</span> invokespecial #<span class="hljs-number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;<span class="hljs-number">41</span> ldc #<span class="hljs-number">6</span> &lt;javaEE&gt;<span class="hljs-number">43</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<span class="hljs-number">46</span> aload_2<span class="hljs-number">47</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<span class="hljs-number">50</span> invokevirtual #<span class="hljs-number">12</span> &lt;java/lang/StringBuilder.toString&gt;<span class="hljs-number">53</span> astore <span class="hljs-number">6</span><span class="hljs-number">55</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder&gt;<span class="hljs-number">58</span> dup<span class="hljs-number">59</span> invokespecial #<span class="hljs-number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;<span class="hljs-number">62</span> aload_1<span class="hljs-number">63</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<span class="hljs-number">66</span> aload_2<span class="hljs-number">67</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<span class="hljs-number">70</span> invokevirtual #<span class="hljs-number">12</span> &lt;java/lang/StringBuilder.toString&gt;<span class="hljs-number">73</span> astore <span class="hljs-number">7</span><span class="hljs-number">75</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">78</span> aload_3<span class="hljs-number">79</span> aload <span class="hljs-number">4</span><span class="hljs-number">81</span> if_acmpne <span class="hljs-number">88</span> (+<span class="hljs-number">7</span>)<span class="hljs-number">84</span> iconst_1<span class="hljs-number">85</span> goto <span class="hljs-number">89</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">88</span> iconst_0<span class="hljs-number">89</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">92</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">95</span> aload_3<span class="hljs-number">96</span> aload <span class="hljs-number">5</span><span class="hljs-number">98</span> if_acmpne <span class="hljs-number">105</span> (+<span class="hljs-number">7</span>)<span class="hljs-number">101</span> iconst_1<span class="hljs-number">102</span> goto <span class="hljs-number">106</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">105</span> iconst_0<span class="hljs-number">106</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">109</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">112</span> aload_3<span class="hljs-number">113</span> aload <span class="hljs-number">6</span><span class="hljs-number">115</span> if_acmpne <span class="hljs-number">122</span> (+<span class="hljs-number">7</span>)<span class="hljs-number">118</span> iconst_1<span class="hljs-number">119</span> goto <span class="hljs-number">123</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">122</span> iconst_0<span class="hljs-number">123</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">126</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">129</span> aload_3<span class="hljs-number">130</span> aload <span class="hljs-number">7</span><span class="hljs-number">132</span> if_acmpne <span class="hljs-number">139</span> (+<span class="hljs-number">7</span>)<span class="hljs-number">135</span> iconst_1<span class="hljs-number">136</span> goto <span class="hljs-number">140</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">139</span> iconst_0<span class="hljs-number">140</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">143</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">146</span> aload <span class="hljs-number">5</span><span class="hljs-number">148</span> aload <span class="hljs-number">6</span><span class="hljs-number">150</span> if_acmpne <span class="hljs-number">157</span> (+<span class="hljs-number">7</span>)<span class="hljs-number">153</span> iconst_1<span class="hljs-number">154</span> goto <span class="hljs-number">158</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">157</span> iconst_0<span class="hljs-number">158</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">161</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">164</span> aload <span class="hljs-number">5</span><span class="hljs-number">166</span> aload <span class="hljs-number">7</span><span class="hljs-number">168</span> if_acmpne <span class="hljs-number">175</span> (+<span class="hljs-number">7</span>)<span class="hljs-number">171</span> iconst_1<span class="hljs-number">172</span> goto <span class="hljs-number">176</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">175</span> iconst_0<span class="hljs-number">176</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">179</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">182</span> aload <span class="hljs-number">6</span><span class="hljs-number">184</span> aload <span class="hljs-number">7</span><span class="hljs-number">186</span> if_acmpne <span class="hljs-number">193</span> (+<span class="hljs-number">7</span>)<span class="hljs-number">189</span> iconst_1<span class="hljs-number">190</span> goto <span class="hljs-number">194</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">193</span> iconst_0<span class="hljs-number">194</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">197</span> aload <span class="hljs-number">6</span><span class="hljs-number">199</span> invokevirtual #<span class="hljs-number">13</span> &lt;java/lang/String.intern&gt;<span class="hljs-number">202</span> astore <span class="hljs-number">8</span><span class="hljs-number">204</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">207</span> aload_3<span class="hljs-number">208</span> aload <span class="hljs-number">8</span><span class="hljs-number">210</span> if_acmpne <span class="hljs-number">217</span> (+<span class="hljs-number">7</span>)<span class="hljs-number">213</span> iconst_1<span class="hljs-number">214</span> goto <span class="hljs-number">218</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">217</span> iconst_0<span class="hljs-number">218</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">221</span> <span class="hljs-keyword">return</span></code></pre><h3 id="字符串拼接的底层细节"><a href="#字符串拼接的底层细节" class="headerlink" title="字符串拼接的底层细节"></a>字符串拼接的底层细节</h3><p><strong>举例1</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;    <span class="hljs-comment">/*</span><span class="hljs-comment">    如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span><span class="hljs-comment">    ① StringBuilder s = new StringBuilder();</span><span class="hljs-comment">    ② s.append(&quot;a&quot;)</span><span class="hljs-comment">    ③ s.append(&quot;b&quot;)</span><span class="hljs-comment">    ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)，但不等价</span><span class="hljs-comment"></span><span class="hljs-comment">    补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span><span class="hljs-comment">     */</span>    <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;<span class="hljs-comment">//</span>    System.out.println(s3 == s4);<span class="hljs-comment">//false</span>&#125;</code></pre><p>字节码指令</p><pre><code class="hljs java"><span class="hljs-number">0</span> ldc #<span class="hljs-number">14</span> &lt;a&gt;<span class="hljs-number">2</span> astore_1<span class="hljs-number">3</span> ldc #<span class="hljs-number">15</span> &lt;b&gt;<span class="hljs-number">5</span> astore_2<span class="hljs-number">6</span> ldc #<span class="hljs-number">16</span> &lt;ab&gt;<span class="hljs-number">8</span> astore_3<span class="hljs-number">9</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder&gt;<span class="hljs-number">12</span> dup<span class="hljs-number">13</span> invokespecial #<span class="hljs-number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;<span class="hljs-number">16</span> aload_1<span class="hljs-number">17</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<span class="hljs-number">20</span> aload_2<span class="hljs-number">21</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<span class="hljs-number">24</span> invokevirtual #<span class="hljs-number">12</span> &lt;java/lang/StringBuilder.toString&gt;<span class="hljs-number">27</span> astore <span class="hljs-number">4</span><span class="hljs-number">29</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">32</span> aload_3<span class="hljs-number">33</span> aload <span class="hljs-number">4</span><span class="hljs-number">35</span> if_acmpne <span class="hljs-number">42</span> (+<span class="hljs-number">7</span>)<span class="hljs-number">38</span> iconst_1<span class="hljs-number">39</span> goto <span class="hljs-number">43</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">42</span> iconst_0<span class="hljs-number">43</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">46</span> <span class="hljs-keyword">return</span></code></pre><p><strong>举例2</strong></p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">    1. 字符串拼接操作不一定使用的是StringBuilder!</span><span class="hljs-comment">       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span><span class="hljs-comment">    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span><span class="hljs-comment">    </span><span class="hljs-comment">    final 在 Java 中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作 final，你将不能改变这个引用了  在java中 方法变量使用了fianl 变量就不能改变了 变成了常量</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;        System.out.println(s3 == s4);<span class="hljs-comment">//true</span>    &#125;</code></pre><p>从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab”</p><pre><code class="hljs java"><span class="hljs-number">0</span> ldc #<span class="hljs-number">14</span> &lt;a&gt;<span class="hljs-number">2</span> astore_1<span class="hljs-number">3</span> ldc #<span class="hljs-number">15</span> &lt;b&gt;<span class="hljs-number">5</span> astore_2<span class="hljs-number">6</span> ldc #<span class="hljs-number">16</span> &lt;ab&gt;<span class="hljs-number">8</span> astore_3<span class="hljs-number">9</span> ldc #<span class="hljs-number">16</span> &lt;ab&gt;<span class="hljs-number">11</span> astore <span class="hljs-number">4</span><span class="hljs-number">13</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">16</span> aload_3<span class="hljs-number">17</span> aload <span class="hljs-number">4</span><span class="hljs-number">19</span> if_acmpne <span class="hljs-number">26</span> (+<span class="hljs-number">7</span>)<span class="hljs-number">22</span> iconst_1<span class="hljs-number">23</span> goto <span class="hljs-number">27</span> (+<span class="hljs-number">4</span>)<span class="hljs-number">26</span> iconst_0<span class="hljs-number">27</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">30</span> <span class="hljs-keyword">return</span></code></pre><p><strong>拼接操作与 append 操作的效率对比</strong></p><pre><code class="hljs java">    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<span class="hljs-comment">//        method1(100000);//4014</span>        method2(<span class="hljs-number">100000</span>);<span class="hljs-comment">//7</span>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start));    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> highLevel)</span>&#123;        <span class="hljs-type">String</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; highLevel;i++)&#123;            src = src + <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-comment">//每次循环都会创建一个StringBuilder、String</span>        &#125;<span class="hljs-comment">//        System.out.println(src);</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(<span class="hljs-type">int</span> highLevel)</span>&#123;        <span class="hljs-comment">//只需要创建一个StringBuilder</span>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; highLevel; i++) &#123;            src.append(<span class="hljs-string">&quot;a&quot;</span>);        &#125;<span class="hljs-comment">//        System.out.println(src);</span>    &#125;</code></pre><ol><li><p>体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</p></li><li><p>原因：</p><ol><li>StringBuilder的append()的方式：<ul><li>自始至终中只创建过一个StringBuilder的对象</li></ul></li><li>使用String的字符串拼接方式：<ul><li>创建过多个StringBuilder和String（调的toString方法）的对象，内存占用更大；</li><li>如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。</li></ul></li></ol></li><li><p>改进的空间：</p><ul><li>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化：</li><li><code>StringBuilder s = new StringBuilder(highLevel); //new char[highLevel]</code></li><li>这样可以避免频繁扩容</li></ul></li></ol><h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern() 的使用"></a>intern() 的使用</h2><h3 id="intern-方法的说明"><a href="#intern-方法的说明" class="headerlink" title="intern() 方法的说明"></a>intern() 方法的说明</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title function_">intern</span><span class="hljs-params">()</span>;</code></pre><ol><li><p><strong>intern是一个native方法，调用的是底层C的方法</strong></p></li><li><p>字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译）</p></li><li><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：</p><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">myInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">string</span>(<span class="hljs-string">&quot;I love atguigu&quot;</span>).intern();</code></pre></li><li><p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p></li></ol>  <pre><code class="hljs java">(<span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;b&quot;</span>+<span class="hljs-string">&quot;c&quot;</span>).intern()==<span class="hljs-string">&quot;abc&quot;</span></code></pre><ol start="5"><li>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</li></ol><blockquote><p>返回字符串对象的规范表示形式。字符串池（最初为空）由类 String 私下维护。调用 intern 方法时，如果池已包含与 equals（Object） 方法确定的此 String 对象相等的字符串，则返回池中的字符串。否则，此 String 对象将添加到池中，并返回对此 String 对象的引用。因此，对于任何两个字符串 s 和 t，s.intern（） &#x3D;&#x3D; t.intern（） 为真当且仅当 s.equals（t） 为真。所有文本字符串和字符串值常量表达式都驻留。字符串文本在 Java™ 语言规范的第 3.10.5 节中定义。返回值：与此字符串具有相同内容但保证来自唯一字符串池的字符串</p></blockquote><h3 id="new-String-的说明"><a href="#new-String-的说明" class="headerlink" title="new String() 的说明"></a>new String() 的说明</h3><h4 id="new-String-“ab”-会创建几个对象？"><a href="#new-String-“ab”-会创建几个对象？" class="headerlink" title="new String(“ab”)会创建几个对象？"></a>new String(“ab”)会创建几个对象？</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 题目：</span><span class="hljs-comment"> * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。</span><span class="hljs-comment"> *     一个对象是：new关键字在堆空间创建的</span><span class="hljs-comment"> *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。 字节码指令：ldc</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringNewTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);    &#125;&#125;</code></pre><p>字节码指令</p><pre><code class="hljs java"><span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java/lang/String&gt;<span class="hljs-number">3</span> dup<span class="hljs-number">4</span> ldc #<span class="hljs-number">3</span> &lt;ab&gt;<span class="hljs-number">6</span> invokespecial #<span class="hljs-number">4</span> &lt;java/lang/String.&lt;init&gt;&gt;<span class="hljs-number">9</span> astore_1<span class="hljs-number">10</span> <span class="hljs-keyword">return</span></code></pre><p><code>0 new #2 &lt;java/lang/String&gt;</code>：在堆中创建了一个 String 对象   代码中返回的是 堆空间中的1</p><p><code>4 ldc #3 &lt;ab&gt;</code> ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）</p><h4 id="new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象？"></a>new String(“a”) + new String(“b”) 会创建几个对象？</h4><p>代码</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 思考：</span><span class="hljs-comment"> * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？</span><span class="hljs-comment"> *  对象1：new StringBuilder()</span><span class="hljs-comment"> *  对象2： new String(&quot;a&quot;)</span><span class="hljs-comment"> *  对象3： 常量池中的&quot;a&quot;</span><span class="hljs-comment"> *  对象4： new String(&quot;b&quot;)</span><span class="hljs-comment"> *  对象5： 常量池中的&quot;b&quot;</span><span class="hljs-comment"> *  对象6：tostring里面的new String()</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  深入剖析： StringBuilder的toString():</span><span class="hljs-comment"> *      对象6 ：new String(&quot;ab&quot;)</span><span class="hljs-comment"> *       强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot;</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringNewTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);    &#125;&#125;</code></pre><p>字节码指令</p><pre><code class="hljs java"><span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java/lang/StringBuilder&gt;<span class="hljs-number">3</span> dup<span class="hljs-number">4</span> invokespecial #<span class="hljs-number">3</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;<span class="hljs-number">7</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java/lang/String&gt;<span class="hljs-number">10</span> dup<span class="hljs-number">11</span> ldc #<span class="hljs-number">5</span> &lt;a&gt;<span class="hljs-number">13</span> invokespecial #<span class="hljs-number">6</span> &lt;java/lang/String.&lt;init&gt;&gt;<span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append&gt;<span class="hljs-number">19</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java/lang/String&gt;<span class="hljs-number">22</span> dup<span class="hljs-number">23</span> ldc #<span class="hljs-number">8</span> &lt;b&gt;<span class="hljs-number">25</span> invokespecial #<span class="hljs-number">6</span> &lt;java/lang/String.&lt;init&gt;&gt;<span class="hljs-number">28</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append&gt;<span class="hljs-number">31</span> invokevirtual #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder.toString&gt;<span class="hljs-number">34</span> astore_1<span class="hljs-number">35</span> <span class="hljs-keyword">return</span></code></pre><p><strong>答案是4个或5个或6个</strong></p><p>字节码指令分析：</p><ol><li><code>0 new #2 &lt;java/lang/StringBuilder&gt;</code> ：拼接字符串会创建一个 StringBuilder 对象</li><li><code>7 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“a”)</li><li><code>11 ldc #5 &lt;a&gt;</code> ：在字符串常量池中放入 “a”（如果之前字符串常量池中没有 “a” 的话）</li><li><code>19 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“b”)</li><li><code>23 ldc #8 &lt;b&gt;</code> ：在字符串常量池中放入 “b”（如果之前字符串常量池中没有 “b” 的话）</li><li><code>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</code> ：调用 StringBuilder 的 toString() 方法，会生成一个 String 对象</li></ol><img src="/chapter_009/0012.png"><h3 id="有点难的面试题"><a href="#有点难的面试题" class="headerlink" title="有点难的面试题"></a>有点难的面试题</h3><blockquote><p><strong>有点难的面试题</strong></p></blockquote><pre><code class="hljs java">** * 如何保证变量s指向的是字符串常量池中的数据呢？ * 有两种方式： * 方式一： <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;shkstart&quot;</span>;<span class="hljs-comment">//字面量定义的方式</span> * 方式二： 调用intern() *         <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;shkstart&quot;</span>).intern(); *         <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;shkstart&quot;</span>).toString().intern(); * */<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringIntern</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>);        s.intern();<span class="hljs-comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;  所以没有生成 指向的就是字符串常量</span>        <span class="hljs-comment">//如果你写的是 string s = new string(&quot;1&quot;).intern()  那么就是ture了</span>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;        System.out.println(s == s2);<span class="hljs-comment">//jdk6：false   jdk7/8：false</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">        s指向的字符串对象</span><span class="hljs-comment">        s2 指向的字符串常量 所以为true</span><span class="hljs-comment">        </span><span class="hljs-comment">        */</span>                <span class="hljs-comment">/*</span><span class="hljs-comment">         1、s3变量记录的地址为：new String(&quot;11&quot;)</span><span class="hljs-comment">         2、经过上面的分析，我们已经知道执行完pos_1的代码，在堆中有了一个new String(&quot;11&quot;)</span><span class="hljs-comment">         这样的String对象。但是在字符串常量池中没有&quot;11&quot; </span><span class="hljs-comment">         注意这边需要注意下，在正常的new String中是创建两个对象 一个是newString 一个是 lbc 创建在字符串常量池 在toString中没有第二个所以在字符串常量池中没有对应的11</span><span class="hljs-comment">         3、接着执行s3.intern()，在字符串常量池中生成&quot;11&quot;</span><span class="hljs-comment">           3-1、在JDK6的版本中，字符串常量池还在永久代，所以直接在永久代生成&quot;11&quot;,也就有了新的地址</span><span class="hljs-comment">           3-2、而在JDK7的后续版本中，字符串常量池被移动到了 堆中，此时堆里已经有new String（&quot;11&quot;）了</span><span class="hljs-comment">           出于节省空间的目的，直接将堆中的那个字符串的引用地址储存在字符串常量池中。没错，字符串常量池</span><span class="hljs-comment">           中存的是new String（&quot;11&quot;）在堆中的地址</span><span class="hljs-comment">         4、所以在JDK7后续版本中，s3和s4指向的完全是同一个地址。</span><span class="hljs-comment">         */</span>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//pos_1 注意此时字符串常量中只有1 没有11 11存在在s3对象中</span>    s3.intern(); <span class="hljs-comment">// 字符串常量中不存在11 但在 s3对象中存在 所以指向s3</span>                <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11&quot;</span>;<span class="hljs-comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中指向s3的地址</span>        System.out.println(s3 == s4);<span class="hljs-comment">//jdk6：false  jdk7/8：true</span>    &#125;&#125;</code></pre><p>解释的已经比较清楚了，下面看一下内存图</p><p><strong>内存分析</strong></p><p>JDK6 ：正常眼光判断即可</p><ul><li>new String() 即在堆中</li><li>str.intern() 则把字符串放入常量池中</li></ul><img src="/chapter_009/0013.png"><p>JDK7及后续版本，<strong>注意大坑</strong></p><img src="/chapter_009/0014.png"><h4 id="面试题的拓展"><a href="#面试题的拓展" class="headerlink" title="面试题的拓展"></a>面试题的拓展</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * StringIntern.java中练习的拓展：</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringIntern1</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//执行完下一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//new String(&quot;11&quot;)</span>        <span class="hljs-comment">//在字符串常量池中生成对象&quot;11&quot;，代码顺序换一下，实打实的在字符串常量池里有一个&quot;11&quot;对象</span>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11&quot;</span>;          <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> s3.intern();        <span class="hljs-comment">// s3 是堆中的 &quot;ab&quot; ，s4 是字符串常量池中的 &quot;ab&quot;</span>        System.out.println(s3 == s4);<span class="hljs-comment">//false</span>        <span class="hljs-comment">// s5 是从字符串常量池中取回来的引用，当然和 s4 相等</span>        System.out.println(s5 == s4);<span class="hljs-comment">//true</span>    &#125;&#125;</code></pre><p><strong>intern()使用总结：</strong></p><p> jdk6:</p><ul><li>如果字符串常量池中有，并不会将其放入，会返回已有的字符串的地址</li><li>如果没有 就会将该对象复制一份 放入串池中，返回串池当中的对象引用</li></ul><p>jdk7开始</p><ul><li>如果串池中有，不会将其放入 会返回已有的字符串地址</li><li>如果没有，会将该对象的<strong>引用</strong>放入串池当中 并返回串池当中的引用</li></ul><h3 id="intern-方法的练习"><a href="#intern-方法的练习" class="headerlink" title="intern() 方法的练习"></a>intern() 方法的练习</h3><p><strong>练习 1</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExer1</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span><span class="hljs-comment">/*</span><span class="hljs-comment">1、jdk6中：在字符串常量池（此时在永久代）中创建一个字符串&quot;ab&quot;</span><span class="hljs-comment">        2、jdk8中：字符串常量池（此时在堆中）中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，  将此引用返回</span><span class="hljs-comment">        3、详解看上面</span><span class="hljs-comment">*/</span>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.intern();          System.out.println(s2 == <span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//jdk6:true  jdk8:true</span>        System.out.println(s == <span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//jdk6:false  jdk8:true   在jdk6中 s在堆中 ab(s2)在永久代中所以不相同  在jdk7以上 s在堆中  ab在堆中 同时 在串池当中 已经将引用指向了s对象的地址</span>                &#125;&#125;</code></pre><p><strong>JDK6</strong></p><p><img src="/chapter_009/0015.png" alt="image-20201116113423492"></p><p><strong>JDK7&#x2F;8</strong></p><img src="/chapter_009/0016.png"><p><strong>练习2</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExer2</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span>        s1.intern();        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;        System.out.println(s1 == s2);<span class="hljs-comment">//false</span>    &#125;&#125;</code></pre><p><strong>验证</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExer2</span> &#123;    <span class="hljs-comment">// 对象内存地址可以使用System.identityHashCode(object)方法获取</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">//执行完以后，不会在字符串常量池中会生成&quot;ab&quot;</span>        System.out.println(System.identityHashCode(s1));        s1.intern();        System.out.println(System.identityHashCode(s1));        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;        System.out.println(System.identityHashCode(s2));        System.out.println(s1 == s2); <span class="hljs-comment">// true</span>    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="hljs java"><span class="hljs-number">1836019240</span><span class="hljs-number">1836019240</span><span class="hljs-number">1836019240</span><span class="hljs-literal">true</span></code></pre><h3 id="intern-的效率测试（空间角度）"><a href="#intern-的效率测试（空间角度）" class="headerlink" title="intern() 的效率测试（空间角度）"></a>intern() 的效率测试（空间角度）</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 使用intern()测试执行效率：空间使用上</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringIntern2</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">10000</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[MAX_COUNT];    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        Integer[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_COUNT; i++) &#123;<span class="hljs-comment">//            arr[i] = new String(String.valueOf(data[i % data.length]));</span>            arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(String.valueOf(data[i % data.length])).intern();        &#125;        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start));        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.gc();    &#125;&#125;</code></pre><p>1、直接 new String ：由于每个 String 对象都是 new 出来的，所以程序需要维护大量存放在堆空间中的 String 实例，程序内存占用也会变高</p><pre><code class="hljs java">arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(String.valueOf(data[i % data.length]));</code></pre><img src="/chapter_009/0018.png"><img src="/chapter_009/0019.png"><p>2、使用 intern() 方法：由于数组中字符串的引用都指向字符串常量池中的字符串，所以程序需要维护的 String 对象更少，内存占用也更低</p><pre><code class="hljs java"><span class="hljs-comment">//调用了intern()方法使用了字符串常量池里的字符串，那么前面堆里的字符串便会被GC掉，这也是intern省内存的关键原因</span>arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(String.valueOf(data[i % data.length])).intern();</code></pre><img src="/chapter_009/0020.png" ><img src="/chapter_009/0021.png"><p><strong>结论</strong>：</p><ol><li>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省很大的内存空间。</li><li>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</li></ol><h2 id="StringTable-的垃圾回收"><a href="#StringTable-的垃圾回收" class="headerlink" title="StringTable 的垃圾回收"></a>StringTable 的垃圾回收</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * String的垃圾回收:</span><span class="hljs-comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringGCTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++) &#123;            String.valueOf(j).intern();        &#125;    &#125;&#125;</code></pre><p>输出结果：</p><ul><li>在 PSYoungGen 区发生了垃圾回收</li><li>Number of entries 和 Number of literals 明显没有 100000</li><li>以上两点均说明 StringTable 区发生了垃圾回收</li></ul><img src="/chapter_009/0022.jpg"><img src="/chapter_009/0023.jpg"/><h2 id="G1-中的-String-去重操作"><a href="#G1-中的-String-去重操作" class="headerlink" title="G1 中的 String 去重操作"></a>G1 中的 String 去重操作</h2><blockquote><p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/192">http://openjdk.java.net/jeps/192</a></p></blockquote><p>暂时了解一下，后面会详解垃圾回收器</p><p><strong>String去重操作的背景</strong></p><blockquote><p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的</p></blockquote><ol><li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul><li>堆存活数据集合里面String对象占了25%</li><li>堆存活数据集合里面重复的String对象有13.5%</li><li>String对象的平均长度是45</li></ul></li><li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：<code>str1.equals(str2)= true</code>。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li></ol><p><strong>String 去重的实现</strong></p><ol><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li><li>使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</li></ol><p><strong>命令行选项</strong></p><ol><li>UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。</li><li>PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息</li><li>stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;StringTable（字符串常量池）&quot;&gt;&lt;a href=&quot;#StringTable（字符串常量池）&quot; class=&quot;headerlink&quot; title=&quot;StringTable（字符串常量池）&quot;&gt;&lt;/a&gt;StringTable（字符串常量池）&lt;/h1&gt;&lt;p&gt;St</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>8.JVM系列-执行引擎</title>
    <link href="http://example.com/2023/04/09/8-JVM%E7%B3%BB%E5%88%97-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://example.com/2023/04/09/8-JVM%E7%B3%BB%E5%88%97-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</id>
    <published>2023-04-09T08:22:21.000Z</published>
    <updated>2024-03-12T09:37:26.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><p>执行引擎的作用是将二进制字节码编译成为本地机器呢能够执行的机器指令</p><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><img src="/chapter_008/0001.png"><h3 id="执行引擎概述-1"><a href="#执行引擎概述-1" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h3><ol><li>执行引擎是Java虚拟机核心的组成部分之一。</li><li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式</strong>。</li><li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li><li>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li></ol><img src="/chapter_008/0002.png"><p>执行引擎这里有两种行为：一种是解释执行，一种是编译执行（这里的是后端编译）。</p><blockquote><p>这里就是所谓java的半编译半解释语言 </p></blockquote><h3 id="执行引擎工作过程"><a href="#执行引擎工作过程" class="headerlink" title="执行引擎工作过程"></a>执行引擎工作过程</h3><blockquote><p><strong>执行引擎工作过程</strong></p></blockquote><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li><li>从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行、即时编译的等效过程，输出的是执行过程。</li></ol><img src="/chapter_008/0003.png"><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><h3 id="解释执行和即时编译"><a href="#解释执行和即时编译" class="headerlink" title="解释执行和即时编译"></a>解释执行和即时编译</h3><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤：</p><ol><li><p>前面橙色部分是编译生成生成字节码文件的过程（javac编译器来完成，也就是前端编译器），和JVM没有关系。</p></li><li><p>后面绿色（解释执行）和蓝色（即时编译）才是JVM需要考虑的过程</p></li></ol><img src="/chapter_008/0004.png">    <ol start="3"><li><p>javac编译器（前端编译器）流程图如下所示：</p><img src="/chapter_008/0005.png"></li><li><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示</p><img src="/chapter_008/0006.png"></li></ol><h3 id="什么是解释器？什么是JIT编译器？"><a href="#什么是解释器？什么是JIT编译器？" class="headerlink" title="什么是解释器？什么是JIT编译器？"></a>什么是解释器？什么是JIT编译器？</h3><blockquote><ul><li>解释器：直接执行用编程语言编写的指令的程序</li><li>编译器：把源代码转换成（翻译）低级语言的程序</li></ul></blockquote><ol><li>解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用<strong>逐行</strong>解释的方式<strong>执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码<strong>一次性直接</strong>编译成和本地机器平台相关的机器语言，<strong>但并不是马上执行</strong>。</li></ol><p><strong>为什么Java是半编译半解释型语言？</strong></p><ol><li>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</li><li>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</li><li>JIT编译器将字节码翻译成本地代码后，就可以做一个缓存操作，存储在方法区的JIT 代码缓存中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。</li></ol><p><strong>用图总结一下</strong></p><img src="/chapter_008/0007.png"><h2 id="机器码-指令-汇编语言"><a href="#机器码-指令-汇编语言" class="headerlink" title="机器码 指令 汇编语言"></a>机器码 指令 汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><ol><li>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</li><li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li><li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li><li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li></ol><h3 id="指令和指令集"><a href="#指令和指令集" class="headerlink" title="指令和指令集"></a>指令和指令集</h3><p><strong>指令</strong></p><ol><li><p>由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p></li><li><p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p></li><li><p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p></li></ol><p><strong>指令集</strong></p><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。如常见的</p><ol><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ol><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ol><li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li><li>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</li><li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译（汇编）成机器指令码，计算机才能识别和执行。</li></ol><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ol><li><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p></li><li><p>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p></li></ol><img src="/chapter_008/0008.png"><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><ol><li><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p></li><li><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p></li><li><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p></li><li><p>字节码典型的应用为：Java bytecode</p></li></ol><h3 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h3><p><strong>编译过程又可以分成两个阶段：编译和汇编。</strong></p><ol><li><p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p></li><li><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p></li></ol><img src="/chapter_008/0009.png"><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><h3 id="为什么要有解释器"><a href="#为什么要有解释器" class="headerlink" title="为什么要有解释器"></a>为什么要有解释器</h3><ol><li><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式由高级语言直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法（也就是产生了一个中间产品<strong>字节码</strong>）。</p></li><li><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p></li><li><p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p></li></ol><img src="/chapter_008/0010.png"><h3 id="解释器的分类"><a href="#解释器的分类" class="headerlink" title="解释器的分类"></a>解释器的分类</h3><ol><li>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。<ul><li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</li><li>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li></ul></li><li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul></li></ol><h3 id="解释器的现状"><a href="#解释器的现状" class="headerlink" title="解释器的现状"></a>解释器的现状</h3><ol><li><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C++程序员所调侃。</p></li><li><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p></li><li><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p></li></ol><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><h3 id="Java-代码执行的分类"><a href="#Java-代码执行的分类" class="headerlink" title="Java 代码执行的分类"></a>Java 代码执行的分类</h3><ol><li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p></li><li><p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p></li><li><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。<strong>它采用解释器与即时编译器并存的架构</strong>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p></li><li><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。</p></li></ol><h3 id="为啥我们还需要解释器呢？"><a href="#为啥我们还需要解释器呢？" class="headerlink" title="为啥我们还需要解释器呢？"></a>为啥我们还需要解释器呢？</h3><ol><li><p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p></li><li><p>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</p></li></ol><p><strong>首先明确两点：</strong></p><ol><li>当程序启动后，解释器可以马上发挥作用，<strong>响应速度快</strong>，省去编译的时间，立即执行。</li><li>编译器要想发挥作用，把代码编译成本地代码，<strong>需要一定的执行时间</strong>，但编译为本地代码后，执行效率高。</li></ol><p><strong>所以：</strong></p><ol><li>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</li><li>在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</li><li>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</li></ul><ol><li><p>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态（已经运行了一段时间叫热机状态）可以承受的负载要大于冷机状态（刚启动的时候叫冷机状态）</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p></li><li><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1&#x2F;2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—<strong>阿里团队</strong></p></li></ol><img src="/chapter_008/0011.png"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JITTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            list.add(<span class="hljs-string">&quot;让天下没有难学的技术&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p>通过 JVisualVM 查看 JIT 编译器执行的编译次数</p><img src="/chapter_008/0012.png"><h3 id="JIT编译器相关概念"><a href="#JIT编译器相关概念" class="headerlink" title="JIT编译器相关概念"></a>JIT编译器相关概念</h3><ol><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。</li><li>也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li><li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）</li></ol><h3 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h3><ol><li>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。</li><li>关于那些需要被编译为本地代码的字节码，也被称之为<strong>“热点代码”</strong>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</li><li>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。</li><li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</li><li><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。<ol><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ol></li></ol><h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><ol><li><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p></li><li><p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p></li><li><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本</p><ul><li>如果存在，则优先使用编译后的本地代码来执行</li><li>如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。<ul><li>如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li><li>如果未超过阈值，则使用解释器对字节码文件解释执行</li></ul></li></ul></li></ol><img src="/chapter_008/0013.png"><h4 id="热度衰减"><a href="#热度衰减" class="headerlink" title="热度衰减"></a>热度衰减</h4><ol><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li></ol><h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><img src="/chapter_008/0014.png"><h3 id="HotSpotVM可以设置程序执行方法"><a href="#HotSpotVM可以设置程序执行方法" class="headerlink" title="HotSpotVM可以设置程序执行方法"></a>HotSpotVM可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ol><li>-Xint：完全采用解释器模式执行程序；</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ol><img src="/chapter_008/0015.png"><p><strong>代码测试</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 测试解释器模式和JIT编译模式</span><span class="hljs-comment"> *  -Xint  : 6520ms</span><span class="hljs-comment"> *  -Xcomp : 950ms</span><span class="hljs-comment"> *  -Xmixed : 936ms</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntCompTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        testPrimeNumber(<span class="hljs-number">1000000</span>);        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start));    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPrimeNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;            <span class="hljs-comment">//计算100以内的质数</span>            label:<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;j &lt;= <span class="hljs-number">100</span>;j++)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;k &lt;= Math.sqrt(j);k++)&#123;                    <span class="hljs-keyword">if</span>(j % k == <span class="hljs-number">0</span>)&#123;                        <span class="hljs-keyword">continue</span> label;                    &#125;                &#125;                <span class="hljs-comment">//System.out.println(j);</span>            &#125;        &#125;    &#125;&#125;</code></pre><p>结论：只用解释器执行是真的慢</p><h3 id="HotSpotVM-JIT-分类"><a href="#HotSpotVM-JIT-分类" class="headerlink" title="HotSpotVM JIT 分类"></a>HotSpotVM JIT 分类</h3><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ol><li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul><li>C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li></ul></li><li>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。<ul><li>C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）</li></ul></li></ol><h3 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h3><ol><li>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。<ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现樊进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul></li></ol><blockquote><p>也就是说之前的逃逸分析，只有在C2（server模式下）才会触发。那是否说明C1就用不了了？</p></blockquote><h3 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h3><ol><li><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p></li><li><p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p></li><li><p>一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高</p></li><li><p>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</p></li></ol><h4 id="Graal-编译器"><a href="#Graal-编译器" class="headerlink" title="Graal 编译器"></a>Graal 编译器</h4><ul><li><p>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</p></li><li><p>编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</p></li><li><p>目前，带着实验状态标签，需要使用开关参数去激活才能使用</p><p>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</p></li></ul><h4 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h4><ol><li><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p></li><li><p>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p></li><li><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是<strong>在程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前</strong>，便将字节码转换为机器码的过程。</p><p>.java -&gt; .class -&gt; (使用jaotc) -&gt; .so</p></li></ol><p><strong>AOT编译器编译器的优缺点</strong></p><p><strong>最大的好处：</strong></p><ol><li>Java虚拟机加载已经预编译成二进制库，可以直接执行。</li><li>不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</li></ol><p><strong>缺点：</strong></p><ol><li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;执行引擎&quot;&gt;&lt;a href=&quot;#执行引擎&quot; class=&quot;headerlink&quot; title=&quot;执行引擎&quot;&gt;&lt;/a&gt;执行引擎&lt;/h1&gt;&lt;p&gt;执行引擎的作用是将二进制字节码编译成为本地机器呢能够执行的机器指令&lt;/p&gt;
&lt;h2 id=&quot;执行引擎概述&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>7.JVM系列-对象的实例化内存布局与访问定位</title>
    <link href="http://example.com/2023/04/04/7-JVM%E7%B3%BB%E5%88%97-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
    <id>http://example.com/2023/04/04/7-JVM%E7%B3%BB%E5%88%97-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</id>
    <published>2023-04-04T09:20:02.000Z</published>
    <updated>2024-03-12T09:44:13.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象的实例化内存布局与访问定位"><a href="#对象的实例化内存布局与访问定位" class="headerlink" title="对象的实例化内存布局与访问定位"></a>对象的实例化内存布局与访问定位</h1><p>将运行时数据区里面的各个空间粘合在一起</p><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><img src="/chapter_007/0001.png"><blockquote><p>补充：</p><ul><li>new中分为三种<ol><li>最常见 new Object();</li><li>变例：单例模式 Xxx的静态方法</li><li>变例：工厂模式 XxxFactory的静态方法</li></ol></li><li>class的newInstance()在jdk9版本中已经过时，因为条件太过苛刻<ul><li>只能调用空参构造器，权限必须时public</li></ul></li><li>Contructor的反射的方式可以调用空参、带参的构造器，权限没有要求</li><li>使用clone()  不调用任何构造器，使用时需要实现Cloneable接口 实现clone()</li><li>使用反序列化 调用文件或者网络中对象的二进制流</li></ul></blockquote><h3 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h3><h3 id="对象创建的步骤"><a href="#对象创建的步骤" class="headerlink" title="对象创建的步骤"></a>对象创建的步骤</h3><blockquote><p><strong>从字节码看待对象的创建过程</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();    &#125;&#125;</code></pre><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/lang/Object</span>         <span class="hljs-number">3</span>: dup            复制引用         <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">1</span>    方法执行              <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>         <span class="hljs-number">7</span>: astore_1         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">10</span>: <span class="hljs-number">8</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;            <span class="hljs-number">8</span>       <span class="hljs-number">1</span>     <span class="hljs-number">1</span>   obj   Ljava/lang/Object;&#125;</code></pre><p><strong>1、判断对象对应的类是否加载、链接、初始化</strong></p><ol><li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。</li><li>如果该类没有加载，那么在双亲委派模式下，使用以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</li></ol><p><strong>2、为对象分配内存</strong></p><ol><li>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</li><li>如果内存规整：采用指针碰撞分配内存<ul><li>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</li><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。</li><li>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li><li>标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域</li></ul></li><li>如果内存不规整<ul><li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。</li><li>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</li><li>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</li><li>标记清除算法清理过后的堆内存，就会存在很多内存碎片。</li></ul></li></ol><p><strong>3、处理并发问题</strong></p><ol><li>采用CAS+失败重试保证更新的原子性   </li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）</li><li>在Eden区给每个线程分配一块区域</li></ol><blockquote><p>加锁或者添加TLAB</p></blockquote><p><strong>4、初始化分配到的空间</strong></p><ul><li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li><li>给对象属性赋值的顺序：<ul><li>属性的默认值初始化</li><li>显示初始化&#x2F;代码块初始化（并列关系，谁先谁后看代码编写的顺序）</li><li>构造器初始化</li></ul></li></ul><p><strong>5、设置对象的对象头</strong></p><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><blockquote><p>指向方法区中的类源信息 使他们关联在一起</p></blockquote><p><strong>6、执行init方法进行初始化</strong></p><p>（ 属性的显式初始化、代码块中初始化、构造器中初始化）</p><ol><li><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p></li><li><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p></li></ol><blockquote><p><strong>从字节码角度看 init 方法</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 测试对象实例化的过程</span><span class="hljs-comment"> *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）</span><span class="hljs-comment"> *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  给对象的属性赋值的操作：</span><span class="hljs-comment"> *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>&#123;    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1001</span>;    String name;    Account acct;    &#123;        name = <span class="hljs-string">&quot;匿名客户&quot;</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Customer</span><span class="hljs-params">()</span>&#123;        acct = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;&#125;</code></pre><p><strong>Customer类的字节码</strong></p><pre><code class="hljs java"> <span class="hljs-number">0</span> aload_0 <span class="hljs-number">1</span> invokespecial #<span class="hljs-number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt; <span class="hljs-number">4</span> aload_0 <span class="hljs-number">5</span> sipush <span class="hljs-number">1001</span> <span class="hljs-number">8</span> putfield #<span class="hljs-number">2</span> &lt;com/atguigu/java/Customer.id&gt;<span class="hljs-number">11</span> aload_0<span class="hljs-number">12</span> ldc #<span class="hljs-number">3</span> &lt;匿名客户&gt;<span class="hljs-number">14</span> putfield #<span class="hljs-number">4</span> &lt;com/atguigu/java/Customer.name&gt;<span class="hljs-number">17</span> aload_0<span class="hljs-number">18</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">5</span> &lt;com/atguigu/java/Account&gt;<span class="hljs-number">21</span> dup<span class="hljs-number">22</span> invokespecial #<span class="hljs-number">6</span> &lt;com/atguigu/java/Account.&lt;init&gt;&gt;<span class="hljs-number">25</span> putfield #<span class="hljs-number">7</span> &lt;com/atguigu/java/Customer.acct&gt;<span class="hljs-number">28</span> <span class="hljs-keyword">return</span></code></pre><ul><li>init() 方法的字节码指令：<ul><li>属性的默认值初始化：<code>id = 1001;</code></li><li>显示初始化&#x2F;代码块初始化：<code>name = &quot;匿名客户&quot;;</code></li><li>构造器初始化：<code>acct = new Account();</code></li></ul></li></ul><p>什么时候算是创建成功对象？使new的时候环视调用构造器的时候？</p><p>在创建对象的时候从new开始到invokespecial结束</p><pre><code class="hljs java"><span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/lang/Object</span>     <span class="hljs-number">3</span>: dup            复制引用     <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">1</span>    方法执行              <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>     <span class="hljs-number">7</span>: astore_1     <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span></code></pre><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><img src="/chapter_007/0002.png"><blockquote><p><strong>内存布局总结</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>&#123;    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1001</span>;    String name;    Account acct;    &#123;        name = <span class="hljs-string">&quot;匿名客户&quot;</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Customer</span><span class="hljs-params">()</span>&#123;        acct = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Customer</span> <span class="hljs-variable">cust</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;&#125;</code></pre><p>图解内存布局</p><img src="/chapter_007/0003.png"><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p><strong>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</strong></p><img src="/chapter_007/0004.png"><p>定位，通过栈上reference访问</p><p><strong>对象的两种访问方式：句柄访问和直接指针</strong></p><p><strong>1、句柄访问</strong></p><ol><li>缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低</li><li>优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</li></ol><img src="/chapter_007/0005.png"><p><strong>2、直接指针（HotSpot采用）</strong></p><ol><li>优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</li><li>缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值</li></ol><img src="image/chapter_007/0006.png">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对象的实例化内存布局与访问定位&quot;&gt;&lt;a href=&quot;#对象的实例化内存布局与访问定位&quot; class=&quot;headerlink&quot; title=&quot;对象的实例化内存布局与访问定位&quot;&gt;&lt;/a&gt;对象的实例化内存布局与访问定位&lt;/h1&gt;&lt;p&gt;将运行时数据区里面的各个空间粘合在一</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>6.JVM系列-方法区</title>
    <link href="http://example.com/2023/03/31/6-JVM%E7%B3%BB%E5%88%97-%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <id>http://example.com/2023/03/31/6-JVM%E7%B3%BB%E5%88%97-%E6%96%B9%E6%B3%95%E5%8C%BA/</id>
    <published>2023-03-31T07:21:44.000Z</published>
    <updated>2024-03-12T09:43:10.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p><strong>从线程共享与否的角度来看</strong></p><p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型场景就是数据库连接管理，以及会话管理。</p><img src="/chapter_006/0001.png"><p><strong>栈、堆、方法区的交互关系</strong></p><p><strong>下面涉及了对象的访问定位</strong></p><ol><li>Person 类的 .class 信息存放在方法区中</li><li>person 变量存放在 Java 栈的局部变量表中</li><li>真正的 person 对象存放在 Java 堆中</li><li>在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的</li></ol><img src="/chapter_006/0002.png"><h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4</a></p></blockquote><h3 id="方法区在哪里？"><a href="#方法区在哪里？" class="headerlink" title="方法区在哪里？"></a>方法区在哪里？</h3><ol><li>《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li><li>所以，<strong>方法区可以看作是一块独立于Java堆的内存空间</strong>。</li></ol><img src="/chapter_006/0003.png"><h3 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h3><p><strong>方法区主要存放的是 Class，而堆中主要存放的是实例化的对象</strong></p><ol><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载同一个类时，只能有一个线程能加载该类，<strong>其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次</strong>。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ol><p><strong>代码举例</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(<span class="hljs-string">&quot;start...&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">&quot;end...&quot;</span>);    &#125;&#125;</code></pre><p>简单的程序，加载了1600多个类</p><img src="/chapter_006/0004.png"><h3 id="HotSpot方法区演进"><a href="#HotSpot方法区演进" class="headerlink" title="HotSpot方法区演进"></a>HotSpot方法区演进</h3><ol><li>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类</li><li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。<ul><li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOm（超过-XX:MaxPermsize上限）</li></ul></li><li>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</li><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。</li><li>永久代、元空间二者并不只是名字变了，内部结构也调整了</li><li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</li></ol><img src="/chapter_006/0005.png"><h2 id="设置方法区大小与-OOM"><a href="#设置方法区大小与-OOM" class="headerlink" title="设置方法区大小与 OOM"></a>设置方法区大小与 OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><h3 id="JDK7及以前-永久代"><a href="#JDK7及以前-永久代" class="headerlink" title="JDK7及以前(永久代)"></a>JDK7及以前(永久代)</h3><ol><li>通过-XX:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ol><img src="/chapter_006/0006.png"><h3 id="JDK8及以后-元空间"><a href="#JDK8及以后-元空间" class="headerlink" title="JDK8及以后(元空间)"></a>JDK8及以后(元空间)</h3><blockquote><p><strong>JDK8 版本设置元空间大小</strong></p></blockquote><ol><li><p>元数据区大小可以使用参数 <strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong> 指定</p></li><li><p>默认值依赖于平台，Windows下，-XX:MetaspaceSize 约为21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p></li><li><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p></li><li><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p></li><li><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p></li></ol><h3 id="方法区OOM"><a href="#方法区OOM" class="headerlink" title="方法区OOM"></a>方法区OOM</h3><p>举例：</p><p>代码：OOMTest 类继承 ClassLoader 类，获得 defineClass() 方法，可自己进行类的加载</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * jdk6/7中：</span><span class="hljs-comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * jdk8中：</span><span class="hljs-comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">OOMTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OOMTest</span>();            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;                <span class="hljs-comment">//创建ClassWriter对象，用于生成类的二进制字节码</span>                <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>);                <span class="hljs-comment">//指明版本号，修饰符，类名，包名，父类，接口</span>                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;Class&quot;</span> + i, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-literal">null</span>);                <span class="hljs-comment">//返回byte[]</span>                <span class="hljs-type">byte</span>[] code = classWriter.toByteArray();                <span class="hljs-comment">//类的加载</span>                test.defineClass(<span class="hljs-string">&quot;Class&quot;</span> + i, code, <span class="hljs-number">0</span>, code.length);<span class="hljs-comment">//Class对象</span>                j++;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(j);        &#125;    &#125;&#125;</code></pre><p><strong>不设置元空间的上限</strong></p><p>使用默认的 JVM 参数，元空间不设置上限</p><p>输出结果：</p><pre><code class="hljs java"><span class="hljs-number">10000</span></code></pre><p><strong>设置元空间的上限</strong></p><p>JVM 参数</p><p>-XX:MetaspaceSize&#x3D;10m -XX:MaxMetaspaceSize&#x3D;10m</p><p>输出结果：</p><pre><code class="hljs java"><span class="hljs-number">8531</span>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Metaspaceat java.lang.ClassLoader.defineClass1(Native Method)at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="hljs-number">763</span>)at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="hljs-number">642</span>)at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="hljs-number">29</span>)</code></pre><h3 id="如何解决OOM"><a href="#如何解决OOM" class="headerlink" title="如何解决OOM"></a>如何解决OOM</h3><blockquote><p>这个属于调优的问题，这里先简单的说一下</p></blockquote><ol><li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</li><li><strong>内存泄漏</strong>就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ol><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><h3 id="方法区存储什么？"><a href="#方法区存储什么？" class="headerlink" title="方法区存储什么？"></a>方法区存储什么？</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><img src="/chapter_006/0007.png"><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p><img src="/chapter_006/0008.png"><p><strong>类型信息</strong></p><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ol><li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ol><p><strong>域（Field）信息</strong></p><blockquote><p>也就是我们常说的成员变量，域信息是比较官方的称呼</p></blockquote><ol><li><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p></li><li><p>域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p></li></ol><p><strong>方法（Method）信息</strong></p><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li>方法名称</li><li>方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class</li><li>方法参数(形参)的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 测试方法区的内部构成</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodInnerStrucTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;String&gt;,Serializable &#123;    <span class="hljs-comment">//属性</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;测试方法的内部结构&quot;</span>;    <span class="hljs-comment">//构造器</span>    <span class="hljs-comment">//方法</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;        System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-type">int</span> cal)</span>&#123;        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;            result = value / cal;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(String o)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><p><code>javap -v -p MethodInnerStrucTest.class &gt; test.txt</code></p><ul><li>反编译字节码文件，并输出值文本文件中，便于查看。参数 -p 确保能查看 private 权限类型的字段或方法</li></ul><p>字节码：</p><p># stack:运行该方法所需要的最大操作数栈深度是2.</p><p>#locals:运行该方法所需要的最大局部方法表的最大slot数是1</p><p>#args_size:该方法的形参个数。如果是实例方法，第一个形参是this引用。</p><pre><code class="hljs java">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter09/com/atguigu/java/MethodInnerStrucTest.<span class="hljs-keyword">class</span>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">13</span>; size <span class="hljs-number">1626</span> bytes  MD5 checksum 0d0fcb54854d4ce183063df985141ad0  Compiled from <span class="hljs-string">&quot;MethodInnerStrucTest.java&quot;</span><span class="hljs-comment">//类型信息      </span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java.MethodInnerStrucTest <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Object <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable  minor version: <span class="hljs-number">0</span>  major version: <span class="hljs-number">52</span>  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">18.</span>#<span class="hljs-number">52</span>        <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">17.</span>#<span class="hljs-number">53</span>        <span class="hljs-comment">// com/atguigu/java/MethodInnerStrucTest.num:I</span>   #<span class="hljs-number">3</span> = Fieldref           #<span class="hljs-number">54.</span>#<span class="hljs-number">55</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span>   #<span class="hljs-number">4</span> = Class              #<span class="hljs-number">56</span>            <span class="hljs-comment">// java/lang/StringBuilder</span>   #<span class="hljs-number">5</span> = Methodref          #<span class="hljs-number">4.</span>#<span class="hljs-number">52</span>         <span class="hljs-comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span>   #<span class="hljs-number">6</span> = String             #<span class="hljs-number">57</span>            <span class="hljs-comment">// count =</span>   #<span class="hljs-number">7</span> = Methodref          #<span class="hljs-number">4.</span>#<span class="hljs-number">58</span>         <span class="hljs-comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span>   #<span class="hljs-number">8</span> = Methodref          #<span class="hljs-number">4.</span>#<span class="hljs-number">59</span>         <span class="hljs-comment">// java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span>   #<span class="hljs-number">9</span> = Methodref          #<span class="hljs-number">4.</span>#<span class="hljs-number">60</span>         <span class="hljs-comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span>  #<span class="hljs-number">10</span> = Methodref          #<span class="hljs-number">61.</span>#<span class="hljs-number">62</span>        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span>  #<span class="hljs-number">11</span> = Class              #<span class="hljs-number">63</span>            <span class="hljs-comment">// java/lang/Exception</span>  #<span class="hljs-number">12</span> = Methodref          #<span class="hljs-number">11.</span>#<span class="hljs-number">64</span>        <span class="hljs-comment">// java/lang/Exception.printStackTrace:()V</span>  #<span class="hljs-number">13</span> = Class              #<span class="hljs-number">65</span>            <span class="hljs-comment">// java/lang/String</span>  #<span class="hljs-number">14</span> = Methodref          #<span class="hljs-number">17.</span>#<span class="hljs-number">66</span>        <span class="hljs-comment">// com/atguigu/java/MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I</span>  #<span class="hljs-number">15</span> = String             #<span class="hljs-number">67</span>            <span class="hljs-comment">// 测试方法的内部结构</span>  #<span class="hljs-number">16</span> = Fieldref           #<span class="hljs-number">17.</span>#<span class="hljs-number">68</span>        <span class="hljs-comment">// com/atguigu/java/MethodInnerStrucTest.str:Ljava/lang/String;</span>  #<span class="hljs-number">17</span> = Class              #<span class="hljs-number">69</span>            <span class="hljs-comment">// com/atguigu/java/MethodInnerStrucTest</span>  #<span class="hljs-number">18</span> = Class              #<span class="hljs-number">70</span>            <span class="hljs-comment">// java/lang/Object</span>  #<span class="hljs-number">19</span> = Class              #<span class="hljs-number">71</span>            <span class="hljs-comment">// java/lang/Comparable</span>  #<span class="hljs-number">20</span> = Class              #<span class="hljs-number">72</span>            <span class="hljs-comment">// java/io/Serializable</span>  #<span class="hljs-number">21</span> = Utf8               num  #<span class="hljs-number">22</span> = Utf8               I  #<span class="hljs-number">23</span> = Utf8               str  #<span class="hljs-number">24</span> = Utf8               Ljava/lang/String;  #<span class="hljs-number">25</span> = Utf8               &lt;init&gt;  #<span class="hljs-number">26</span> = Utf8               ()V  #<span class="hljs-number">27</span> = Utf8               Code  #<span class="hljs-number">28</span> = Utf8               LineNumberTable  #<span class="hljs-number">29</span> = Utf8               LocalVariableTable  #<span class="hljs-number">30</span> = Utf8               <span class="hljs-built_in">this</span>  #<span class="hljs-number">31</span> = Utf8               Lcom/atguigu/java/MethodInnerStrucTest;  #<span class="hljs-number">32</span> = Utf8               test1  #<span class="hljs-number">33</span> = Utf8               count  #<span class="hljs-number">34</span> = Utf8               test2  #<span class="hljs-number">35</span> = Utf8               (I)I  #<span class="hljs-number">36</span> = Utf8               value  #<span class="hljs-number">37</span> = Utf8               e  #<span class="hljs-number">38</span> = Utf8               Ljava/lang/Exception;  #<span class="hljs-number">39</span> = Utf8               cal  #<span class="hljs-number">40</span> = Utf8               result  #<span class="hljs-number">41</span> = Utf8               StackMapTable  #<span class="hljs-number">42</span> = Class              #<span class="hljs-number">63</span>            <span class="hljs-comment">// java/lang/Exception</span>  #<span class="hljs-number">43</span> = Utf8               compareTo  #<span class="hljs-number">44</span> = Utf8               (Ljava/lang/String;)I  #<span class="hljs-number">45</span> = Utf8               o  #<span class="hljs-number">46</span> = Utf8               (Ljava/lang/Object;)I  #<span class="hljs-number">47</span> = Utf8               &lt;clinit&gt;  #<span class="hljs-number">48</span> = Utf8               Signature  #<span class="hljs-number">49</span> = Utf8               Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;  #<span class="hljs-number">50</span> = Utf8               SourceFile  #<span class="hljs-number">51</span> = Utf8               MethodInnerStrucTest.java  #<span class="hljs-number">52</span> = NameAndType        #<span class="hljs-number">25</span>:#<span class="hljs-number">26</span>        <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span>  #<span class="hljs-number">53</span> = NameAndType        #<span class="hljs-number">21</span>:#<span class="hljs-number">22</span>        <span class="hljs-comment">// num:I</span>  #<span class="hljs-number">54</span> = Class              #<span class="hljs-number">73</span>            <span class="hljs-comment">// java/lang/System</span>  #<span class="hljs-number">55</span> = NameAndType        #<span class="hljs-number">74</span>:#<span class="hljs-number">75</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span>  #<span class="hljs-number">56</span> = Utf8               java/lang/StringBuilder  #<span class="hljs-number">57</span> = <span class="hljs-type">Utf8</span>               <span class="hljs-variable">count</span> <span class="hljs-operator">=</span>  #<span class="hljs-number">58</span> = NameAndType        #<span class="hljs-number">76</span>:#<span class="hljs-number">77</span>        <span class="hljs-comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span>  #<span class="hljs-number">59</span> = NameAndType        #<span class="hljs-number">76</span>:#<span class="hljs-number">78</span>        <span class="hljs-comment">// append:(I)Ljava/lang/StringBuilder;</span>  #<span class="hljs-number">60</span> = NameAndType        #<span class="hljs-number">79</span>:#<span class="hljs-number">80</span>        <span class="hljs-comment">// toString:()Ljava/lang/String;</span>  #<span class="hljs-number">61</span> = Class              #<span class="hljs-number">81</span>            <span class="hljs-comment">// java/io/PrintStream</span>  #<span class="hljs-number">62</span> = NameAndType        #<span class="hljs-number">82</span>:#<span class="hljs-number">83</span>        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span>  #<span class="hljs-number">63</span> = Utf8               java/lang/Exception  #<span class="hljs-number">64</span> = NameAndType        #<span class="hljs-number">84</span>:#<span class="hljs-number">26</span>        <span class="hljs-comment">// printStackTrace:()V</span>  #<span class="hljs-number">65</span> = Utf8               java/lang/String  #<span class="hljs-number">66</span> = NameAndType        #<span class="hljs-number">43</span>:#<span class="hljs-number">44</span>        <span class="hljs-comment">// compareTo:(Ljava/lang/String;)I</span>  #<span class="hljs-number">67</span> = Utf8               测试方法的内部结构  #<span class="hljs-number">68</span> = NameAndType        #<span class="hljs-number">23</span>:#<span class="hljs-number">24</span>        <span class="hljs-comment">// str:Ljava/lang/String;</span>  #<span class="hljs-number">69</span> = Utf8               com/atguigu/java/MethodInnerStrucTest  #<span class="hljs-number">70</span> = Utf8               java/lang/Object  #<span class="hljs-number">71</span> = Utf8               java/lang/Comparable  #<span class="hljs-number">72</span> = Utf8               java/io/Serializable  #<span class="hljs-number">73</span> = Utf8               java/lang/System  #<span class="hljs-number">74</span> = Utf8               out  #<span class="hljs-number">75</span> = Utf8               Ljava/io/PrintStream;  #<span class="hljs-number">76</span> = Utf8               append  #<span class="hljs-number">77</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;  #<span class="hljs-number">78</span> = Utf8               (I)Ljava/lang/StringBuilder;  #<span class="hljs-number">79</span> = Utf8               toString  #<span class="hljs-number">80</span> = Utf8               ()Ljava/lang/String;  #<span class="hljs-number">81</span> = Utf8               java/io/PrintStream  #<span class="hljs-number">82</span> = Utf8               println  #<span class="hljs-number">83</span> = Utf8               (Ljava/lang/String;)V  #<span class="hljs-number">84</span> = Utf8               printStackTrace&#123;<span class="hljs-comment">//域信息</span>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> num;    descriptor: I    flags: ACC_PUBLIC  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> java.lang.String str;    descriptor: Ljava/lang/String;    flags: ACC_PRIVATE, ACC_STATIC  <span class="hljs-comment">//方法信息</span>  <span class="hljs-keyword">public</span> com.atguigu.java.MethodInnerStrucTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>         <span class="hljs-number">4</span>: aload_0         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span>         <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span>        <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">10</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">12</span>: <span class="hljs-number">4</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>      <span class="hljs-number">11</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>;    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">20</span>         <span class="hljs-number">2</span>: istore_1         <span class="hljs-number">3</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="hljs-number">6</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span>         <span class="hljs-number">9</span>: dup        <span class="hljs-number">10</span>: invokespecial #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span>        <span class="hljs-number">13</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String count =</span>        <span class="hljs-number">15</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span>        <span class="hljs-number">18</span>: iload_1        <span class="hljs-number">19</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span>        <span class="hljs-number">22</span>: invokevirtual #<span class="hljs-number">9</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span>        <span class="hljs-number">25</span>: invokevirtual #<span class="hljs-number">10</span>                 <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>        <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">17</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">18</span>: <span class="hljs-number">3</span>        line <span class="hljs-number">19</span>: <span class="hljs-number">28</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>      <span class="hljs-number">29</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;            <span class="hljs-number">3</span>      <span class="hljs-number">26</span>     <span class="hljs-number">1</span> count   I  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;    descriptor: (I)I    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: iconst_0         <span class="hljs-number">1</span>: istore_1         <span class="hljs-number">2</span>: bipush        <span class="hljs-number">30</span>         <span class="hljs-number">4</span>: istore_2         <span class="hljs-number">5</span>: iload_2         <span class="hljs-number">6</span>: iload_0         <span class="hljs-number">7</span>: idiv         <span class="hljs-number">8</span>: istore_1         <span class="hljs-number">9</span>: goto          <span class="hljs-number">17</span>        <span class="hljs-number">12</span>: astore_2        <span class="hljs-number">13</span>: aload_2        <span class="hljs-number">14</span>: invokevirtual #<span class="hljs-number">12</span>                 <span class="hljs-comment">// Method java/lang/Exception.printStackTrace:()V</span>        <span class="hljs-number">17</span>: iload_1        <span class="hljs-number">18</span>: ireturn      Exception table:         from    to  target type             <span class="hljs-number">2</span>     <span class="hljs-number">9</span>    <span class="hljs-number">12</span>   Class java/lang/Exception      LineNumberTable:        line <span class="hljs-number">21</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">23</span>: <span class="hljs-number">2</span>        line <span class="hljs-number">24</span>: <span class="hljs-number">5</span>        line <span class="hljs-number">27</span>: <span class="hljs-number">9</span>        line <span class="hljs-number">25</span>: <span class="hljs-number">12</span>        line <span class="hljs-number">26</span>: <span class="hljs-number">13</span>        line <span class="hljs-number">28</span>: <span class="hljs-number">17</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">5</span>       <span class="hljs-number">4</span>     <span class="hljs-number">2</span> value   I           <span class="hljs-number">13</span>       <span class="hljs-number">4</span>     <span class="hljs-number">2</span>     e   Ljava/lang/Exception;            <span class="hljs-number">0</span>      <span class="hljs-number">19</span>     <span class="hljs-number">0</span>   cal   I            <span class="hljs-number">2</span>      <span class="hljs-number">17</span>     <span class="hljs-number">1</span> result   I      StackMapTable: number_of_entries = <span class="hljs-number">2</span>        frame_type = <span class="hljs-number">255</span> <span class="hljs-comment">/* full_frame */</span>          offset_delta = <span class="hljs-number">12</span>          locals = [ <span class="hljs-type">int</span>, <span class="hljs-type">int</span> ]          stack = [ <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>/lang/Exception ]        frame_type = <span class="hljs-number">4</span> <span class="hljs-comment">/* same */</span>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(java.lang.String)</span>;    descriptor: (Ljava/lang/String;)I    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">2</span>         <span class="hljs-number">0</span>: iconst_0         <span class="hljs-number">1</span>: ireturn      LineNumberTable:        line <span class="hljs-number">33</span>: <span class="hljs-number">0</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">2</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;            <span class="hljs-number">0</span>       <span class="hljs-number">2</span>     <span class="hljs-number">1</span>     o   Ljava/lang/String;  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(java.lang.Object)</span>;    descriptor: (Ljava/lang/Object;)I    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC    Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">2</span>         <span class="hljs-number">0</span>: aload_0         <span class="hljs-number">1</span>: aload_1         <span class="hljs-number">2</span>: checkcast     #<span class="hljs-number">13</span>                 <span class="hljs-comment">// class java/lang/String</span>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">14</span>                 <span class="hljs-comment">// Method compareTo:(Ljava/lang/String;)I</span>         <span class="hljs-number">8</span>: ireturn      LineNumberTable:        line <span class="hljs-number">10</span>: <span class="hljs-number">0</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;  <span class="hljs-keyword">static</span> &#123;&#125;;    descriptor: ()V    flags: ACC_STATIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">15</span>                 <span class="hljs-comment">// String 测试方法的内部结构</span>         <span class="hljs-number">2</span>: putstatic     #<span class="hljs-number">16</span>                 <span class="hljs-comment">// Field str:Ljava/lang/String;</span>         <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">13</span>: <span class="hljs-number">0</span>&#125;Signature: #<span class="hljs-number">49</span>                          <span class="hljs-comment">// Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span>SourceFile: <span class="hljs-string">&quot;MethodInnerStrucTest.java&quot;</span></code></pre><p><strong>类型信息</strong></p><p>在运行时方法区中，类信息中记录了哪个加载器加载了该类，同时类加载器也记录了它加载了哪些类</p><pre><code class="hljs java"><span class="hljs-comment">//类型信息      </span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java.MethodInnerStrucTest <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Object <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable</code></pre><p><strong>域信息</strong></p><ol><li>descriptor: I 表示字段类型为 Integer</li><li>flags: ACC_PUBLIC 表示字段权限修饰符为 public</li><li>域名称</li></ol><pre><code class="hljs java"><span class="hljs-comment">//域信息</span>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> num;    descriptor: I    flags: ACC_PUBLIC  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> java.lang.String str;    descriptor: Ljava/lang/String;    flags: ACC_PRIVATE, ACC_STATIC</code></pre><p><strong>方法信息</strong></p><ol><li>descriptor: ()V 表示方法返回值类型为 void</li><li>flags: ACC_PUBLIC 表示方法权限修饰符为 public</li><li>stack&#x3D;3 表示操作数栈深度为 3</li><li>locals&#x3D;2 表示局部变量个数为 2 个（实力方法包含 this）</li><li>test1() 方法虽然没有参数，但是其 args_size&#x3D;1 ，这时因为将 this 作为了参数</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>;    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">20</span>         <span class="hljs-number">2</span>: istore_1         <span class="hljs-number">3</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="hljs-number">6</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span>         <span class="hljs-number">9</span>: dup        <span class="hljs-number">10</span>: invokespecial #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span>        <span class="hljs-number">13</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String count =</span>        <span class="hljs-number">15</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span>        <span class="hljs-number">18</span>: iload_1        <span class="hljs-number">19</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span>        <span class="hljs-number">22</span>: invokevirtual #<span class="hljs-number">9</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span>        <span class="hljs-number">25</span>: invokevirtual #<span class="hljs-number">10</span>                 <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>        <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">17</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">18</span>: <span class="hljs-number">3</span>        line <span class="hljs-number">19</span>: <span class="hljs-number">28</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>      <span class="hljs-number">29</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;            <span class="hljs-number">3</span>      <span class="hljs-number">26</span>     <span class="hljs-number">1</span> count   I</code></pre><h3 id="non-final-类型的类变量"><a href="#non-final-类型的类变量" class="headerlink" title="non-final 类型的类变量"></a>non-final 类型的类变量</h3><ol><li><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p></li><li><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p></li></ol><p><strong>举例</strong></p><ol><li>如下代码所示，即使我们把order设置为null，也不会出现空指针异常</li><li>这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        order.hello();        System.out.println(order.count);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="hljs plaintext">hello!1</code></pre><h4 id="全局常量：static-final"><a href="#全局常量：static-final" class="headerlink" title="全局常量：static final"></a>全局常量：static final</h4><ol><li><p>全局常量就是使用 static final 进行修饰</p></li><li><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p></li></ol><p>查看上面代码，这部分的字节码指令</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;    ...&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count;    descriptor: I    flags: ACC_PUBLIC, ACC_STATIC  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> number;    descriptor: I    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL    ConstantValue: <span class="hljs-type">int</span> <span class="hljs-number">2</span></code></pre><p>可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><h4 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h4><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><p>后面会细讲常量池，这里为了讲清楚方法区，简单带一下。</p></blockquote><img src="/chapter_006/0009.png"><ol><li><p>方法区，内部包含了运行时常量池</p><blockquote><p>把字节码中的常量池加载到方法区中，就是运行时常量池</p></blockquote></li><li><p>字节码文件，内部包含了常量池。（之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池）</p></li><li><p>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</p></li><li><p>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</p></li></ol><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ol><li>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括各种字面量和对类型、域和方法的符号引用。</li><li>字面量： 10 ， “我是某某”这种数字和字符串都是字面量</li></ol><img src="/chapter_006/0010.png"><p><strong>为什么需要常量池？</strong></p><ol><li>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍</li></ol><p>比如：如下的代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleClass</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;</code></pre><ol><li>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。</li><li>比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构</li><li>这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</li></ol><img src="/chapter_006/0011.png"><p><strong>常量池中有啥？</strong></p><ol><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ol><p>MethodInnerStrucTest 的 test1方法的字节码</p><pre><code class="hljs java"> <span class="hljs-number">0</span> bipush <span class="hljs-number">20</span> <span class="hljs-number">2</span> istore_1 <span class="hljs-number">3</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt; <span class="hljs-number">6</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java/lang/StringBuilder&gt; <span class="hljs-number">9</span> dup<span class="hljs-number">10</span> invokespecial #<span class="hljs-number">5</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;<span class="hljs-number">13</span> ldc #<span class="hljs-number">6</span> &lt;count = &gt;<span class="hljs-number">15</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append&gt;<span class="hljs-number">18</span> iload_1<span class="hljs-number">19</span> invokevirtual #<span class="hljs-number">8</span> &lt;java/lang/StringBuilder.append&gt;<span class="hljs-number">22</span> invokevirtual #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder.toString&gt;<span class="hljs-number">25</span> invokevirtual #<span class="hljs-number">10</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">28</span> <span class="hljs-keyword">return</span></code></pre><p>1、#3，#5等等这些带# 的，都是引用了常量池。</p><p><strong>常量池总结</strong></p><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ol><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li>常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。（运行时常量池就是常量池在程序运行时的称呼）</li><li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li><li>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址</strong>。</li></ol><ul><li>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</li></ul><ol start="6"><li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</li></ol><h2 id="方法区的使用举例"><a href="#方法区的使用举例" class="headerlink" title="方法区的使用举例"></a>方法区的使用举例</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x / y;        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;        System.out.println(a + b);    &#125;&#125;</code></pre><p>字节码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java1.MethodAreaDemo  minor version: <span class="hljs-number">0</span>  major version: <span class="hljs-number">51</span>  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">5.</span>#<span class="hljs-number">24</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">25.</span>#<span class="hljs-number">26</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span>   #<span class="hljs-number">3</span> = Methodref          #<span class="hljs-number">27.</span>#<span class="hljs-number">28</span>        <span class="hljs-comment">// java/io/PrintStream.println:(I)V</span>   #<span class="hljs-number">4</span> = Class              #<span class="hljs-number">29</span>            <span class="hljs-comment">// com/atguigu/java1/MethodAreaDemo</span>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">30</span>            <span class="hljs-comment">// java/lang/Object</span>   #<span class="hljs-number">6</span> = Utf8               &lt;init&gt;   #<span class="hljs-number">7</span> = Utf8               ()V   #<span class="hljs-number">8</span> = Utf8               Code   #<span class="hljs-number">9</span> = Utf8               LineNumberTable  #<span class="hljs-number">10</span> = Utf8               LocalVariableTable  #<span class="hljs-number">11</span> = Utf8               <span class="hljs-built_in">this</span>  #<span class="hljs-number">12</span> = Utf8               Lcom/atguigu/java1/MethodAreaDemo;  #<span class="hljs-number">13</span> = Utf8               main  #<span class="hljs-number">14</span> = Utf8               ([Ljava/lang/String;)V  #<span class="hljs-number">15</span> = Utf8               args  #<span class="hljs-number">16</span> = Utf8               [Ljava/lang/String;  #<span class="hljs-number">17</span> = Utf8               x  #<span class="hljs-number">18</span> = Utf8               I  #<span class="hljs-number">19</span> = Utf8               y  #<span class="hljs-number">20</span> = Utf8               a  #<span class="hljs-number">21</span> = Utf8               b  #<span class="hljs-number">22</span> = Utf8               SourceFile  #<span class="hljs-number">23</span> = Utf8               MethodAreaDemo.java  #<span class="hljs-number">24</span> = NameAndType        #<span class="hljs-number">6</span>:#<span class="hljs-number">7</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span>  #<span class="hljs-number">25</span> = Class              #<span class="hljs-number">31</span>            <span class="hljs-comment">// java/lang/System</span>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">32</span>:#<span class="hljs-number">33</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span>  #<span class="hljs-number">27</span> = Class              #<span class="hljs-number">34</span>            <span class="hljs-comment">// java/io/PrintStream</span>  #<span class="hljs-number">28</span> = NameAndType        #<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// println:(I)V</span>  #<span class="hljs-number">29</span> = Utf8               com/atguigu/java1/MethodAreaDemo  #<span class="hljs-number">30</span> = Utf8               java/lang/Object  #<span class="hljs-number">31</span> = Utf8               java/lang/System  #<span class="hljs-number">32</span> = Utf8               out  #<span class="hljs-number">33</span> = Utf8               Ljava/io/PrintStream;  #<span class="hljs-number">34</span> = Utf8               java/io/PrintStream  #<span class="hljs-number">35</span> = Utf8               println  #<span class="hljs-number">36</span> = Utf8               (I)V&#123;  <span class="hljs-keyword">public</span> com.atguigu.java1.MethodAreaDemo();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/MethodAreaDemo;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: sipush        <span class="hljs-number">500</span>         <span class="hljs-number">3</span>: istore_1         <span class="hljs-number">4</span>: bipush        <span class="hljs-number">100</span>         <span class="hljs-number">6</span>: istore_2         <span class="hljs-number">7</span>: iload_1         <span class="hljs-number">8</span>: iload_2         <span class="hljs-number">9</span>: idiv        <span class="hljs-number">10</span>: istore_3        <span class="hljs-number">11</span>: bipush        <span class="hljs-number">50</span>        <span class="hljs-number">13</span>: istore        <span class="hljs-number">4</span>        <span class="hljs-number">15</span>: getstatic     #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>        <span class="hljs-number">18</span>: iload_3        <span class="hljs-number">19</span>: iload         <span class="hljs-number">4</span>        <span class="hljs-number">21</span>: iadd        <span class="hljs-number">22</span>: invokevirtual #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span>        <span class="hljs-number">25</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">10</span>: <span class="hljs-number">4</span>        line <span class="hljs-number">11</span>: <span class="hljs-number">7</span>        line <span class="hljs-number">12</span>: <span class="hljs-number">11</span>        line <span class="hljs-number">13</span>: <span class="hljs-number">15</span>        line <span class="hljs-number">14</span>: <span class="hljs-number">25</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>      <span class="hljs-number">26</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;            <span class="hljs-number">4</span>      <span class="hljs-number">22</span>     <span class="hljs-number">1</span>     x   I            <span class="hljs-number">7</span>      <span class="hljs-number">19</span>     <span class="hljs-number">2</span>     y   I           <span class="hljs-number">11</span>      <span class="hljs-number">15</span>     <span class="hljs-number">3</span>     a   I           <span class="hljs-number">15</span>      <span class="hljs-number">11</span>     <span class="hljs-number">4</span>     b   I&#125;SourceFile: <span class="hljs-string">&quot;MethodAreaDemo.java&quot;</span></code></pre><h4 id="图解字节码指令执行流程"><a href="#图解字节码指令执行流程" class="headerlink" title="图解字节码指令执行流程"></a>图解字节码指令执行流程</h4><p>1、初始状态</p><img src="/chapter_006/0012.png"><p>2、首先将操作数500压入操作数栈中</p><img src="/chapter_006/0013.png"><p>3、然后操作数 500 从操作数栈中取出，存储到局部变量表中索引为 1 的位置</p><img src="/chapter_006/0014.png"><p>4、</p><img src="/chapter_006/0015.png"><p>5、</p><img src="/chapter_006/0016.png"><p>6、</p><img src="/chapter_006/0017.png"><p>7、</p><img src="/chapter_006/0018.png"><p>8、</p><img src="/chapter_006/0019.png"><p>9、</p><img src="/chapter_006/0020.png"><p>10、</p><img src="/chapter_006/0021.png"><p>11、图片写错了是#25和#26（获得System类）</p><img src="/chapter_006/0022.png"><p>12、</p><img src="/chapter_006/0023.png"><p>13、</p><img src="/chapter_006/0024.png"><p>15、执行加法运算后，将计算结果放在操作数栈顶</p><img src="/chapter_006/0025.png"><p>16、就是真正的打印</p><img src="/chapter_006/0026.png"><p>17、</p><img src="/chapter_006/0027.png"><p><strong>符号引用 –&gt; 直接饮用</strong></p><ol><li>上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载</li><li>如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）</li></ol><h2 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h2><h3 id="永久代演进过程"><a href="#永久代演进过程" class="headerlink" title="永久代演进过程"></a>永久代演进过程</h3><ol><li><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p></li><li><p>Hotspot中方法区的变化：</p></li></ol><table><thead><tr><th>JDK1.6及以前</th><th>有永久代（permanent generation），静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，<strong>字符串常量池，静态变量移除，保存在堆中</strong></td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p><strong>JDK6</strong></p><p>方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p><img src="/chapter_006/0028.png"><p><strong>JDK7</strong></p><p>方法区由永久代实现，使用 JVM 虚拟机内存</p><img src="/chapter_006/0029.png"><p><strong>JDK8</strong></p><p>方法区由元空间实现，使用物理机本地内存</p><img src="/chapter_006/0030.png"><h3 id="永久代为什么要被元空间替代？"><a href="#永久代为什么要被元空间替代？" class="headerlink" title="永久代为什么要被元空间替代？"></a>永久代为什么要被元空间替代？</h3><blockquote><p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p></blockquote><ol><li>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</li><li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</li><li>这项改动是很有必要的，原因有：<ol><li>为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。<code>Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space</code>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</li><li>对永久代进行调优是很困难的。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低<strong>Full GC</strong><ol><li>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li><li>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻**。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</li></ol></li></ol></li></ol><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池 StringTable 为什么要调整位置？</strong></p><ul><li><p>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</p></li><li><p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p></li></ul><h3 id="静态变量放在哪里"><a href="#静态变量放在哪里" class="headerlink" title="静态变量放在哪里"></a>静态变量放在哪里</h3><h4 id="对象实体在哪里放着？"><a href="#对象实体在哪里放着？" class="headerlink" title="对象实体在哪里放着？"></a>对象实体在哪里放着？</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 结论：</span><span class="hljs-comment"> * 1、静态引用对应的对象实体(也就是这个new byte[1024 * 1024 * 100])始终都存在堆空间，</span><span class="hljs-comment"> * 2、只是那个变量(相当于下面的arr变量名)在JDK6,JDK7,JDK8存放位置中有所变化</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * jdk7：</span><span class="hljs-comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span><span class="hljs-comment"> * jdk 8：</span><span class="hljs-comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticFieldTest</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>];<span class="hljs-comment">//100MB</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(StaticFieldTest.arr);    &#125;&#125;</code></pre><p>JDK6环境下</p><img src="/chapter_006/0031.png" alt="image-20201113224231761" /><p>JDK7环境下</p><img src="/chapter_006/0032.png"><p>JDK8环境</p><img src="/chapter_006/0033.png"><h4 id="变量-名-存放在哪里？"><a href="#变量-名-存放在哪里？" class="headerlink" title="变量(名)存放在哪里？"></a>变量(名)存放在哪里？</h4><p>这个问题需要用JHSDB工具来进行分析，这个工具是JDK9开始自带的(JDK9以前没有)，在bin目录下可以找到</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.java1;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 《深入理解Java虚拟机》中的案例：</span><span class="hljs-comment"> * staticObj、instanceObj、localObj存放在哪里？</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticObjTest</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;        <span class="hljs-keyword">static</span> <span class="hljs-type">ObjectHolder</span> <span class="hljs-variable">staticObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectHolder</span>();        <span class="hljs-type">ObjectHolder</span> <span class="hljs-variable">instanceObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectHolder</span>();        <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;            <span class="hljs-type">ObjectHolder</span> <span class="hljs-variable">localObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectHolder</span>();            System.out.println(<span class="hljs-string">&quot;done&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectHolder</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticObjTest</span>.Test();        test.foo();    &#125;&#125;</code></pre><p><strong>JDK6环境下</strong></p><p>1、staticObj随着Test的类型信息存放在方法区</p><p>2、instanceObj随着Test的对象实例存放在Java堆</p><p>3、localObject则是存放在foo()方法栈帧的局部变量表中。</p><p>4、测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：<strong>只要是对象实例必然会在Java堆中分配</strong>。</p><img src="/chapter_006/0034.png"><blockquote><p>1、0x00007f32c7800000(Eden区的起始地址)    —-   0x00007f32c7b50000(Eden区的终止地址)  </p><p>2、可以发现三个变量都在这个范围内</p><p>3、所以可以得到上面结论</p></blockquote><p>5、接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p><img src="/chapter_006/0035.png"><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点</p><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><ol><li><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区<strong>类型卸载</strong>的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</p></li><li><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p></li><li><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p></li><li><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li><li><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p></li><li><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p></li></ol><p>下面也称作<strong>类卸载</strong></p><p>1、判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p></li><li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>2、Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX：+TraceClass-Loading</code>、<code>-XX：+TraceClassUnLoading</code>查看类加载和卸载信息</p><p>3、在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p><h2 id="运行时数据区总结"><a href="#运行时数据区总结" class="headerlink" title="运行时数据区总结"></a>运行时数据区总结</h2><img src="/chapter_006/0036.png"><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="直接内存概述"><a href="#直接内存概述" class="headerlink" title="直接内存概述"></a>直接内存概述</h3><ol><li><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p></li><li><p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p></li><li><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p></li><li><p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p></li><li><p>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</p></li><li><p>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</p></li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  IO                  NIO (New IO / Non-Blocking IO)</span><span class="hljs-comment"> *  byte[] / char[]     Buffer</span><span class="hljs-comment"> *  Stream              Channel</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 查看直接内存的占用与释放</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferTest</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BUFFER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<span class="hljs-comment">//1GB</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-comment">//直接分配本地内存空间</span>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(BUFFER);        System.out.println(<span class="hljs-string">&quot;直接内存分配完毕，请求指示！&quot;</span>);        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);        scanner.next();        System.out.println(<span class="hljs-string">&quot;直接内存开始释放！&quot;</span>);        byteBuffer = <span class="hljs-literal">null</span>;        System.gc();        scanner.next();    &#125;&#125;</code></pre><p>直接占用了 1G 的本地内存</p><img src="/chapter_006/0037.jpg"><h3 id="BIO-与-NIO"><a href="#BIO-与-NIO" class="headerlink" title="BIO 与 NIO"></a>BIO 与 NIO</h3><p><strong>非直接缓存区（BIO）</strong></p><p>原来采用BIO的架构，在读写本地文件时，我们需要从用户态切换成内核态</p><img src="/chapter_006/0038.png"><p><strong>直接缓冲区（NIO）</strong></p><p>NIO 直接操作物理磁盘，省去了中间过程</p><img src="/chapter_006/0039.png"><h3 id="直接内存与-OOM"><a href="#直接内存与-OOM" class="headerlink" title="直接内存与 OOM"></a>直接内存与 OOM</h3><ol><li><p>直接内存也可能导致OutofMemoryError异常</p></li><li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p></li><li><p>直接内存的缺点为：</p><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul></li><li><p>直接内存大小可以通过MaxDirectMemorySize设置</p></li><li><p>如果不指定，默认与堆的最大值-Xmx参数值一致</p></li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 本地内存的OOM:  OutOfMemoryError: Direct buffer memory</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferTest2</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BUFFER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">20</span>;<span class="hljs-comment">//20MB</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        ArrayList&lt;ByteBuffer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(BUFFER);                list.add(byteBuffer);                count++;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">100</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(count);        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Direct buffer memoryat java.nio.Bits.reserveMemory(Bits.java:<span class="hljs-number">694</span>)at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="hljs-number">123</span>)at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="hljs-number">311</span>)at com.atguigu.java.BufferTest2.main(BufferTest2.java:<span class="hljs-number">21</span>)</code></pre><img src="/chapter_006/0040.jpg"><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ol><li><p>百度</p><ul><li>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？<ul><li>jvm内存模型分为 方法区、堆空间、虚拟机栈、本地方法栈、pc寄存器。方法区用于存放类，方法去内部结构分为类型信息、域信息、方法信息、运行时常量池等。堆空间分为老年代，新生代，新生代分为edan区和from区和to区，用于存放对象信息，同时在jdk7之后，将静态变量的引用存放到java堆中。虚拟机栈存放线程运行时的存储空间，同时虚拟机栈还细分为本地变量表、动态链接、操作数栈、返回地址。本地变量表用于jvm运行c或者c++代码，让程序员无需关心这部分实现细节，仅仅只需要提供接口即可。pc寄存器这是存储线程下一次执行地址，方便jvm的执行。</li></ul></li></ul></li><li><p>蚂蚁金服：</p><ul><li>Java8的内存分代改进<ul><li>java8以前方法区中时永久代，8版本之后jvm采用了元空间来进行存储类信息</li></ul></li><li>一面：栈和堆的区别？堆的结构？为什么两个survivor区？<ul><li>堆主要用于存放数据 而栈主要进行数据的处理，但在虚拟机栈中 栈对线程运行时的数据进行存放</li><li>堆结构 <ul><li>Java 7：新生区+养老区+永久区<br>Java 8：新生区+养老区+元空间</li></ul></li><li>为了解决内存碎片化的问题，提高内存的使用率</li><li>为了解决内存的碎片化问题，提高内存的使用率。具体表现为，在进行一次Minor GC 的时候，Eden 区的存活对象会被复制的Survivor区S1（From 或 To）中，当触发第二次Minor GC 的时候，此时Eden 区的存活对象应该被复制到Survior区的S2（From 或 To）；同时将Survivor区S1中存活的对象也复制到S2区；当下一次再进行Minor GC 的时候，Eden区的存活对象就复制到空的S1区，这样循环往复。这样做的好处使得Survivor区的内存空间连续避免了碎片化。<br>而如果只有一个Survivor区的话，由于Survivor区的对象也有死亡掉的对象，没有被及时清除，这样从Eden区复制到Survivor区的对象就有了碎片化的间隙。降低了内存空间的使用效率。</li></ul></li><li>二面：Eden和survior的比例分配<ul><li>8：1：1</li></ul></li></ul></li><li><p>小米：</p><ul><li>jvm内存分区，为什么要有新生代和老年代<ul><li>研究发现在java中大部分都是临时对象，我们可以在新生代中存放初始对象，在老年代中存放多次gc后都能存活的对象，这样的分代可以优化gc性能，如果没有将对象分代，在gc的时候需要寻找那些对象没用，这样就需要将堆中所有的区域进行扫描。如果粉黛的话gc就可以直接将新创建的对象及逆行扫描回收，腾出很大一部分空间。</li></ul></li></ul></li><li><p>字节跳动：</p><ul><li>二面：讲讲vm运行时数据库区</li><li>什么时候对象会进入老年代？<ul><li>当对象很大无法在eden区直接放下，对象会直接进入老年代</li><li>在yungGc进行扫描后，to区无法存放下该对象，对象会直接进入老年代</li><li>如果一个类经过15次yungGC后任然没有被回收，该类进入老年代</li><li>如果Survivor区所有相同年龄对象的总和大于Survivor区的一半，年龄大于等于该年龄的对象直接进入老年代</li></ul></li></ul></li><li><p>京东：</p><ul><li>JVM的内存结构，Eden和Survivor比例。</li></ul></li><li><p>美团：</p><ul><li><p>jvm的永久代中会发生垃圾回收吗？</p><ul><li>方法区中的垃圾回收是很宽松的，在《Java虚拟机规范》中不要求虚拟机实现GC，事实上也确实存在虚拟机（有的）中方法区没有类卸机制。这是因为在方法区进行类卸载机制时很吃力不讨好的，在方法区堆类的回收是很苛刻的同时堆类的卸载又是很有必要的。方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</li></ul><p>方法区回收类的要求：</p><ul><li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p></li><li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;方法区&quot;&gt;&lt;a href=&quot;#方法区&quot; class=&quot;headerlink&quot; title=&quot;方法区&quot;&gt;&lt;/a&gt;方法区&lt;/h1&gt;&lt;h2 id=&quot;栈、堆、方法区的交互关系&quot;&gt;&lt;a href=&quot;#栈、堆、方法区的交互关系&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>5.JVM系列-堆</title>
    <link href="http://example.com/2023/03/25/5-JVM%E7%B3%BB%E5%88%97-%E5%A0%86/"/>
    <id>http://example.com/2023/03/25/5-JVM%E7%B3%BB%E5%88%97-%E5%A0%86/</id>
    <published>2023-03-25T09:21:28.000Z</published>
    <updated>2024-03-12T09:43:05.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><ol><li>HotSpot虚拟机上，所有的对象实例都是创建在堆上。</li></ol><h2 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h2><p>s0和s1满并不会触发GC回收器 当Eden区域满的事后就会自动将的from区的内容复制到to区去</p><p><strong>线程安全问题</strong>：我们可以看到，这里出现了两个26，为什么会出现这种情况，出现这种情况显然表明我们这个方法根本就不是线程安全的，出现这种问题的原因有很多，我们说最常见的一种，就是我们A线程在进入方法后，拿到了count的值，刚把这个值读取出来还没有改变count的值的时候，结果线程B也进来的，那么导致线程A和线程B拿到的count值是一样的。</p><h3 id="堆与进程"><a href="#堆与进程" class="headerlink" title="堆与进程"></a>堆与进程</h3><p>一个进程对应一个jvm实例 一个jvm实例使用一个运行时数据区</p><ol><li>堆针对一个JVM进程来说是唯一的。也就是<strong>一个进程只有一个JVM实例</strong>，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。</li><li>但是<span style="color:red"><strong>进程包含多个线程，他们是共享同一堆空间的</strong>。</span></li></ol><img src="\chapter_005\0001.png"><ol><li><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p></li><li><p><strong>Java堆区在JVM启动的时候即被创建</strong>，其空间大小也就确定了，堆是JVM管理的最大一块内存空间</p><blockquote><p>堆内存的大小是可以调节的。</p></blockquote></li><li><p>《Java虚拟机规范》规定，<span style="color:red">堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的</span>。</p><blockquote><p>逻辑上连续  实现上简单 直接分配一块连续空间 ，存储高效 执行的放一起。</p><p>物理上不连续 涉及到虚拟内存的问题  </p><p>这里涉及到对象实例在堆内存中的存储方式，物理内存连续的采用指针碰撞，不连续的采用动态列表</p></blockquote></li><li><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，<strong>TLAB</strong>）。</p><blockquote><p>tlab 如果所有的线程都共享同一个数据文件 势必会发生线程安全问题 可以使用他同步锁解决线程问题 但并发性很差 ，所以在堆空间中会划分出许多小空间 为每个线程分配一个空间 就是 TLAB</p></blockquote></li><li><p>《Java虚拟机规范》中对Java堆的描述是：**<span style="color:red">所有的对象实例</span>以及数组都应当在运行时分配在堆上**。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><ul><li>从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li></ul></li><li><p>数组和对象可能永远不会存储在栈上（<strong>不一定</strong>），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p></li><li><p><strong>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</strong></p><ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul></li><li><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p></li></ol><blockquote><p>随着JVM的迭代升级，原来一些绝对的事情，在后续版本中也开始有了特例，变的不再那么绝对。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleHeap</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<span class="hljs-comment">//属性、成员变量</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;My ID is &quot;</span> + id);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">SimpleHeap</span> <span class="hljs-variable">sl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleHeap</span>(<span class="hljs-number">1</span>);        <span class="hljs-type">SimpleHeap</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleHeap</span>(<span class="hljs-number">2</span>);        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];        Object[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];    &#125;&#125;</code></pre><img src="\chapter_005\0002.png"><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><blockquote><p>新生区&lt;&#x3D;&gt;新生代&lt;&#x3D;&gt;年轻代     养老区&lt;&#x3D;&gt;老年区 &lt;&#x3D;&gt;老年代      永久区&lt;&#x3D;&gt;永久代</p></blockquote><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p><ol><li>Java7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区<ul><li>Young Generation Space    新生区      Young&#x2F;New<ul><li>又被划分为Eden区和Survivor区</li></ul></li><li>Old generation space    养老区           Old&#x2F;Tenure</li><li>Permanent Space   永久区                   Perm</li></ul></li><li>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间<ul><li>Young Generation Space 新生区，又被划分为Eden区和Survivor区</li><li>Old generation space 养老区</li><li>Meta Space 元空间 Meta</li></ul></li></ol><img src="\chapter_005\0003.png"><ol start="2"><li>堆空间内部结构，JDK1.8之前从永久代 替换成 元空间</li></ol><img src="\chapter_005\0004.png"><h2 id="JVisualVM可视化查看堆内存"><a href="#JVisualVM可视化查看堆内存" class="headerlink" title="JVisualVM可视化查看堆内存"></a>JVisualVM可视化查看堆内存</h2><p>运行下面代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(<span class="hljs-string">&quot;start...&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            TimeUnit.MINUTES.sleep(<span class="hljs-number">30</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">&quot;end...&quot;</span>);    &#125;&#125;</code></pre><p>1、双击jdk目录下的这个文件</p><img src="\chapter_005\0005.png"><p>2、工具 -&gt; 插件 -&gt; 安装Visual GC插件</p><img src="\chapter_005\0006.png"><p>3、运行上面的代码</p><img src="\chapter_005\0007.png"><h2 id="设置堆内存大小与-OOM"><a href="#设置堆内存大小与-OOM" class="headerlink" title="设置堆内存大小与 OOM"></a>设置堆内存大小与 OOM</h2><h3 id="设置堆内存"><a href="#设置堆内存" class="headerlink" title="设置堆内存"></a>设置堆内存</h3><ol><li><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置。</p><ul><li><strong>-Xms</strong>用于表示堆区的起始内存  用来设置堆空间(年轻代+老年代)初始内存大小，等价于**-XX:InitialHeapSize**</li><li><strong>-Xmx</strong>则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**</li></ul></li><li><p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</p></li><li><p>通常会将-Xms和-Xmx两个参数配置相同的值</p></li></ol><ul><li>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。</li><li>如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM</li></ul><ol start="4"><li><p>默认情况下:</p><ul><li>初始内存大小：物理电脑内存大小&#x2F;64</li><li>最大内存大小：物理电脑内存大小&#x2F;4</li></ul></li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 1. 设置堆空间大小的参数</span><span class="hljs-comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span><span class="hljs-comment"> *      -X 是jvm的运行参数</span><span class="hljs-comment"> *      ms 是memory start</span><span class="hljs-comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 2. 默认堆空间的大小</span><span class="hljs-comment"> *    初始内存大小：物理电脑内存大小 / 64</span><span class="hljs-comment"> *             最大内存大小：物理电脑内存大小 / 4</span><span class="hljs-comment"> * 3. 手动设置：-Xms600m -Xmx600m</span><span class="hljs-comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span><span class="hljs-comment"> *                  方式二：-XX:+PrintGCDetails</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSpaceInitial</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//返回Java虚拟机中的堆内存总量</span>        <span class="hljs-type">long</span> <span class="hljs-variable">initialMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;        <span class="hljs-comment">//返回Java虚拟机试图使用的最大堆内存量</span>        <span class="hljs-type">long</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;        System.out.println(<span class="hljs-string">&quot;-Xms : &quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);        System.out.println(<span class="hljs-string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);        System.out.println(<span class="hljs-string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="hljs-number">64.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);        System.out.println(<span class="hljs-string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="hljs-number">4.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="hljs java">-Xms : 123M-Xmx : 1794M系统内存大小为：<span class="hljs-number">7.</span>6875G系统内存大小为：<span class="hljs-number">7.</span>0078125G</code></pre><p>两个不一样的原因待会再说</p><p>设置下参数再看</p><img src="\chapter_005\0008.png"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSpaceInitial</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//返回Java虚拟机中的堆内存总量</span>        <span class="hljs-type">long</span> <span class="hljs-variable">initialMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;        <span class="hljs-comment">//返回Java虚拟机试图使用的最大堆内存量</span>        <span class="hljs-type">long</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;        System.out.println(<span class="hljs-string">&quot;-Xms : &quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);        System.out.println(<span class="hljs-string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="hljs java">-Xms : 575M-Xmx : 575M</code></pre><p>为什么会少25M</p><p><strong>方式一： jps   &#x2F;  jstat -gc 进程id</strong></p><img src="\chapter_005\0009.png"><blockquote><p>jps：查看java进程</p><p>jstat：查看某进程内存使用情况</p></blockquote><pre><code class="hljs java">SOC: S0区总共容量S1C: S1区总共容量S0U: S0区使用的量S1U: S1区使用的量EC: 伊甸园区总共容量EU: 伊甸园区使用的量OC: 老年代总共容量OU: 老年代使用的量</code></pre><p>1、</p><p>25600+25600+153600+409600 &#x3D; 614400K</p><p>614400 &#x2F;1024 &#x3D; 600M</p><p>2、</p><p>25600+153600+409600 &#x3D; 588800K</p><p>588800 &#x2F;1024 &#x3D; 575M</p><p>3、</p><p>并非巧合，S0区和S1区两个只有一个能使用，另一个用不了（后面会详解）</p><p> <strong>方式二：-XX:+PrintGCDetails</strong></p><img src="\chapter_005\0010.png"><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        ArrayList&lt;Picture&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">20</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Picture</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)));        &#125;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Picture</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] pixels;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Picture</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span> &#123;        <span class="hljs-built_in">this</span>.pixels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];    &#125;&#125;</code></pre><p>1、设置虚拟机参数</p><p><code>-Xms600m -Xmx600m</code></p><p>最终输出结果：</p><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap spaceat com.atguigu.java.Picture.&lt;init&gt;(OOMTest.java:<span class="hljs-number">29</span>)at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="hljs-number">20</span>)Process finished with exit code <span class="hljs-number">1</span></code></pre><p>2、堆内存变化图</p><img src="\chapter_005\0011.png"><p>3、原因：大对象导致堆内存溢出</p><img src="\chapter_005\0012.png"><h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>1、存储在JVM中的Java对象可以被划分为两类：</p><pre><code>- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</code></pre><p>2、Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>3、其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p><blockquote><p>谁空谁是to区</p></blockquote><img src="\chapter_005\0013.png"><img src="\chapter_005\0014.png"><ul><li><p>配置新生代与老年代在堆结构的占比</p><ul><li><p>默认**-XX:NewRatio**&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p></li><li><p>可以修改**-XX:NewRatio**&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p></li></ul></li></ul><ol><li><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，</p></li><li><p>当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio&#x3D;8</p></li><li><p>几乎所有的Java对象都是在Eden区被new出来的。</p></li><li><p>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p></li><li><p>可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</p></li></ol><img src="\chapter_005\0015.png"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * -Xms600m -Xmx600m</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.</span><span class="hljs-comment"> * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8</span><span class="hljs-comment"> * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）</span><span class="hljs-comment"> * -Xmn:设置新生代的空间的大小。 （一般不设置）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart  shkstart@126.com</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020  17:23</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EdenSurvivorTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(<span class="hljs-string">&quot;我只是来打个酱油~&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><p><strong>具体过程</strong></p><ol><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</li><li>然后将伊甸园中的剩余对象移动到幸存者0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：**-XX:MaxTenuringThreshold**&#x3D;N 进行设置</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ol><img src="\chapter_005\0019.png"><h3 id="图解对象分配（一般情况）"><a href="#图解对象分配（一般情况）" class="headerlink" title="图解对象分配（一般情况）"></a>图解对象分配（一般情况）</h3><p>1、我们创建的对象，一般都是存放在Eden区的，<strong>当我们Eden区满了后，就会触发GC操作</strong>，一般被称为 YGC &#x2F; Minor GC操作</p><img src="\chapter_005\0016.png"><p>2、当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</p><p>3、同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To（S1）区，同时让存活的对象年龄 + 1</p><blockquote><p>下一次再进行GC的时候，</p><p>1、这一次的s0区为空，所以成为下一次GC的S1区</p><p>2、这一次的s1区则成为下一次GC的S0区</p><p>3、也就是说s0区和s1区在互相转换。</p></blockquote><img src="\chapter_005\0017.png"><p>4、我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中</p><img src="\chapter_005\0018.png"><p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</p><h3 id="特殊情况说明"><a href="#特殊情况说明" class="headerlink" title="特殊情况说明"></a>特殊情况说明</h3><p><strong>对象分配的特殊情况</strong></p><ol><li>如果来了一个新对象，先看看 Eden 是否放的下？<ul><li>如果 Eden 放得下，则直接放到 Eden 区</li><li>如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？</li></ul></li><li>将对象放到老年区又有两种情况：<ul><li>如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代</li><li>那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM</li></ul></li><li>如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区</li></ol><img src="\chapter_005\0019.png"><h3 id="常用调优工具"><a href="#常用调优工具" class="headerlink" title="常用调优工具"></a>常用调优工具</h3><ol><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控，推荐）</li><li>Jprofiler（IDEA插件）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ol><h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><ol><li><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，<strong>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</strong></p><blockquote><p>Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p></blockquote></li><li><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p></li></ol><ul><li><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li><strong>新生代收集</strong>（Minor GC&#x2F;Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</li><li><strong>老年代收集</strong>（Major GC&#x2F;Old GC）：只是老年代的圾收集。</li><li>目前，只有CMS GC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li></ul></li><li><p><strong>整堆收集</strong>（Full GC）：收集整个java堆和方法区的垃圾收集。</p></li></ul><blockquote><p>由于历史原因，外界各种解读，majorGC和Full GC有些混淆。</p></blockquote><h3 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h3><p><strong>年轻代 GC（Minor GC）触发机制</strong></p><ol><li><p>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满。Survivor满不会主动引发GC，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）</p></li><li><p>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p></li><li><p>Minor GC会引发STW（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p></li></ol><img src="\chapter_005\0020.png"><h3 id="Major-Full-GC"><a href="#Major-Full-GC" class="headerlink" title="Major&#x2F;Full GC"></a>Major&#x2F;Full GC</h3><blockquote><p>Full GC有争议，后续详解两者区别，暂时先看着</p></blockquote><p><strong>老年代GC（MajorGC）触发机制</strong></p><ol><li><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p></li><li><p>出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发Minor GC（哈？我有点迷？），如果之后空间还不足，则触发Major GC</li></ul></li><li><p>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</p></li><li><p>如果Major GC后，内存还不足，就报OOM了</p></li></ol><p><strong>Full GC 触发机制（后面细讲）</strong></p><p><strong>触发Full GC执行的情况有如下五种：</strong></p><ol><li>调用System.gc()时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><p>说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些</p><h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 测试MinorGC 、 MajorGC、FullGC</span><span class="hljs-comment"> * -Xms9m -Xmx9m -XX:+PrintGCDetails</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart  shkstart@126.com</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020  14:19</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();            <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.com&quot;</span>;            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                list.add(a);                a = a + a;                i++;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            t.printStackTrace();            System.out.println(<span class="hljs-string">&quot;遍历次数为：&quot;</span> + i);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="hljs-number">0.0455865</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.06</span> secs] [GC (Allocation Failure) [PSYoungGen: 2246K-&gt;496K(2560K)] 2470K-&gt;1506K(9728K), <span class="hljs-number">0.0009094</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] [GC (Allocation Failure) [PSYoungGen: 2294K-&gt;488K(2560K)] 3305K-&gt;2210K(9728K), <span class="hljs-number">0.0009568</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] [GC (Allocation Failure) [PSYoungGen: 1231K-&gt;488K(2560K)] 7177K-&gt;6434K(9728K), <span class="hljs-number">0.0005594</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] [GC (Allocation Failure) [PSYoungGen: 488K-&gt;472K(2560K)] 6434K-&gt;6418K(9728K), <span class="hljs-number">0.0005890</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] [Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(Allocation Failure)</span> [PSYoungGen: 472K-&gt;0K(2560K)] [ParOldGen: 5946K-&gt;4944K(7168K)] 6418K-&gt;4944K(9728K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="hljs-number">0.0045270</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 4944K-&gt;4944K(8704K), <span class="hljs-number">0.0004954</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] [Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(Allocation Failure)</span> java.lang.OutOfMemoryError: Java heap spaceat java.util.Arrays.copyOf(Arrays.java:<span class="hljs-number">3332</span>)at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="hljs-number">124</span>)at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="hljs-number">448</span>)at java.lang.StringBuilder.append(StringBuilder.java:<span class="hljs-number">136</span>)at com.atguigu.java1.GCTest.main(GCTest.java:<span class="hljs-number">20</span>)[PSYoungGen: 0K-&gt;0K(1536K)] [ParOldGen: 4944K-&gt;4877K(7168K)] 4944K-&gt;4877K(8704K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="hljs-number">0.0076061</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.02</span>, real=<span class="hljs-number">0.01</span> secs] 遍历次数为：<span class="hljs-number">16</span>Heap PSYoungGen      total 1536K, used 60K [<span class="hljs-number">0x00000000ffd00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)  eden space 1024K, <span class="hljs-number">5</span>% used [<span class="hljs-number">0x00000000ffd00000</span>,<span class="hljs-number">0x00000000ffd0f058</span>,<span class="hljs-number">0x00000000ffe00000</span>)  from space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x0000000100000000</span>)  to   space 1024K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ffe00000</span>,<span class="hljs-number">0x00000000ffe00000</span>,<span class="hljs-number">0x00000000fff00000</span>) ParOldGen       total 7168K, used 4877K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ffd00000</span>, <span class="hljs-number">0x00000000ffd00000</span>)  object space 7168K, <span class="hljs-number">68</span>% used [<span class="hljs-number">0x00000000ff600000</span>,<span class="hljs-number">0x00000000ffac3408</span>,<span class="hljs-number">0x00000000ffd00000</span>) Metaspace       used 3525K, capacity 4502K, committed 4864K, reserved 1056768K  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 391K, capacity 394K, committed 512K, reserved 1048576K</code></pre><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="hljs-number">0.0455865</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.06</span> secs] </code></pre><ul><li><p>[PSYoungGen: 2037K-&gt;504K(2560K)]：年轻代总空间为 2560K ，当前占用 2037K ，经过垃圾回收后剩余504K</p></li><li><p>2037K-&gt;728K(9728K)：堆内存总空间为 9728K ，当前占用2037K ，经过垃圾回收后剩余728K</p></li></ul><h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p>为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><ul><li>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to或s0&#x2F;s1）构成，to总为空。</li><li>老年代：存放新生代中经历多次GC仍然存活的对象。</li></ul><img src="\chapter_005\0021.png"><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。</p><ul><li>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。（性能低）</li></ul><ul><li>而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）</li></ul><img src="\chapter_005\0022.png"><h2 id="对象内存分配策略"><a href="#对象内存分配策略" class="headerlink" title="对象内存分配策略"></a>对象内存分配策略</h2><ol><li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。</li><li>对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</li><li>对象晋升老年代的年龄阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置</li></ol><p><strong>针对不同年龄段的对象分配原则如下所示：</strong></p><ol><li><strong>优先分配到Eden</strong>：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li><li><strong>大对象直接分配到老年代</strong>：尽量避免程序中出现过多的大对象</li><li><strong>长期存活的对象分配到老年代</strong></li><li><strong>动态对象年龄判断</strong>：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li><li><strong>空间分配担保</strong>： -XX:HandlePromotionFailure 。</li><li>如果对象过大，比eden空间的分配内存大小还要大，那么s1 s0 空间也必然不足，对象会直接进入老年代，不会经过YGC的垃圾回收</li></ol><blockquote><p>一些细节放在后面说</p></blockquote><h2 id="TLAB为对象分配内存（保证线程安全）"><a href="#TLAB为对象分配内存（保证线程安全）" class="headerlink" title="TLAB为对象分配内存（保证线程安全）"></a>TLAB为对象分配内存（保证线程安全）</h2><h3 id="为什么有-TLAB"><a href="#为什么有-TLAB" class="headerlink" title="为什么有 TLAB"></a>为什么有 TLAB</h3><ol start="2"><li><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p></li><li><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p></li><li><p>为避免多个线程操作同一地址，需要使用<strong>加锁等机制</strong>，进而影响分配速度。</p><blockquote><p>至于为什么内存分配需要加锁，很简单，因为多线程可能竞争一块内存空间，而那一块内存只能分配给一个对象，加锁是乐观锁了,CAS+失败重试，提高性能，由此可见TLAB对性能提高更大 TLAB中的对象并不是私有的，这个技术只是为了解决在对给对象分配内存的时候，不需要加锁，普通的EDEN区分配是需要加锁的 TLAB在EDEN中，是可以被其它所有线程访问的，GC的时候也会被回收</p></blockquote></li></ol><h3 id="什么是-TLAB"><a href="#什么是-TLAB" class="headerlink" title="什么是 TLAB"></a>什么是 TLAB</h3><p>TLAB（Thread Local Allocation Buffer）</p><ol><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong>。</li><li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li><li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li></ol><img src="\chapter_005\0023.png"><p>1、每个线程都有一个TLAB空间</p><p>2、当一个线程的TLAB存满时，可以使用公共区域（蓝色）的</p><h3 id="TLAB再说明"><a href="#TLAB再说明" class="headerlink" title="TLAB再说明"></a>TLAB再说明</h3><ol><li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</p></li><li><p>在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。</p></li><li><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“**-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。</p></li><li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存。</p></li></ol><blockquote><p>1、哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，<strong>分配新的缓存区时才需要同步锁定</strong>                   —-这是《深入理解JVM》–第三版里说的</p><p>2、和这里讲的有点不同。我猜测说的意思是某一次分配，如果TLAB用完了，那么<strong>这一次</strong>先在Eden区直接分配。空闲下来后再加锁分配新的TLAB（TLAB内存较大，分配时间应该较长）</p><p>3、堆空间不都是共享的 存在tlab这样的私有空间</p></blockquote><p><strong>TLAB 分配过程</strong></p><img src="\chapter_005\0024.png"><h2 id="堆空间参数设置"><a href="#堆空间参数设置" class="headerlink" title="堆空间参数设置"></a>堆空间参数设置</h2><h3 id="常用参数设置"><a href="#常用参数设置" class="headerlink" title="常用参数设置"></a>常用参数设置</h3><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p>我们只说常用的</p></blockquote><pre><code class="hljs java">* 测试堆空间常用的jvm参数：* -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值* -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）*      具体查看某个参数的指令： jps：查看当前运行中的进程*                             jinfo -flag SurvivorRatio 进程id** -Xms：初始堆空间内存 （默认为物理内存的<span class="hljs-number">1</span>/<span class="hljs-number">64</span>）* -Xmx：最大堆空间内存（默认为物理内存的<span class="hljs-number">1</span>/<span class="hljs-number">4</span>）* -Xmn：设置新生代的大小。(初始值及最大值)* -XX:NewRatio：配置新生代与老年代在堆结构的占比    新生代区域过小，导致YGC频繁调用 占用用户线程 导致STW总体时间变多* -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例   Eden区域过大 意味着s0和s1区域过小，很容易发生s1和s0区域无法存放类 只能直接将类存放到老年代中使得MinorGC数去意义* -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄  默认<span class="hljs-number">15</span>* -XX:+PrintGCDetails：输出详细的GC处理日志* 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc* -XX:HandlePromotionFailure：是否设置空间分配担保</code></pre><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>1、在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p><ul><li><p>如果大于，则此次Minor GC是安全的</p></li><li><p>如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。</p><ul><li>如果HandlePromotionFailure&#x3D;true，那么会继续检查<strong>老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则进行一次Full GC。</li></ul></li><li>如果HandlePromotionFailure&#x3D;false，则进行一次Full GC。</li></ul></li></ul><p><strong>历史版本</strong></p><ol><li>在JDK6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。</li><li>JDK6 Update 24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC</strong>，否则将进行Full GC。即 HandlePromotionFailure&#x3D;true</li></ol><h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><p><strong>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</strong></p><ol><li><p>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p></li><li><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><blockquote><p>没有发生逃逸对象分析的对象 可以分配到栈上 随着方法的结束栈空间被移除</p></blockquote></li><li><p>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p></li></ol><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><ol><li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li><li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li><li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li><li>逃逸分析的基本行为就是分析对象动态作用域：<ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></li></ol><p><strong>逃逸分析举例</strong></p><p>1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">my_method</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">V</span>();    <span class="hljs-comment">// use v</span>    <span class="hljs-comment">// ....</span>    v = <span class="hljs-literal">null</span>;&#125;</code></pre><p>2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();    sb.append(s1);    sb.append(s2);    <span class="hljs-keyword">return</span> sb;&#125;</code></pre><p>3、如果想要StringBuffer sb不发生逃逸，可以这样写</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();    sb.append(s1);    sb.append(s2);    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 逃逸分析</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EscapeAnalysis</span> &#123;    <span class="hljs-keyword">public</span> EscapeAnalysis obj;    <span class="hljs-comment">/*</span><span class="hljs-comment">    方法返回EscapeAnalysis对象，发生逃逸</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> EscapeAnalysis <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> obj == <span class="hljs-literal">null</span>? <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>() : obj;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">    为成员属性赋值，发生逃逸</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObj</span><span class="hljs-params">()</span>&#123;        <span class="hljs-built_in">this</span>.obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();    &#125;    <span class="hljs-comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">    引用成员变量的值，发生逃逸</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis1</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> getInstance();        <span class="hljs-comment">//getInstance().xxx()同样会发生逃逸 </span>        <span class="hljs-comment">// 关心得对象实体 在getInstance()里面存在隐藏得this.obj = new EscapeAnalysis()；</span>    &#125;&#125;</code></pre><p><strong>逃逸分析参数设置</strong></p><ol><li><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p></li><li><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析</li><li>通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul></li></ol><p><strong>总结</strong></p><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ol><li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li><strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ol><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ol><li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有<strong>逃逸出方法</strong>的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li><li>常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li></ol><p><strong>栈上分配举例</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 栈上分配测试</span><span class="hljs-comment"> * -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackAllocation</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;            alloc();        &#125;        <span class="hljs-comment">// 查看执行时间</span>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        System.out.println(<span class="hljs-string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);        <span class="hljs-comment">// 为了方便查看堆内存中对象个数，线程sleep</span>        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e1) &#123;            e1.printStackTrace();        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<span class="hljs-comment">//未发生逃逸</span>    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="hljs plaintext">[GC (Allocation Failure) [PSYoungGen: 33280K-&gt;808K(38400K)] 33280K-&gt;816K(125952K), 0.0483350 secs] [Times: user=0.00 sys=0.00, real=0.06 secs] [GC (Allocation Failure) [PSYoungGen: 34088K-&gt;808K(38400K)] 34096K-&gt;816K(125952K), 0.0008411 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 34088K-&gt;792K(38400K)] 34096K-&gt;800K(125952K), 0.0008427 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 34072K-&gt;808K(38400K)] 34080K-&gt;816K(125952K), 0.0012223 secs] [Times: user=0.08 sys=0.00, real=0.00 secs] 花费的时间为： 114 ms</code></pre><p>1、JVM 参数设置</p><p>-Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</p><p>2、日志打印：发生了 GC ，耗时 114ms</p><p><strong>开启逃逸分析的情况</strong></p><p>输出结果：</p><pre><code class="hljs plaintext">花费的时间为： 5 ms</code></pre><p>1、参数设置</p><p>-Xmx128m -Xms128m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</p><p>2、日志打印：并没有发生 GC ，耗时5ms 。</p><h3 id="同步省略（同步消除）"><a href="#同步省略（同步消除）" class="headerlink" title="同步省略（同步消除）"></a>同步省略（同步消除）</h3><ol><li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p></li><li><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。</p></li><li><p>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个<strong>取消同步的过程就叫同步省略，也叫锁消除</strong>。</p></li></ol><p>例如下面的代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">Object</span> <span class="hljs-variable">hollis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();    <span class="hljs-keyword">synchronized</span>(hollis) &#123;        System.out.println(hollis);    &#125;&#125;</code></pre><p>代码中对hollis这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">Object</span> <span class="hljs-variable">hellis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();System.out.println(hellis);&#125;</code></pre><p><strong>字节码分析</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Object</span> <span class="hljs-variable">hollis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();        <span class="hljs-keyword">synchronized</span>(hollis) &#123;            System.out.println(hollis);        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java/lang/Object&gt; <span class="hljs-number">3</span> dup <span class="hljs-number">4</span> invokespecial #<span class="hljs-number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt; <span class="hljs-number">7</span> astore_1 <span class="hljs-number">8</span> aload_1 <span class="hljs-number">9</span> dup<span class="hljs-number">10</span> astore_2<span class="hljs-number">11</span> monitorenter<span class="hljs-number">12</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<span class="hljs-number">15</span> aload_1<span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">19</span> aload_2<span class="hljs-number">20</span> monitorexit<span class="hljs-number">21</span> goto <span class="hljs-number">29</span> (+<span class="hljs-number">8</span>)<span class="hljs-number">24</span> astore_3<span class="hljs-number">25</span> aload_2<span class="hljs-number">26</span> monitorexit<span class="hljs-number">27</span> aload_3<span class="hljs-number">28</span> athrow<span class="hljs-number">29</span> <span class="hljs-keyword">return</span></code></pre><p>注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，<strong>同步省略操作是在解释运行时发生的</strong></p><h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p><strong>分离对象或标量替换</strong></p><ol><li>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li><li>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li><li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</li></ol><p>重点关注标量替换和栈上分配 这两个的触发条件一样 ，都是外界没有进行访问方法内的数据，标量替换是将集合聚合量替换成标量，栈上分配是将对象存储到栈上。</p><p><strong>标量替换举例</strong></p><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;    alloc();&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">Point</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);    System.out.println(<span class="hljs-string">&quot;point.x&quot;</span> + point.x + <span class="hljs-string">&quot;;point.y&quot;</span> + point.y);&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> y;&#125;</code></pre><p>以上代码，经过标量替换后，就会变成</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;    System.out.println(<span class="hljs-string">&quot;point.x = &quot;</span> + x + <span class="hljs-string">&quot;; point.y=&quot;</span> + y);&#125;</code></pre><ol><li>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。</li><li>那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</li><li>标量替换为栈上分配提供了很好的基础。</li></ol><p><strong>标量替换参数设置</strong></p><p>参数 -XX:+ElimilnateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p><p><strong>代码示例</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 标量替换测试</span><span class="hljs-comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart  shkstart@126.com</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020  12:01</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScalarReplace</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;        <span class="hljs-keyword">public</span> String name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<span class="hljs-comment">//未发生逃逸</span>        u.id = <span class="hljs-number">5</span>;        u.name = <span class="hljs-string">&quot;www.atguigu.com&quot;</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;            alloc();        &#125;        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        System.out.println(<span class="hljs-string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);    &#125;&#125;</code></pre><p><strong>未开启标量替换</strong></p><p>1、JVM 参数</p><p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</p><p>2、日志</p><pre><code class="hljs java">[GC (Allocation Failure)  25600K-&gt;880K(98304K), <span class="hljs-number">0.0012658</span> secs][GC (Allocation Failure)  26480K-&gt;832K(98304K), <span class="hljs-number">0.0012124</span> secs][GC (Allocation Failure)  26432K-&gt;784K(98304K), <span class="hljs-number">0.0009719</span> secs][GC (Allocation Failure)  26384K-&gt;832K(98304K), <span class="hljs-number">0.0009071</span> secs][GC (Allocation Failure)  26432K-&gt;768K(98304K), <span class="hljs-number">0.0010643</span> secs][GC (Allocation Failure)  26368K-&gt;824K(101376K), <span class="hljs-number">0.0012354</span> secs][GC (Allocation Failure)  32568K-&gt;712K(100864K), <span class="hljs-number">0.0011291</span> secs][GC (Allocation Failure)  32456K-&gt;712K(100864K), <span class="hljs-number">0.0006368</span> secs]花费的时间为： <span class="hljs-number">99</span> ms</code></pre><p><strong>开启标量替换</strong></p><p>1、JVM 参数</p><p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</p><p>2、日志：时间减少很多，且无GC</p><pre><code class="hljs plaintext">花费的时间为： 6 ms</code></pre><p>上述代码在主函数中调用了1亿次alloc()方法，进行对象创建由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><p><code>-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></p><p>这里设置参数如下：</p><ol><li>参数 -server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li><li>参数 -XX:+DoEscapeAnalysis：启用逃逸分析</li><li>参数 -Xmx10m：指定了堆空间最大为10MB</li><li>参数 -XX:+PrintGC：将打印GC日志。</li><li>参数 -XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ol><h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><ol><li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li><li>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</li><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li><li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，<strong>Oracle Hotspot JVM中并未这么做</strong>（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，<strong>所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上</strong>。</li><li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，<strong>所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</strong>。</li></ol><blockquote><p><strong>堆是分配对象的唯一选择么？ 不是 但是hotspot中确实是所有的对象都在堆上</strong></p></blockquote><p>综上：<strong>对象实例都是分配在堆上</strong>。What the fuck？</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p></li><li><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。</p></li><li><p>当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；</p></li><li><p>如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；</p></li><li><p>如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</p></li><li><p>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</p></li><li><p>当GC发生在老年代时则被称为Major GC或者Full GC。</p></li><li><p>一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;HotSpot虚拟机上，所有的对象实例都是创建在堆上。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;堆的核心概述&quot;&gt;&lt;a href=&quot;#堆的核</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>4.JVM系列-虚拟机栈</title>
    <link href="http://example.com/2023/03/21/4-JVM%E7%B3%BB%E5%88%97-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>http://example.com/2023/03/21/4-JVM%E7%B3%BB%E5%88%97-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</id>
    <published>2023-03-21T05:21:09.000Z</published>
    <updated>2024-03-12T09:34:51.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>没有gc有oom</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="虚拟机栈的出现背景"><a href="#虚拟机栈的出现背景" class="headerlink" title="虚拟机栈的出现背景"></a>虚拟机栈的出现背景</h3><ol><li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li><li>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li></ol><h3 id="虚拟机作用"><a href="#虚拟机作用" class="headerlink" title="虚拟机作用"></a>虚拟机作用</h3><p><span style="color:red"><strong>每个线程运行所需要的内存成为虚拟机栈。</strong></span></p><h3 id="内存中的栈与堆"><a href="#内存中的栈与堆" class="headerlink" title="内存中的栈与堆"></a>内存中的栈与堆</h3><ol><li><span style="color:red">首先栈是运行时的单位，而堆是存储的单位。</span><ol><li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li><li>但栈也能存储一些简单的数据 像方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回</li></ol></li></ol><img src="\chapter_004\0001.png"><h3 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a>虚拟机栈基本内容</h3><ul><li><p>Java虚拟机栈是什么？</p><ul><li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，<span style="color:rgb(48, 130, 254)">其内部保存一个个的栈帧（Stack Frame）</span>，<strong>对应着一次次的Java方法调用</strong>，<span style="color:rgb(48, 130, 254)">虚拟机栈是线程私有的</span></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">StackTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StackTest</span>();        test.methodA();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;        methodB();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;    &#125;&#125;</code></pre></li></ul><img src="\chapter_004\0002.png"><ul><li><strong>虚拟机栈的生命周期</strong><ul><li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li></ul></li><li><strong>虚拟机栈的作用</strong><ul><li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li><li>引用对象本身在堆空间存储</li></ul></li></ul><h3 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h3><ul><li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p></li><li><p>JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li><p>对于栈来说不存在垃圾回收问题</p><ul><li><strong>栈不需要GC，但是可能存在OOM</strong></li></ul></li></ul><img src="\chapter_004\0003.png"><h3 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a>虚拟机栈的异常</h3><p><strong>面试题：栈中可能出现的异常？</strong></p><ul><li><p><strong>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的</strong>。</p></li><li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</p></li><li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</p></li></ul><h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>多去官方文档看看：<a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></p><p>地址经常变</p></blockquote><p>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><p>The following examples set the thread stack size to 1024 KB in different units:</p><pre><code class="hljs java">-Xss1m-Xss1024k-Xss1048576</code></pre><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackErrorTest</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(count);        count++;        main(args);    &#125;&#125;</code></pre><p><strong>没设置参数前</strong></p><p>部分输出结果：</p><pre><code class="hljs java"><span class="hljs-number">11404</span><span class="hljs-number">11405</span><span class="hljs-number">11406</span>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowErrorat sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:<span class="hljs-number">691</span>)</code></pre><p>说明栈在11406这个深度溢出了</p><p><strong>设置栈参数之后</strong></p><img src="\chapter_004\0004.png"><p>部分输出结果</p><pre><code class="hljs java"><span class="hljs-number">2474</span><span class="hljs-number">2475</span><span class="hljs-number">2476</span>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowErrorat sun.nio.cs.UTF_8.updatePositions(UTF_8.java:<span class="hljs-number">77</span>)</code></pre><p>说明参数起作用了</p><h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><ol><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ol><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><ol><li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</p></li><li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></p></li><li><p><strong>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</strong>。</p></li><li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li></ol><img src="\chapter_004\0005.png"><ol><li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ol><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li><p>局部变量表（Local Variables）</p></li><li><p>操作数栈（Operand Stack）（或表达式栈）</p></li><li><p>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</p></li><li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p></li><li><p>一些附加信息</p></li></ul><img src="\chapter_004\0006.png"><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈 决定的</p><img src="\chapter_004\0007.png"><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><h3 id="认识局部变量表"><a href="#认识局部变量表" class="headerlink" title="认识局部变量表"></a>认识局部变量表</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ol><li>局部变量表也被称之为局部变量数组或本地变量表</li><li>**定义为一个数字数组，<span style="color:red">主要用于存储方法参数和定义在方法体内的局部变量</span>**，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong><ul><li>在方法体中定义的但是被返回出去了的引用数据类型变量是线程不安全的，可能被接收到传递给其它线程使用</li><li>在方法体中定义的并且在方法体中消亡的引用数据类型变量是线程安全的，无法被其它线程使用</li><li>所有的基本数据类型局部变量都是线程安全的，当方法传参时传递的是变量值，不是变量。</li></ul></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li>局部变量表中的变量只在当前方法调用中有效。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ol><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVariablesTest</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">LocalVariablesTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariablesTest</span>();        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;        test.test1();    &#125;    <span class="hljs-comment">//练习：</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStatic</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">LocalVariablesTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariablesTest</span>();        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;        System.out.println(count);        <span class="hljs-comment">//因为this变量不存在于当前方法的局部变量表中！！</span><span class="hljs-comment">//        System.out.println(this.count);</span>    &#125;    <span class="hljs-comment">//关于Slot的使用的理解</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LocalVariablesTest</span><span class="hljs-params">()</span>&#123;        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();        <span class="hljs-type">String</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.com&quot;</span>;        test2(date, name1);        System.out.println(date + name1);    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">(Date dateP, String name2)</span> &#123;        dateP = <span class="hljs-literal">null</span>;        name2 = <span class="hljs-string">&quot;songhongkang&quot;</span>;        <span class="hljs-type">double</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> <span class="hljs-number">130.5</span>;<span class="hljs-comment">//占据两个slot</span>        <span class="hljs-type">char</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>;        <span class="hljs-keyword">return</span> dateP + name2;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.count++;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            b = a + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><img src="\chapter_004\0008.png"><p>看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。</p><h4 id="部分详解"><a href="#部分详解" class="headerlink" title="部分详解"></a>部分详解</h4><p>为了更好讲解，我们直接用jclasslib来看字节码，以main方法为例来讲解。一些一目了然的就不讲了</p><p>1、0-15  也就是有16行字节码</p><img src="\chapter_004\0009.png"><p>2、方法异常信息表</p><img src="\chapter_004\0010.png"><p>3、Misc</p><img src="\chapter_004\0011.png"><p>4、行号表</p><p>Java代码的行号和字节码指令行号的对应关系</p><img src="\chapter_004\0012.png"><p>5、注意：生效行数和剩余有效行数都是针对于字节码文件的行数</p><img src="\chapter_004\0013.png"><p>1、图中圈的东西表示该局部变量的作用域</p><p>2、Start PC&#x3D;&#x3D;11表示在字节码的11行开始生效，也就是Java代码对应的第15行。而声明int num在java代码的是第14行，说明是从声明的下一行开始生效</p><p>3、Length&#x3D;&#x3D; 5表示局部变量剩余有效行数，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 &#x3D;&#x3D;5。</p><ul><li>length就是对应变量作用域的范围</li></ul><p>4、<code>Ljava/lang/String</code>   前面的L表示引用类型</p><h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><ol><li>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li><li>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型 byte boolean char shot int  ），<strong>64位的类型占用两个slot</strong>（long和double）。<ul><li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true  (卧槽 c语言 )</li><li>long和double则占据两个slot</li></ul></li><li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</li></ol><img src="\chapter_004\0014.png"><h3 id="Slot代码示例"><a href="#Slot代码示例" class="headerlink" title="Slot代码示例"></a>Slot代码示例</h3><p><strong>this 存放在 index &#x3D; 0 的位置：</strong></p><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;       <span class="hljs-built_in">this</span>.count++;   &#125;</code></pre><p>局部变量表：this 存放在 index &#x3D; 0 的位置</p><img src="\chapter_004\0015.png"><p><strong>64位的类型（long和double）占用两个slot</strong></p><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">(Date dateP, String name2)</span> &#123;      dateP = <span class="hljs-literal">null</span>;      name2 = <span class="hljs-string">&quot;hcj&quot;</span>;      <span class="hljs-type">double</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> <span class="hljs-number">100.5</span>;<span class="hljs-comment">//占据两个slot</span>      <span class="hljs-type">char</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>;      <span class="hljs-keyword">return</span> dateP + name2;  &#125;</code></pre><p>weight 为 double 类型，index 直接从 3 蹦到了 5</p><img src="\chapter_004\0016.png"><p><strong>static 无法调用 this</strong></p><p>this 不存在与 static 方法的局部变量表中，所以无法调用</p><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStatic</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">LocalVariablesTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariablesTest</span>();        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;        System.out.println(count);        <span class="hljs-comment">//因为this变量不存在于当前方法的局部变量表中！！</span><span class="hljs-comment">//        System.out.println(this.count);</span>    &#125;</code></pre><h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h3><p><strong>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</strong></p><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        b = a + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;&#125;</code></pre><p>局部变量 c 重用了局部变量 b 的 slot 位置</p><img src="\chapter_004\0017.png"><h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><pre><code class="hljs java">变量的分类：<span class="hljs-number">1</span>、按照数据类型分：① 基本数据类型  ② 引用数据类型<span class="hljs-number">2</span>、按照在类中声明的位置分：  <span class="hljs-number">2</span>-<span class="hljs-number">1</span>、成员变量：在使用前，都经历过默认初始化赋值       <span class="hljs-number">2</span>-<span class="hljs-number">1</span>-<span class="hljs-number">1</span>、类变量: linking的prepare阶段：给类变量默认赋值              ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值       <span class="hljs-number">2</span>-<span class="hljs-number">1</span>-<span class="hljs-number">2</span>、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值  <span class="hljs-number">2</span>-<span class="hljs-number">2</span>、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</code></pre><ol><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li>我们知道成员变量有两次初始化的机会<strong>，</strong>第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了<em>局部变量则必须人为的初始化</em>，否则无法使用。</li></ol><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol><li><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p></li><li><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p></li></ol><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><h3 id="操作数栈的特点"><a href="#操作数栈的特点" class="headerlink" title="操作数栈的特点"></a>操作数栈的特点</h3><ol><li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</p></li><li><p>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</p></li></ol><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</li><li>比如：执行复制、交换、求和等操作</li></ul><img src="\chapter_004\0018.png"><img src="\chapter_004\0019.png"><h3 id="操作数栈的作用"><a href="#操作数栈的作用" class="headerlink" title="操作数栈的作用"></a>操作数栈的作用</h3><ol><li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p></li><li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</p></li><li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p></li><li><p>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</p></li></ol><img src="\chapter_004\0020.jpg"><p>局部变量表就相当于食材</p><p>操作数栈就相当于做法步骤</p><h2 id="操作数栈代码追踪"><a href="#操作数栈代码追踪" class="headerlink" title="操作数栈代码追踪"></a>操作数栈代码追踪</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddOperation</span><span class="hljs-params">()</span> &#123;       <span class="hljs-comment">//byte、short、char、boolean：都以int型来保存</span>       <span class="hljs-type">byte</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;       <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;       <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;      <span class="hljs-comment">// int m = 800;</span>   &#125;</code></pre><p>对应字节码指令</p><pre><code class="hljs java"> <span class="hljs-number">0</span> bipush <span class="hljs-number">15</span> <span class="hljs-number">2</span> istore_1 <span class="hljs-number">3</span> bipush <span class="hljs-number">8</span> <span class="hljs-number">5</span> istore_2 <span class="hljs-number">6</span> iload_1 <span class="hljs-number">7</span> iload_2 <span class="hljs-number">8</span> iadd <span class="hljs-number">9</span> istore_3<span class="hljs-number">10</span> <span class="hljs-keyword">return</span></code></pre><img src="\chapter_004\0021.png"><h3 id="一步一步看流程"><a href="#一步一步看流程" class="headerlink" title="一步一步看流程"></a>一步一步看流程</h3><p>1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p><img src="\chapter_004\0022.png"><p>2、<span style="color:green">执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了</span></p><ul><li>解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</li></ul><img src="\chapter_004\0023.png"><p>3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><img src="\chapter_004\0024.png"><p>4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行add操作</p><p>iload_1：取出局部变量表中索引为1的数据入操作数栈</p><img src="\chapter_004\0025.png"><p>5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p><img src="\chapter_004\0026.png"><h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><p><strong>关于类型转换的说明</strong></p><img src="\chapter_004\0027.png"><ul><li>因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8</li><li>但是存储在局部变量的时候，会转成 int 类型的变量：istore_4</li></ul><img src="\chapter_004\0028.png"><ul><li>m改成800之后，byte存储不了，就成了short型，sipush 800</li></ul><p><strong>如果被调用的方法带有返回值，返回值入操作数栈</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">()</span>&#123;      <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;      <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> m + n;      <span class="hljs-keyword">return</span> k;  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetSum</span><span class="hljs-params">()</span>&#123;      <span class="hljs-comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> getSum();      <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  &#125;</code></pre><p>getSum() 方法字节码指令：最后带着个 ireturn</p><img src="\chapter_004\0029.png"><p>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</p><img src="\chapter_004\0030.png"><h2 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h2><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ol><li><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读&#x2F;写次数多，效率不高。</p></li><li><p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></p></li><li><p>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</p></li></ol><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><ol><li><p>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</p></li><li><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p></li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicLinkingTest</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;methodA()....&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;methodB()....&quot;</span>);        methodA();        num++;    &#125;&#125;</code></pre><p>对应字节码</p><pre><code class="hljs java">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.<span class="hljs-keyword">class</span>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">10</span>; size <span class="hljs-number">712</span> bytes  MD5 checksum e56913c945f897c7ee6c0a608629bca8  Compiled from <span class="hljs-string">&quot;DynamicLinkingTest.java&quot;</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java1.DynamicLinkingTest  minor version: <span class="hljs-number">0</span>  major version: <span class="hljs-number">52</span>  flags: ACC_PUBLIC, ACC_SUPERConstant pool: <span class="hljs-comment">// 常量池</span>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">9.</span>#<span class="hljs-number">23</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">8.</span>#<span class="hljs-number">24</span>         <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest.num:I</span>   #<span class="hljs-number">3</span> = Fieldref           #<span class="hljs-number">25.</span>#<span class="hljs-number">26</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span>   #<span class="hljs-number">4</span> = String             #<span class="hljs-number">27</span>            <span class="hljs-comment">// methodA()....</span>   #<span class="hljs-number">5</span> = Methodref          #<span class="hljs-number">28.</span>#<span class="hljs-number">29</span>        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span>   #<span class="hljs-number">6</span> = String             #<span class="hljs-number">30</span>            <span class="hljs-comment">// methodB()....</span>   #<span class="hljs-number">7</span> = Methodref          #<span class="hljs-number">8.</span>#<span class="hljs-number">31</span>         <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest.methodA:()V</span>   #<span class="hljs-number">8</span> = Class              #<span class="hljs-number">32</span>            <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest</span>   #<span class="hljs-number">9</span> = Class              #<span class="hljs-number">33</span>            <span class="hljs-comment">// java/lang/Object</span>  #<span class="hljs-number">10</span> = Utf8               num  #<span class="hljs-number">11</span> = Utf8               I  #<span class="hljs-number">12</span> = Utf8               &lt;init&gt;  #<span class="hljs-number">13</span> = Utf8               ()V  #<span class="hljs-number">14</span> = Utf8               Code  #<span class="hljs-number">15</span> = Utf8               LineNumberTable  #<span class="hljs-number">16</span> = Utf8               LocalVariableTable  #<span class="hljs-number">17</span> = Utf8               <span class="hljs-built_in">this</span>  #<span class="hljs-number">18</span> = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;  #<span class="hljs-number">19</span> = Utf8               methodA  #<span class="hljs-number">20</span> = Utf8               methodB  #<span class="hljs-number">21</span> = Utf8               SourceFile  #<span class="hljs-number">22</span> = Utf8               DynamicLinkingTest.java  #<span class="hljs-number">23</span> = NameAndType        #<span class="hljs-number">12</span>:#<span class="hljs-number">13</span>        <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span>  #<span class="hljs-number">24</span> = NameAndType        #<span class="hljs-number">10</span>:#<span class="hljs-number">11</span>        <span class="hljs-comment">// num:I</span>  #<span class="hljs-number">25</span> = Class              #<span class="hljs-number">34</span>            <span class="hljs-comment">// java/lang/System</span>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span>  #<span class="hljs-number">27</span> = Utf8               <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>....  #<span class="hljs-number">28</span> = Class              #<span class="hljs-number">37</span>            <span class="hljs-comment">// java/io/PrintStream</span>  #<span class="hljs-number">29</span> = NameAndType        #<span class="hljs-number">38</span>:#<span class="hljs-number">39</span>        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span>  #<span class="hljs-number">30</span> = Utf8               <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>....  #<span class="hljs-number">31</span> = NameAndType        #<span class="hljs-number">19</span>:#<span class="hljs-number">13</span>        <span class="hljs-comment">// methodA:()V</span>  #<span class="hljs-number">32</span> = Utf8               com/atguigu/java1/DynamicLinkingTest  #<span class="hljs-number">33</span> = Utf8               java/lang/Object  #<span class="hljs-number">34</span> = Utf8               java/lang/System  #<span class="hljs-number">35</span> = Utf8               out  #<span class="hljs-number">36</span> = Utf8               Ljava/io/PrintStream;  #<span class="hljs-number">37</span> = Utf8               java/io/PrintStream  #<span class="hljs-number">38</span> = Utf8               println  #<span class="hljs-number">39</span> = Utf8               (Ljava/lang/String;)V&#123;  <span class="hljs-type">int</span> num;    descriptor: I    flags:  <span class="hljs-keyword">public</span> com.atguigu.java1.DynamicLinkingTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>         <span class="hljs-number">4</span>: aload_0         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span>         <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span>        <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">9</span>: <span class="hljs-number">4</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>      <span class="hljs-number">11</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String methodA()....</span>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">12</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">13</span>: <span class="hljs-number">8</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String methodB()....</span>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>         <span class="hljs-number">8</span>: aload_0         <span class="hljs-number">9</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method methodA:()V</span>        <span class="hljs-number">12</span>: aload_0        <span class="hljs-number">13</span>: dup        <span class="hljs-number">14</span>: getfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span>        <span class="hljs-number">17</span>: iconst_1        <span class="hljs-number">18</span>: iadd        <span class="hljs-number">19</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span>        <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">16</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">18</span>: <span class="hljs-number">8</span>        line <span class="hljs-number">20</span>: <span class="hljs-number">12</span>        line <span class="hljs-number">21</span>: <span class="hljs-number">22</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>      <span class="hljs-number">23</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;&#125;SourceFile: <span class="hljs-string">&quot;DynamicLinkingTest.java&quot;</span></code></pre><p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p><p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p><ul><li>先找 #8 ：<ul><li><code>#8 = Class #32</code> ：去找 #32</li><li><code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li><li>结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li></ul></li><li>再来找 #31：<ul><li><code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li><li><code>#19 = Utf8 methodA</code> ：方法名为 methodA</li><li><code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li></ul></li></ul><p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p><p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p><img src="\chapter_004\0031.png"><p><strong>为什么要用常量池呢？</strong></p><ol><li>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</li><li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li><li>减少内存使用 提高代码使用效率</li></ol><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><h3 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><strong>静态链接</strong>：</li></ul><p>当一个字节码文件被装载进JVM内部时，<span style="color:red">如果被调用的目标方法在编译期确定</span>，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程<span style="color:red">称之为静态链接</span></p><ul><li><strong>动态链接</strong>：</li></ul><p><span style="color:red">如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</span></p><h3 id="早期绑定与晚期绑定"><a href="#早期绑定与晚期绑定" class="headerlink" title="早期绑定与晚期绑定"></a>早期绑定与晚期绑定</h3><blockquote><p>静态链接与动态链接针对的是<span style="color:blue"><strong>方法</strong></span>。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p></blockquote><p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong></li></ul><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p><ul><li><strong>晚期绑定</strong></li></ul><p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;动物进食&quot;</span>);    &#125;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Huntable</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hunt</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Huntable</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;狗吃骨头&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hunt</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;捕食耗子，多管闲事&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Huntable</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">super</span>();<span class="hljs-comment">//表现为：早期绑定</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>();<span class="hljs-comment">//表现为：早期绑定</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">super</span>.eat();<span class="hljs-comment">//表现为：早期绑定</span>        System.out.println(<span class="hljs-string">&quot;猫吃鱼&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hunt</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;捕食耗子，天经地义&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showAnimal</span><span class="hljs-params">(Animal animal)</span> &#123;        animal.eat();<span class="hljs-comment">//表现为：晚期绑定</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showHunt</span><span class="hljs-params">(Huntable h)</span> &#123;        h.hunt();<span class="hljs-comment">//表现为：晚期绑定</span>    &#125;&#125;</code></pre><p>部分字节码</p><pre><code class="hljs java">&#123;  <span class="hljs-keyword">public</span> com.atguigu.java2.AnimalTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">54</span>: <span class="hljs-number">0</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java2/AnimalTest;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showAnimal</span><span class="hljs-params">(com.atguigu.java2.Animal)</span>;    descriptor: (Lcom/atguigu/java2/Animal;)V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">2</span>         <span class="hljs-number">0</span>: aload_1         <span class="hljs-number">1</span>: invokevirtual #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Method com/atguigu/java2/Animal.eat:()V</span>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">56</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">57</span>: <span class="hljs-number">4</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java2/AnimalTest;            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">1</span> animal   Lcom/atguigu/java2/Animal;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showHunt</span><span class="hljs-params">(com.atguigu.java2.Huntable)</span>;    descriptor: (Lcom/atguigu/java2/Huntable;)V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">2</span>         <span class="hljs-number">0</span>: aload_1         <span class="hljs-number">1</span>: invokeinterface #<span class="hljs-number">3</span>,  <span class="hljs-number">1</span>            <span class="hljs-comment">// InterfaceMethod com/atguigu/java2/Huntable.hunt:()V</span>         <span class="hljs-number">6</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">60</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">61</span>: <span class="hljs-number">6</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">7</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java2/AnimalTest;            <span class="hljs-number">0</span>       <span class="hljs-number">7</span>     <span class="hljs-number">1</span>     h   Lcom/atguigu/java2/Huntable;&#125;SourceFile: <span class="hljs-string">&quot;AnimalTest.java&quot;</span></code></pre><p>invokevirtual 体现为晚期绑定</p><p>invokeinterface 也体现为晚期绑定</p><p>invokespecial 体现为早期绑定</p><h3 id="多态与绑定"><a href="#多态与绑定" class="headerlink" title="多态与绑定"></a>多态与绑定</h3><ol><li><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p></li><li><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p></li></ol><h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><p><strong>虚方法与非虚方法的区别</strong></p><ol><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ol><p><strong>子类对象的多态的使用前提：</strong></p><ol><li>类的继承关系</li><li>方法的重写</li></ol><p><strong>虚拟机中调用方法的指令</strong></p><ul><li><strong>普通指令：</strong></li></ul><ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ol><ul><li><strong>动态调用指令</strong></li></ul><p>invokedynamic：动态解析出需要调用的方法，然后执行</p><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Father</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;father的构造器&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showStatic</span><span class="hljs-params">(String str)</span> &#123;        System.out.println(<span class="hljs-string">&quot;father &quot;</span> + str);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showFinal</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;father show final&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showCommon</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;father 普通方法&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Son</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//invokespecial</span>        <span class="hljs-built_in">super</span>();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Son</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;        <span class="hljs-comment">//invokespecial</span>        <span class="hljs-built_in">this</span>();    &#125;    <span class="hljs-comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showStatic</span><span class="hljs-params">(String str)</span> &#123;        System.out.println(<span class="hljs-string">&quot;son &quot;</span> + str);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showPrivate</span><span class="hljs-params">(String str)</span> &#123;        System.out.println(<span class="hljs-string">&quot;son private&quot;</span> + str);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//invokestatic</span>        showStatic(<span class="hljs-string">&quot;atguigu.com&quot;</span>);        <span class="hljs-comment">//invokestatic</span>        <span class="hljs-built_in">super</span>.showStatic(<span class="hljs-string">&quot;good!&quot;</span>);        <span class="hljs-comment">//invokespecial</span>        showPrivate(<span class="hljs-string">&quot;hello!&quot;</span>);        <span class="hljs-comment">//invokespecial</span>        <span class="hljs-built_in">super</span>.showCommon();        <span class="hljs-comment">//invokevirtual</span>        showFinal();<span class="hljs-comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span>        <span class="hljs-comment">//虚方法如下：</span>                <span class="hljs-comment">/*</span><span class="hljs-comment">        invokevirtual  你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也会认为)，所以编译期间确定不下来，就是虚方法。</span><span class="hljs-comment">        */</span>        showCommon();        info();        <span class="hljs-type">MethodInterface</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-comment">//invokeinterface</span>        in.methodA();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(Father f)</span> &#123;        f.showCommon();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Son</span> <span class="hljs-variable">so</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();        so.show();    &#125;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;&#125;</code></pre><p>Son 类中 show() 方法的字节码指令如下</p><img src="\chapter_004\0032.png"><p>当不想使用虚函数特征时 可以使用final来进行修饰，因为使用fianl修饰 该方法不能进行方法重写 即不能进行多态，就不能进行动态绑定<br>总结：指针不确定的情况下，可以认为是动态绑定，指针确定就是静态绑定</p><h4 id="关于-invokedynamic-指令"><a href="#关于-invokedynamic-指令" class="headerlink" title="关于 invokedynamic 指令"></a>关于 invokedynamic 指令</h4><ol><li><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</p></li><li><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p></li><li><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p></li></ol><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Func</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">func</span><span class="hljs-params">(String str)</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lambda</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambda</span><span class="hljs-params">(Func func)</span> &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Lambda</span> <span class="hljs-variable">lambda</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lambda</span>();        <span class="hljs-type">Func</span> <span class="hljs-variable">func</span> <span class="hljs-operator">=</span> s -&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;;        lambda.lambda(func);        lambda.lambda(s -&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;);    &#125;&#125;</code></pre><img src="\chapter_004\0033.png"><h3 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h3><ol><li><p>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。   java是静态语言</p></li><li><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p></li></ol><p>​    Java：String info &#x3D; “mogu blog”;     (Java是静态类型语言的，会先编译就进行类型检查)<br>​    JS：var name &#x3D; “shkstart”;    var name &#x3D; 10;（运行时才进行检查）<br>​    Python: info &#x3D; 130.5 (运行时才检查)</p><h3 id="Java语言中方法重写的本质"><a href="#Java语言中方法重写的本质" class="headerlink" title="Java语言中方法重写的本质"></a>Java语言中方法重写的本质</h3><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul><li>如果通过则返回这个方法的直接引用，查找过程结束</li><li>如果不通过，则返回java.lang.IllegalAccessError 异常</li></ul></li><li>否则(类型C中找不到与常量中的描述)，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。（和双亲委派机制相反）</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol><blockquote><p>上面这个过程称为<strong>动态分派</strong></p></blockquote><p><strong>IllegalAccessError介绍</strong></p><ol><li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变  。</li><li>比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</li></ol><h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ol><li><p>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</p></li><li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p></li><li><p>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建（链接阶段中的解析阶段）并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</p></li></ol><p><strong>例子1</strong></p><p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p><img src="\chapter_004\0034.png"><p>1、比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p><p>2、下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</p><p><strong>例子2</strong></p><img src="\chapter_004\0035.png"><img src="\chapter_004\0036.jpg"><img src="\chapter_004\0037.jpg"><img src="\chapter_004\0038.jpg"><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>用于保存当前方法返回时需要跳转位置的指令地址</p><img src="\chapter_004\0039.png"><blockquote><p>在一些帖子里，方法返回地址、动态链接、一些附加信息  也叫做帧数据区</p></blockquote><ol><li><strong>存放调用该方法的pc寄存器的值</strong>。一个方法的结束，有两种方式：</li></ol><ul><li>正常执行完成<ul><li>出现未处理的异常，非正常退出</li></ul></li></ul><ol start="2"><li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p></li><li><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p></li><li><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p></li></ol><p><strong>方法退出的两种方式</strong></p><p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p><p><strong>正常退出：</strong></p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含：<ul><li><p>ireturn：当返回值是boolean，byte，char，short和int类型时使用</p></li><li><p>lreturn：Long类型</p></li><li><p>freturn：Float类型</p></li><li><p>dreturn：Double类型</p></li><li><p>areturn：引用类型</p></li><li><p>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p></li></ul></li></ol><p><strong>异常退出：</strong></p><ol><li><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</p></li><li><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p></li></ol><img src="\chapter_004\0040.png"><p>异常处理表：</p><ul><li>反编译字节码文件，可得到 Exception table</li><li>from ：字节码指令起始地址</li><li>to ：字节码指令结束地址</li><li>target ：出现异常跳转至地址为 11 的指令执行</li><li>type ：捕获异常的类型</li></ul><img src="\chapter_004\0041.png"><h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="栈相关面试题"><a href="#栈相关面试题" class="headerlink" title="栈相关面试题"></a>栈相关面试题</h2><h3 id="举例栈溢出的情况？"><a href="#举例栈溢出的情况？" class="headerlink" title="举例栈溢出的情况？"></a>举例栈溢出的情况？</h3><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p><h3 id="调整栈大小，就能保证不出现溢出么？"><a href="#调整栈大小，就能保证不出现溢出么？" class="headerlink" title="调整栈大小，就能保证不出现溢出么？"></a>调整栈大小，就能保证不出现溢出么？</h3><p>不能保证不溢出，只能保证SOF出现的几率小</p><h3 id="分配的栈内存越大越好么？"><a href="#分配的栈内存越大越好么？" class="headerlink" title="分配的栈内存越大越好么？"></a>分配的栈内存越大越好么？</h3><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><h3 id="垃圾回收是否涉及到虚拟机栈？"><a href="#垃圾回收是否涉及到虚拟机栈？" class="headerlink" title="垃圾回收是否涉及到虚拟机栈？"></a>垃圾回收是否涉及到虚拟机栈？</h3><p>不会</p><table><thead><tr><th>位置</th><th>是否有Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>PC计数器</td><td>无</td><td>不存在</td></tr><tr><td>虚拟机栈</td><td>有，SOF</td><td>不存在</td></tr><tr><td>本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td><td></td><td>不存在</td></tr><tr><td>堆</td><td>有，OOM</td><td>存在</td></tr><tr><td>方法区</td><td>有</td><td>存在</td></tr></tbody></table><h3 id="方法中定义的局部变量是否线程安全？"><a href="#方法中定义的局部变量是否线程安全？" class="headerlink" title="方法中定义的局部变量是否线程安全？"></a>方法中定义的局部变量是否线程安全？</h3><p>具体问题具体分析</p><ol><li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li><li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li></ol><p><strong>具体问题具体分析：</strong></p><ul><li>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 面试题：</span><span class="hljs-comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *   何为线程安全？</span><span class="hljs-comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span><span class="hljs-comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilderTest</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    <span class="hljs-comment">//s1的声明方式是线程安全的（只在方法内部用了）</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;        <span class="hljs-comment">//StringBuilder:线程不安全</span>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        s1.append(<span class="hljs-string">&quot;a&quot;</span>);        s1.append(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-comment">//sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(StringBuilder sBuilder)</span>&#123;        sBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);        sBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-comment">//s1的操作：是线程不安全的（有返回值，可能被其它线程操作）</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title function_">method3</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        s1.append(<span class="hljs-string">&quot;a&quot;</span>);        s1.append(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-keyword">return</span> s1;    &#125;    <span class="hljs-comment">//s1的操作：是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象）</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">method4</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        s1.append(<span class="hljs-string">&quot;a&quot;</span>);        s1.append(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-keyword">return</span> s1.toString();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            s.append(<span class="hljs-string">&quot;a&quot;</span>);            s.append(<span class="hljs-string">&quot;b&quot;</span>);        &#125;).start();        method2(s);    &#125;&#125;</code></pre><p>在方法体中定义的但是被返回出去了的引用数据类型变量是线程不安全的，可能被接收到传递给其它线程使用<br>在方法体中定义的并且在方法体中消亡的引用数据类型变量是线程安全的，无法被其它线程使用<br>所有的基本数据类型局部变量都是线程安全的，当方法传参时传递的是变量值，不是变量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚拟机栈&quot;&gt;&lt;a href=&quot;#虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;虚拟机栈&quot;&gt;&lt;/a&gt;虚拟机栈&lt;/h1&gt;&lt;p&gt;没有gc有oom&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>静态代理和动态代理</title>
    <link href="http://example.com/2023/03/16/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2023/03/16/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2023-03-16T06:52:17.000Z</published>
    <updated>2024-03-12T08:53:07.966Z</updated>
    
    <content type="html"><![CDATA[<p>代理的相关术语</p><ul><li><p>代理：降费核心的逻辑剥离出来以后封装在这些非核心逻辑的类、对象、方法</p></li><li><p>目标：背代套用了非和核心的逻辑代码的类 对象 方法。</p></li></ul><p>代理就是将被代理类包在代理类当中 是被代理类成为代理类的成员方法  同时借助多态实现</p><h1 id="静态代理与动态代理"><a href="#静态代理与动态代理" class="headerlink" title="静态代理与动态代理"></a>静态代理与动态代理</h1><p>代理解决的是如果我们项目要完成一个项目，需要使用的类不足以完成任务 但该类我们不能随意进行修改 这时候我们就需要进行代理的使用 在不改变源代码的同时实现代码功能的添加，在后续的spring框架中 aop就使用动态代理实现了切面的添加 </p><p> servlect 方法得实现也采用了代理的方法(可能)</p><p>代理设计模式的原理:  使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原 始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p><blockquote><p>代理类相当于中介将我们常遭的被代理类封装起来，然后通过调用代理类来调用被代理类</p></blockquote><p>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时 根据需要动态创建目标类的代理对象。</p><p>动态代理相比于静态代理的优点： 抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中 处理，这样，我们可以更加灵活和统一的处理众多的方法。</p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> 动态代理;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created with IntelliJ IDEA.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : hcj</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@Project</span> : java8新特性</span><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span> : 动态代理</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> : StaticPROXY.java</span><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> : 2023/2/6 18:47</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> :  静态代理举例</span><span class="hljs-comment"> */</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClothFactory</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceCloth</span><span class="hljs-params">()</span>;&#125;<span class="hljs-comment">//代理类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyClothFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClothFactory</span> &#123;    <span class="hljs-keyword">private</span> ClothFactory factory;  <span class="hljs-comment">// 拿被代理类对象进行实例化</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyClothFactory</span><span class="hljs-params">(ClothFactory factory)</span> &#123;        <span class="hljs-built_in">this</span>.factory = factory;   <span class="hljs-comment">// 多态 相当于  ClothFactory factory = new ProxyClothFactory();</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceCloth</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;代理工厂要做准备工作了&quot;</span>);        factory.produceCloth();          System.out.println(<span class="hljs-string">&quot;代理工厂要做收尾工作了&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 被代理类</span><span class="hljs-comment">//被代理类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">NikeClothFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClothFactory</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceCloth</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Nike工厂生产一批运动服&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticProxy</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//创建被代理类的对象</span>        <span class="hljs-type">ClothFactory</span> <span class="hljs-variable">nike</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NikeClothFactory</span>();        <span class="hljs-comment">//创建代理类的对象</span>        <span class="hljs-type">ClothFactory</span> <span class="hljs-variable">proxyClothFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyClothFactory</span>(nike);        proxyClothFactory.produceCloth();    &#125;&#125;</code></pre><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理中 代理类是动态生成的</p><p>根据你的 被代理类动态生成对应的接口来代理对你的执行</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> 动态代理;<span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created with IntelliJ IDEA.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : hcj</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@Project</span> : java8新特性</span><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span> : 动态代理</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> : ProxyTest.java</span><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> : 2023/2/6 19:02</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> :  动态代理实例</span><span class="hljs-comment"> */</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Human</span>&#123;    String <span class="hljs-title function_">getBelief</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span>;&#125;<span class="hljs-comment">//被代理类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Human</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBelief</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I believe I can fly!&quot;</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span> &#123;        System.out.println(<span class="hljs-string">&quot;我喜欢吃&quot;</span> + food);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">HumanUtil</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;====================通用方法一====================&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;====================通用方法二====================&quot;</span>);    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">要想实现动态代理，需要解决的问题？</span><span class="hljs-comment">问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。</span><span class="hljs-comment">问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span>&#123;    <span class="hljs-comment">//调用此方法，返回一个代理类的对象。解决问题一</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">(Object obj)</span>&#123;<span class="hljs-comment">//obj:被代理类的对象</span>        <span class="hljs-type">MyInvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInvocationHandler</span>();<span class="hljs-comment">// 获取被代理类对象</span>        handler.bind(obj);        <span class="hljs-comment">// Proxy.newProxyInstance(类加载器,被代理类的接口,InvocationHandler);</span>        <span class="hljs-comment">//invocationHandler：设置代理对象实现被代理对象方法的过程，即代理类中如何重写接口中的抽象方法(动态的执行被代理类对象的方法)</span>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;    <span class="hljs-keyword">private</span> Object obj;<span class="hljs-comment">//需要使用被代理类的对象进行赋值</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(Object obj)</span>&#123;        <span class="hljs-built_in">this</span>.obj = obj;    &#125;    <span class="hljs-comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span>    <span class="hljs-comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span>      <span class="hljs-comment">/**</span><span class="hljs-comment">        * proxy：代理对象</span><span class="hljs-comment">        * method：代理对象需要实现的方法，即其中需要重写的方法</span><span class="hljs-comment">        * args：method所对应方法的参数</span><span class="hljs-comment">      */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-type">HumanUtil</span> <span class="hljs-variable">util</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HumanUtil</span>();        util.method1();        <span class="hljs-comment">//method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span>        <span class="hljs-comment">//obj:被代理类的对象</span>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> method.invoke(obj,args);        util.method2();        <span class="hljs-comment">//上述方法的返回值就作为当前类中的invoke()的返回值。</span>        <span class="hljs-keyword">return</span> returnValue;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">SuperMan</span> <span class="hljs-variable">superMan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperMan</span>();        <span class="hljs-comment">//proxyInstance:代理类的对象</span>        <span class="hljs-comment">// 这里只能是Human  动态代理过程中是寻找superman实现了什么接口 在这里 的接口human 该方法无法确定Hunman接口下层的superman</span>        <span class="hljs-type">Human</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);        <span class="hljs-comment">//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span>        <span class="hljs-type">String</span> <span class="hljs-variable">belief</span> <span class="hljs-operator">=</span> proxyInstance.getBelief();        System.out.println(belief);        proxyInstance.eat(<span class="hljs-string">&quot;四川麻辣烫&quot;</span>);        System.out.println(<span class="hljs-string">&quot;*****************************&quot;</span>);        <span class="hljs-type">NikeClothFactory</span> <span class="hljs-variable">nikeClothFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NikeClothFactory</span>();        <span class="hljs-type">ClothFactory</span> <span class="hljs-variable">proxyClothFactory</span> <span class="hljs-operator">=</span> (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);        proxyClothFactory.produceCloth();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span><span class="hljs-params">                                          Class&lt;?&gt;[] interfaces,</span><span class="hljs-params">                                          InvocationHandler h)</span>        <span class="hljs-keyword">throws</span> IllegalArgumentException    &#123;            <span class="hljs-comment">//检查InvocationHandler是否为空，为空抛出空指针异常</span>        Objects.requireNonNull(h);        <span class="hljs-comment">//克隆拿到接口</span>        <span class="hljs-keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();        <span class="hljs-comment">//进行安全校验</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">sm</span> <span class="hljs-operator">=</span> System.getSecurityManager();        <span class="hljs-comment">//检查是否能被代理</span>        <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);        &#125;        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Look up or generate the designated proxy class.</span><span class="hljs-comment">         * 得到代理类</span><span class="hljs-comment">         */</span>        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Invoke its constructor with the designated invocation handler.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;                checkNewProxyPermission(Reflection.getCallerClass(), cl);            &#125;            <span class="hljs-comment">//通过构造方法得到代理类的对象</span>            <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);            <span class="hljs-keyword">final</span> <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">ih</span> <span class="hljs-operator">=</span> h;            <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;                AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;                    <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                        cons.setAccessible(<span class="hljs-literal">true</span>);                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;                    &#125;                &#125;);            &#125;            <span class="hljs-comment">//new得到代理对象</span>            <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;h&#125;);        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(e.toString(), e);        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;            <span class="hljs-type">Throwable</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> e.getCause();            <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;                <span class="hljs-keyword">throw</span> (RuntimeException) t;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(t.toString(), t);            &#125;        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(e.toString(), e);        &#125;    &#125;</code></pre><p>　从上面可以看出 <strong>Class&lt;?&gt; cl &#x3D; getProxyClass0(loader, intfs);</strong> 这行代码最重要，它可以得到一个代理对象，下面是 <strong>Proxy#getProxyClass0</strong> 的源码<strong>：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,                                           Class&lt;?&gt;... interfaces) &#123;        <span class="hljs-keyword">if</span> (interfaces.length &gt; <span class="hljs-number">65535</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;interface limit exceeded&quot;</span>);        &#125;        <span class="hljs-comment">// If the proxy class defined by the given loader implementing</span>        <span class="hljs-comment">// the given interfaces exists, this will simply return the cached copy;</span>        <span class="hljs-comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span>　　　　<span class="hljs-comment">//如果接口的代理类已经存在缓存中了，直接从缓存中取出来返回，如果不存在则通过ProxyClassFactory创建一个并放入缓存中供下次使用　</span>        <span class="hljs-keyword">return</span> proxyClassCache.get(loader, interfaces);    &#125;</code></pre><p>参考：</p><p><a href="https://blog.csdn.net/Ellie_Jin/article/details/123866874">(55条消息) 类加载器详细解释_是云佐丫的博客-CSDN博客_类加载器</a></p><p><a href="https://zhuanlan.zhihu.com/p/616987288">彻底明白JDK动态代理的底层原理 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/huangrenhui/p/14698331.html">Proxy.newProxyInstance源码探究 - 码猿手 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代理的相关术语&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代理：降费核心的逻辑剥离出来以后封装在这些非核心逻辑的类、对象、方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目标：背代套用了非和核心的逻辑代码的类 对象 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代理就是将被代理类包在代理类当</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>3.JVM系列-运行时数据区</title>
    <link href="http://example.com/2023/03/16/3.JVM%E7%B3%BB%E5%88%97-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <id>http://example.com/2023/03/16/3.JVM%E7%B3%BB%E5%88%97-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</id>
    <published>2023-03-16T03:56:14.000Z</published>
    <updated>2024-03-12T09:37:12.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此章把运行时数据区里比较少的地方讲一下。虚拟机栈，堆，方法区这些地方后续再讲。</p></blockquote><p>pc寄存器 没有垃圾回收器 没有oom</p><p>本地方法栈 有oom 没有垃圾回收器 不受jvm管理</p><h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="运行时数据区概述及线程"></a>运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><img src="/chapter_003/0001.png"><p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><blockquote><p>java 虚拟机定义了若干程序运行时会使用到的运行数据区 其中有一些会随着虚拟机启动而去创建 随着虚拟机的推出而销毁，另外一些则是与线程一对应的，这些与线程对应的数据区域会随着线程(TCB)开始和结束而创建和销毁</p><p>灰色的为单线程私有的，红色的为多个线程共享的</p><ul><li>每个线程 地理包括程序计数器 栈 本地栈</li><li>线程共享：对外内存(永久或元空间、代码缓存)</li></ul></blockquote><img src="/chapter_003/0002.png"><p>类比一下也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品。</p><img src="/chapter_003/0003.png"><h2 id="运行时数据区结构"><a href="#运行时数据区结构" class="headerlink" title="运行时数据区结构"></a>运行时数据区结构</h2><h3 id="运行时数据区与内存"><a href="#运行时数据区与内存" class="headerlink" title="运行时数据区与内存"></a>运行时数据区与内存</h3><ol><li><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p></li><li><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></li></ol><img src="/chapter_003/0004.jpg"><h3 id="线程的内存空间"><a href="#线程的内存空间" class="headerlink" title="线程的内存空间"></a>线程的内存空间</h3><ol><li><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p></li><li><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>线程独有：独立包括程序计数器、栈、本地方法栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul></li></ol><img src="/chapter_003/0005.png"><h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p><strong>每个JVM只有一个Runtime实例 也对应只有一个运行时数据区 换句话说jvm只能同时处理一个进程 即并发</strong>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="JVM-线程"><a href="#JVM-线程" class="headerlink" title="JVM 线程"></a>JVM 线程</h3><ol><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li><span style="color:red"><strong>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射</strong></span><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul></li><li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li></ol><h3 id="JVM-系统线程"><a href="#JVM-系统线程" class="headerlink" title="JVM 系统线程"></a>JVM 系统线程</h3><ul><li><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</p></li><li><p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p></li></ul><ol><li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li><li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ol><h1 id="程序计数器-PC寄存器"><a href="#程序计数器-PC寄存器" class="headerlink" title="程序计数器(PC寄存器)"></a>程序计数器(PC寄存器)</h1><h2 id="PC寄存器介绍"><a href="#PC寄存器介绍" class="headerlink" title="PC寄存器介绍"></a>PC寄存器介绍</h2><blockquote><p>官方文档网址：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p></blockquote><img src="/chapter_003/0007.png"><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是<strong>广义上所指的物理寄存器</strong>，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<span style="color:red"><strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong></span>。</li><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中，<strong>每个线程都有它自己的程序计数器</strong>，<strong>是线程私有的</strong>，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。<ul><li><img src="/chapter_003/Snipaste_2023-03-15_18-05-28.png"></li></ul></li><li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li><li><strong>没有GC  没有OOM</strong></li></ol><h2 id="PC寄存器的作用"><a href="#PC寄存器的作用" class="headerlink" title="PC寄存器的作用"></a>PC寄存器的作用</h2><p><span style="color:red">PC寄存器用来存储指向下一条指令的地址，也就是即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</span></p><img src="/chapter_003/0008.png"><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PCRegisterTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;        System.out.println(i);        System.out.println(k);    &#125;&#125;</code></pre><p>查看字节码</p><blockquote><p>看字节码的方法：<a href="https://blog.csdn.net/21aspnet/article/details/88351875">https://blog.csdn.net/21aspnet/article/details/88351875</a></p></blockquote><pre><code class="hljs java">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.<span class="hljs-keyword">class</span>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">2</span>; size <span class="hljs-number">675</span> bytes  MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3  Compiled from <span class="hljs-string">&quot;PCRegisterTest.java&quot;</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java.PCRegisterTest  minor version: <span class="hljs-number">0</span>  major version: <span class="hljs-number">52</span>  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">6.</span>#<span class="hljs-number">26</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>   #<span class="hljs-number">2</span> = String             #<span class="hljs-number">27</span>            <span class="hljs-comment">// abc</span>   #<span class="hljs-number">3</span> = Fieldref           #<span class="hljs-number">28.</span>#<span class="hljs-number">29</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span>   #<span class="hljs-number">4</span> = Methodref          #<span class="hljs-number">30.</span>#<span class="hljs-number">31</span>        <span class="hljs-comment">// java/io/PrintStream.println:(I)V</span>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">32</span>            <span class="hljs-comment">// com/atguigu/java/PCRegisterTest</span>   #<span class="hljs-number">6</span> = Class              #<span class="hljs-number">33</span>            <span class="hljs-comment">// java/lang/Object</span>   #<span class="hljs-number">7</span> = Utf8               &lt;init&gt;   #<span class="hljs-number">8</span> = Utf8               ()V   #<span class="hljs-number">9</span> = Utf8               Code  #<span class="hljs-number">10</span> = Utf8               LineNumberTable  #<span class="hljs-number">11</span> = Utf8               LocalVariableTable  #<span class="hljs-number">12</span> = Utf8               <span class="hljs-built_in">this</span>  #<span class="hljs-number">13</span> = Utf8               Lcom/atguigu/java/PCRegisterTest;  #<span class="hljs-number">14</span> = Utf8               main  #<span class="hljs-number">15</span> = Utf8               ([Ljava/lang/String;)V  #<span class="hljs-number">16</span> = Utf8               args  #<span class="hljs-number">17</span> = Utf8               [Ljava/lang/String;  #<span class="hljs-number">18</span> = Utf8               i  #<span class="hljs-number">19</span> = Utf8               I  #<span class="hljs-number">20</span> = Utf8               j  #<span class="hljs-number">21</span> = Utf8               k  #<span class="hljs-number">22</span> = Utf8               s  #<span class="hljs-number">23</span> = Utf8               Ljava/lang/String;  #<span class="hljs-number">24</span> = Utf8               SourceFile  #<span class="hljs-number">25</span> = Utf8               PCRegisterTest.java  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span>  #<span class="hljs-number">27</span> = Utf8               abc  #<span class="hljs-number">28</span> = Class              #<span class="hljs-number">34</span>            <span class="hljs-comment">// java/lang/System</span>  #<span class="hljs-number">29</span> = NameAndType        #<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span>  #<span class="hljs-number">30</span> = Class              #<span class="hljs-number">37</span>            <span class="hljs-comment">// java/io/PrintStream</span>  #<span class="hljs-number">31</span> = NameAndType        #<span class="hljs-number">38</span>:#<span class="hljs-number">39</span>        <span class="hljs-comment">// println:(I)V</span>  #<span class="hljs-number">32</span> = Utf8               com/atguigu/java/PCRegisterTest  #<span class="hljs-number">33</span> = Utf8               java/lang/Object  #<span class="hljs-number">34</span> = Utf8               java/lang/System  #<span class="hljs-number">35</span> = Utf8               out  #<span class="hljs-number">36</span> = Utf8               Ljava/io/PrintStream;  #<span class="hljs-number">37</span> = Utf8               java/io/PrintStream  #<span class="hljs-number">38</span> = Utf8               println  #<span class="hljs-number">39</span> = Utf8               (I)V&#123;  <span class="hljs-keyword">public</span> com.atguigu.java.PCRegisterTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/PCRegisterTest;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>         <span class="hljs-number">2</span>: istore_1         <span class="hljs-number">3</span>: bipush        <span class="hljs-number">20</span>         <span class="hljs-number">5</span>: istore_2         <span class="hljs-number">6</span>: iload_1         <span class="hljs-number">7</span>: iload_2         <span class="hljs-number">8</span>: iadd         <span class="hljs-number">9</span>: istore_3        <span class="hljs-number">10</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String abc</span>        <span class="hljs-number">12</span>: astore        <span class="hljs-number">4</span>        <span class="hljs-number">14</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>        <span class="hljs-number">17</span>: iload_1        <span class="hljs-number">18</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span>        <span class="hljs-number">21</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>        <span class="hljs-number">24</span>: iload_3        <span class="hljs-number">25</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span>        <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">10</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">11</span>: <span class="hljs-number">3</span>        line <span class="hljs-number">12</span>: <span class="hljs-number">6</span>        line <span class="hljs-number">14</span>: <span class="hljs-number">10</span>        line <span class="hljs-number">15</span>: <span class="hljs-number">14</span>        line <span class="hljs-number">16</span>: <span class="hljs-number">21</span>        line <span class="hljs-number">18</span>: <span class="hljs-number">28</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>      <span class="hljs-number">29</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;            <span class="hljs-number">3</span>      <span class="hljs-number">26</span>     <span class="hljs-number">1</span>     i   I            <span class="hljs-number">6</span>      <span class="hljs-number">23</span>     <span class="hljs-number">2</span>     j   I           <span class="hljs-number">10</span>      <span class="hljs-number">19</span>     <span class="hljs-number">3</span>     k   I           <span class="hljs-number">14</span>      <span class="hljs-number">15</span>     <span class="hljs-number">4</span>     s   Ljava/lang/String;&#125;SourceFile: <span class="hljs-string">&quot;PCRegisterTest.java&quot;</span></code></pre><ul><li>左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令</li></ul><img src="/chapter_003/0009.png"><h2 id="两个面试题"><a href="#两个面试题" class="headerlink" title="两个面试题"></a>两个面试题</h2><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong>或者问<strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p><ol><li><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</p></li><li><p>如果使用 PC 寄存器来记录当前线程的执行地址，JVM的字节码解释器需要通过调用不同线程下的PC寄存器的值 来明确对用该线程下一条应该执行什么样的字节码指令</p></li></ol><img src="/chapter_003/0010.png"><p><strong>PC寄存器为什么被设定为私有的(或者说就是为什么pc寄存器随着线程的创建而创建 线程的销毁而销毁 是线程私有的？</strong></p><ol><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<span style="color:red"><strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong></span>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>并发必然导致经常不同线程中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li></ol><h2 id="CPU-时间片"><a href="#CPU-时间片" class="headerlink" title="CPU 时间片"></a>CPU 时间片</h2><p>并发：串行</p><ol><li><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p></li><li><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p></li><li><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</p></li></ol><img src="/chapter_003/0011.png"><h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h2><img src="/chapter_003/0012.png"><ol><li>简单地讲，<strong>一个Native Method是一个Java调用非Java代码的接囗</strong>一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。</li><li>本地方法是一个非Java的方法，它的具体实现是非Java代码的实现</li><li>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li><li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C&#x2F;C++程序。</li></ol><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IHaveNatives</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Native1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">Native2</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">float</span> <span class="hljs-title function_">Native3</span><span class="hljs-params">(Object o)</span>;    <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Native4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ary)</span> <span class="hljs-keyword">throws</span> Exception;    &#125;</code></pre><h2 id="为什么要使用-Native-Method？"><a href="#为什么要使用-Native-Method？" class="headerlink" title="为什么要使用 Native Method？"></a>为什么要使用 Native Method？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><h3 id="与Java环境外交互"><a href="#与Java环境外交互" class="headerlink" title="与Java环境外交互"></a>与Java环境外交互</h3><p><strong>有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因</strong>。你可以想想Java需要与一些<strong>底层系统</strong>，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><ol><li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li><li>然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。</li><li><strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。</li><li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ol><h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h3><ol><li>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li><li>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ol><h3 id="本地方法的现状"><a href="#本地方法的现状" class="headerlink" title="本地方法的现状"></a>本地方法的现状</h3><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ol><li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ol><img src="/chapter_003/0013.png"><p><strong>注意事项</strong></p><ol><li><span style="color:red">当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</span><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li><li><strong>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此章把运行时数据区里比较少的地方讲一下。虚拟机栈，堆，方法区这些地方后续再讲。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pc寄存器 没有垃圾回收器 没有oom&lt;/p&gt;
&lt;p&gt;本地方法栈 有oom 没有垃圾回收器 不受jvm管理&lt;/p&gt;
&lt;h1 i</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>2.JVM系列-类加载子系统</title>
    <link href="http://example.com/2023/03/14/2.JVM%E7%B3%BB%E5%88%97-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2023/03/14/2.JVM%E7%B3%BB%E5%88%97-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-03-14T01:07:19.000Z</published>
    <updated>2024-03-12T09:35:11.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第2章-类加载子系统"><a href="#第2章-类加载子系统" class="headerlink" title="第2章-类加载子系统"></a>第2章-类加载子系统</h1><h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><h3 id="简图"><a href="#简图" class="headerlink" title="简图"></a>简图</h3><img src="/chapter_002/0001.png"><h3 id="详细图"><a href="#详细图" class="headerlink" title="详细图"></a>详细图</h3><p>英文版</p><img src="/chapter_002/0002.jpg"><p>中文版</p><img src="/chapter_002/0003.jpg"><p>注意：方法区只有HotSpot虚拟机有，J9，JRockit都没有</p><p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p><ol><li>类加载器</li><li>执行引擎</li></ol><h2 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h2><p><strong>类加载器子系统作用：</strong></p><ol><li><p><span style="color:red">类加载器子系统负责从文件系统或者网络中加载Class文件</span>，<span style="color:rgb(254,152,51)">class文件在文件开头有特定的文件标识</span>。</p></li><li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p><span style="color:red"><strong>加载的类信息存放于一块称为方法区的内存空间</strong></span>。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p></li></ol><img src="/chapter_002/0004.png"><h2 id="类加载器ClassLoader角色"><a href="#类加载器ClassLoader角色" class="headerlink" title="类加载器ClassLoader角色"></a>类加载器ClassLoader角色</h2><ol><li>class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而<strong>最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例</strong>。</li><li>class file加载到JVM中，被称为DNA元数据模板（在下图中就是内存中的Car Class），放在方法区。</li><li>在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ol><img src="/chapter_002/0005.png"><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloLoader</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(<span class="hljs-string">&quot;谢谢ClassLoader加载我....&quot;</span>);        System.out.println(<span class="hljs-string">&quot;你的大恩大德，我下辈子再报！&quot;</span>);    &#125;&#125;</code></pre><p>它的加载过程是怎么样的呢?</p><ul><li>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li><li>加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li><li>加载失败则抛出异常</li></ul><img src="/chapter_002/0006.png"><p>完整的流程图如下所示：</p><img src="/chapter_002/0007.png"><h3 id="类的加载阶段"><a href="#类的加载阶段" class="headerlink" title="类的加载阶段"></a>类的加载阶段</h3><p>**加载： ** <em>产生class文件</em></p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流<ul><li>整体加载过程中的第一个环节</li></ul></li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li><span style="color:red"><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong></span>，作为方法区这个类的各种数据的访问入口</li></ol><p><strong>加载class文件的方式：</strong></p><ol><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><p>链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析</p><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证(Verify)"></a>验证(Verify)</h4><ol><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证（class文件开头会有特殊的字符(解析成为二进制的文件后) CA FE BA BE），符号引用验证。</li></ol><p><strong>举例</strong></p><p>查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</p><img src="/chapter_002/Snipaste_2023-03-13_10-30-18.png"> <h4 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备(Prepare)"></a>准备(Prepare)</h4><ol><li><p><span style="color:red">为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值</span></p></li><li><p><span style="color:rgb(168, 1, 8)">这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</span></p></li><li><p>注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</p><blockquote><ul><li><p>实例变量 ：对象变量 类成员变量 从属于类由类生成对象时，才分配存储空间，各对象间的实例变量互不干扰，能通过对象的引用来访问实例变量。但在Java多线程中，实例变量是多个线程共享资源，要注意同步访问时可能出现的问题</p><ul><li><em>&#x2F;&#x2F;实例变量</em>  private String nameString;</li></ul></li><li><p>类变量：静态变量 也叫静态变量，是一种比较特殊的实例变量，用static关键字修饰；一个类的静态变量，所有由这类生成的对象都共用这个类变量，类装载时就分配存储空间。一个对象修改了变量，则所以对象中这个变量的值都会发生改变。</p><ul><li><em>&#x2F;&#x2F;类变量</em>    private static String nameString;</li></ul></li><li><p>局部变量：方法中或者某局部块中声明定义的变量或方法的参数被称为局部变量</p></li></ul></blockquote></li></ol><p><strong>举例</strong></p><p>代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloApp</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//prepare：a = 0 ---&gt; initial(初始化) : a = 1</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(a);    &#125;&#125;</code></pre><h4 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析(Resolve)"></a>解析(Resolve)</h4><ol><li><p><span style="color:red"><strong>将常量池内的符号引用转换为直接引用的过程</strong></span></p></li><li><p>事实上，解析操作往往会伴随着JVM<span style="color:red">在执行完初始化之后再执行</span></p></li><li><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p></li><li><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p></li></ol><p><strong>符号引用</strong></p><ul><li>反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用</li></ul><img src="/chapter_002/0023.png"/><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><h4 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h4><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName(“com.atguigu.Test”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类1没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致<span style="color:red">类的初始化</span>，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p><h3 id="clinit"><a href="#clinit" class="headerlink" title="clinit()"></a>clinit()</h3><ol><li><p>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</p></li><li><p>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</p></li><li><p><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</p></li><li><p><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</p></li><li><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p></li><li><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p></li></ol><blockquote><p>clinit 类型初始化方法 主要是对static变量进行初始化操作 对static域和static代码块初始化的逻辑全部封装在<code>&lt;clinit&gt;</code>方法中。</p><p>Java对象在被创建时，会进行实例化操作。该部分操作封装在<init>方法中，并且子类的<init>方法中会首先对父类<init>方法的调用。</p><p>init是对象构造器方法，也就是说在程序执行 new 一个对象调用该对象类的 constructor 方法时才会执行init方法，而clinit是类构造器方法，也就是在jvm进行类加载—–验证—-解析—–初始化，中的初始化阶段jvm会调用clinit方法。</p><p>init是instance实例构造器，对非静态变量解析初始化，而clinit是class类构造器对静态变量，静态代码块进行初始化。看</p></blockquote><h4 id="1，2，3说明"><a href="#1，2，3说明" class="headerlink" title="1，2，3说明"></a>1，2，3说明</h4><p><strong>举例1：有static变量</strong></p><p>查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p><img src="/chapter_002/0009.png"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassInitTest</span> &#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;   <span class="hljs-keyword">static</span>&#123;       num = <span class="hljs-number">2</span>;       number = <span class="hljs-number">20</span>;       System.out.println(num);       <span class="hljs-comment">//System.out.println(number);//报错：非法的前向引用。</span>   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span><span class="hljs-comment">    * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span><span class="hljs-comment">    * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span><span class="hljs-comment">    *</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(ClassInitTest.num);<span class="hljs-comment">//2</span>        System.out.println(ClassInitTest.number);<span class="hljs-comment">//10</span>    &#125;&#125;</code></pre><p>&lt;clint字节码&gt;：</p><pre><code class="hljs java"> <span class="hljs-number">0</span> iconst_1 <span class="hljs-number">1</span> putstatic #<span class="hljs-number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt; <span class="hljs-number">4</span> iconst_2 <span class="hljs-number">5</span> putstatic #<span class="hljs-number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt; <span class="hljs-number">8</span> bipush <span class="hljs-number">20</span> <span class="hljs-comment">//先赋20</span><span class="hljs-number">10</span> putstatic #<span class="hljs-number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;<span class="hljs-number">13</span> getstatic #<span class="hljs-number">2</span> &lt;java/lang/System.out&gt;<span class="hljs-number">16</span> getstatic #<span class="hljs-number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;<span class="hljs-number">19</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<span class="hljs-number">22</span> bipush <span class="hljs-number">10</span><span class="hljs-comment">//再赋10</span><span class="hljs-number">24</span> putstatic #<span class="hljs-number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;<span class="hljs-number">27</span> <span class="hljs-keyword">return</span></code></pre><p>当我们代码中包含static变量的时候，就会有clinit方法</p><p><strong>举例2：无 static 变量</strong></p><img src="/chapter_002/0010.png"><p>加上之后就有了</p><img src="/chapter_002/0011.png"><h4 id="4说明"><a href="#4说明" class="headerlink" title="4说明"></a>4说明</h4><img src="/chapter_002/0012.png"><p>在构造器中：</p><ul><li>先将类变量 a 赋值为 10</li><li>再将局部变量赋值为 20</li></ul><h4 id="5说明"><a href="#5说明" class="headerlink" title="5说明"></a>5说明</h4><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p><img src="/chapter_002/0013.png"><p>如上代码，加载流程如下：</p><ul><li>首先，执行 main() 方法需要加载 ClinitTest1 类</li><li>获取 Son.B 静态变量，需要加载 Son 类</li><li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li></ul><h4 id="6说明"><a href="#6说明" class="headerlink" title="6说明"></a>6说明</h4><p>在静态块中new对象     相当于同步加锁的过程  说明clinit在同一时间内只能为一个类服务</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadThreadTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始&quot;</span>);            <span class="hljs-type">DeadThread</span> <span class="hljs-variable">dead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadThread</span>();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);        &#125;;        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程1&quot;</span>);        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程2&quot;</span>);        t1.start();        t2.start();    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadThread</span>&#123;    <span class="hljs-keyword">static</span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;初始化当前类&quot;</span>);            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            &#125;        &#125;    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="hljs plaintext">线程2开始线程1开始线程2初始化当前类/然后程序卡死了</code></pre><p>程序卡死，分析原因：</p><ul><li>两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环</li><li>先加载 DeadThread 类的线程抢到了new对象，然后在类的静态代码块中执行死循环，而另一个线程在等待clinit的释放</li><li>所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li></ul><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol><li><p>JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</p></li><li><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></p><blockquote><p>注意是派生于ClassLoader的类加载器</p></blockquote></li><li><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</p></li></ol><img src="/chapter_002/0014.png"><p><strong>ExtClassLoader</strong></p><img src="/chapter_002/0015.png"><p><strong>AppClassLoader</strong></p><img src="/chapter_002/0016.png"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//获取系统类加载器</span>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">systemClassLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();        System.out.println(systemClassLoader);<span class="hljs-comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span>        <span class="hljs-comment">//获取其上层：扩展类加载器</span>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">extClassLoader</span> <span class="hljs-operator">=</span> systemClassLoader.getParent();        System.out.println(extClassLoader);<span class="hljs-comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span>        <span class="hljs-comment">//获取其上层：获取不到引导类加载器</span>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bootstrapClassLoader</span> <span class="hljs-operator">=</span> extClassLoader.getParent();        System.out.println(bootstrapClassLoader);<span class="hljs-comment">//null</span>        <span class="hljs-comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoaderTest.class.getClassLoader();        System.out.println(classLoader);<span class="hljs-comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span>        <span class="hljs-comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> String.class.getClassLoader();        System.out.println(classLoader1);<span class="hljs-comment">//null</span>    &#125;&#125;</code></pre><ul><li>我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，<strong>因为引导类加载器用 C&#x2F;C++ 语言，我们获取不到</strong></li><li>两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明<strong>系统类加载器是全局唯一的</strong></li></ul><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><blockquote><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p></blockquote><ol><li>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并作为他们的父类加载器</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ol><h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><blockquote><p><strong>扩展类加载器（Extension ClassLoader）</strong></p></blockquote><ol><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ol><h4 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h4><blockquote><p><strong>应用程序类加载器（也称为系统类加载器，AppClassLoader）</strong></p></blockquote><ol><li>Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest1</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(<span class="hljs-string">&quot;**********启动类加载器**************&quot;</span>);        <span class="hljs-comment">//获取BootstrapClassLoader能够加载的api的路径</span>        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();        <span class="hljs-keyword">for</span> (URL element : urLs) &#123;            System.out.println(element.toExternalForm());        &#125;        <span class="hljs-comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Provider.class.getClassLoader();        System.out.println(classLoader);        System.out.println(<span class="hljs-string">&quot;***********扩展类加载器*************&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">extDirs</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;java.ext.dirs&quot;</span>);        <span class="hljs-keyword">for</span> (String path : extDirs.split(<span class="hljs-string">&quot;;&quot;</span>)) &#123;            System.out.println(path);        &#125;        <span class="hljs-comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> CurveDB.class.getClassLoader();        System.out.println(classLoader1);<span class="hljs-comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span>    &#125;&#125;</code></pre><p><strong>输出结果</strong></p><pre><code class="hljs java">**********启动类加载器**************file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/resources.jarfile:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/rt.jarfile:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/sunrsasign.jarfile:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/jsse.jarfile:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/jce.jarfile:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/charsets.jarfile:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/jfr.jarfile:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/classes<span class="hljs-literal">null</span>***********扩展类加载器*************C:\Program Files\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>\jre\lib\extC:\Windows\Sun\Java\lib\extsun.misc.Launcher$ExtClassLoader@29453f44</code></pre><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><h4 id="什么时候需要自定义类加载器？"><a href="#什么时候需要自定义类加载器？" class="headerlink" title="什么时候需要自定义类加载器？"></a>什么时候需要自定义类加载器？</h4><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p><ol><li>隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的）</li><li>修改类加载的方式</li><li>扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li>防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ol><h4 id="如何自定义类加载器？"><a href="#如何自定义类加载器？" class="headerlink" title="如何自定义类加载器？"></a>如何自定义类加载器？</h4><ol><li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><p><strong>代码示例</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">byte</span>[] result = getClassFromCustomPath(name);            <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>();            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//defineClass和findClass搭配使用</span>                <span class="hljs-keyword">return</span> defineClass(name, result, <span class="hljs-number">0</span>, result.length);            &#125;        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(name);    &#125;<span class="hljs-comment">//自定义流的获取方式</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] getClassFromCustomPath(String name) &#123;        <span class="hljs-comment">//从自定义路径中加载指定类:细节略</span>        <span class="hljs-comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">CustomClassLoader</span> <span class="hljs-variable">customClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomClassLoader</span>();        <span class="hljs-keyword">try</span> &#123;            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-literal">true</span>, customClassLoader);            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();            System.out.println(obj.getClass().getClassLoader());        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><blockquote><p><strong>ClassLoader 类介绍</strong></p></blockquote><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><img src="/chapter_002/0017.png"><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><img src="/chapter_002/0018.png"><h4 id="获取ClassLoader途径"><a href="#获取ClassLoader途径" class="headerlink" title="获取ClassLoader途径"></a>获取ClassLoader途径</h4><img src="/chapter_002/0019.png"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest2</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1.</span>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>).getClassLoader();            System.out.println(classLoader);            <span class="hljs-comment">//2.</span>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();            System.out.println(classLoader1);            <span class="hljs-comment">//3.</span>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader2</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader().getParent();            System.out.println(classLoader2);        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="hljs plaintext">nullsun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@1540e19dProcess finished with exit code 0</code></pre><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="双亲委派机制原理"><a href="#双亲委派机制原理" class="headerlink" title="双亲委派机制原理"></a>双亲委派机制原理</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，<span style="color:red">即把请求交由父类处理，它是一种任务委派模式</span></p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li><li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li><li><strong>jvm会优先加载核心类库中同名的类</strong></li></ol><img src="/chapter_002/0020.png"><h3 id="双亲委派机制代码演示"><a href="#双亲委派机制代码演示" class="headerlink" title="双亲委派机制代码演示"></a>双亲委派机制代码演示</h3><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h4><p>1、我们自己建立一个 java.lang.String 类，写上 static 代码块</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;    <span class="hljs-comment">//</span>    <span class="hljs-keyword">static</span>&#123;        System.out.println(<span class="hljs-string">&quot;我是自定义的String类的静态代码块&quot;</span>);    &#125;&#125;</code></pre><p>2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.String();        System.out.println(<span class="hljs-string">&quot;hello,atguigu.com&quot;</span>);        <span class="hljs-type">StringTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTest</span>();        System.out.println(test.getClass().getClassLoader());    &#125;&#125;Error: A JNI error has occurred, please check your installation and <span class="hljs-keyword">try</span> againException in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.SecurityException: Prohibited <span class="hljs-keyword">package</span> name: java.langat java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="hljs-number">655</span>)    ........</code></pre><p>输出结果：</p><pre><code class="hljs plaintext">hello,atguigu.comsun.misc.Launcher$AppClassLoader@18b4aac2</code></pre><p>程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类。</p><p>把刚刚的类改一下</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;    <span class="hljs-comment">//</span>    <span class="hljs-keyword">static</span>&#123;        System.out.println(<span class="hljs-string">&quot;我是自定义的String类的静态代码块&quot;</span>);    &#125;    <span class="hljs-comment">//错误: 在类 java.lang.String 中找不到 main 方法</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(<span class="hljs-string">&quot;hello,String&quot;</span>);    &#125;&#125;</code></pre><img src="/chapter_002/0021.png"><p>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。</p><h4 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShkStart</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="hljs java">java.lang.SecurityException: Prohibited <span class="hljs-keyword">package</span> name: java.langat java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="hljs-number">662</span>)at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="hljs-number">761</span>)at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:<span class="hljs-number">142</span>)at java.net.URLClassLoader.defineClass(URLClassLoader.java:<span class="hljs-number">467</span>)at java.net.URLClassLoader.access$<span class="hljs-number">100</span>(URLClassLoader.java:<span class="hljs-number">73</span>)at java.net.URLClassLoader$<span class="hljs-number">1.</span>run(URLClassLoader.java:<span class="hljs-number">368</span>)at java.net.URLClassLoader$<span class="hljs-number">1.</span>run(URLClassLoader.java:<span class="hljs-number">362</span>)at java.security.AccessController.doPrivileged(Native Method)at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="hljs-number">361</span>)at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="hljs-number">424</span>)at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="hljs-number">335</span>)at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="hljs-number">357</span>)at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="hljs-number">495</span>)Error: A JNI error has occurred, please check your installation and <span class="hljs-keyword">try</span> againException in thread <span class="hljs-string">&quot;main&quot;</span> Process finished with exit code <span class="hljs-number">1</span></code></pre><p>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</p><h4 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h4><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p><ol><li>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</li><li>然后使用双亲委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了</li><li>具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</li><li>第三方的jar包中的类属于系统类加载器来加载</li><li>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</li></ol><img src="/chapter_002/0022.png"><h3 id="双亲委派机制优势"><a href="#双亲委派机制优势" class="headerlink" title="双亲委派机制优势"></a>双亲委派机制优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p><ol><li><p>避免类的重复加载</p></li><li><p>保护程序安全，防止核心API被随意篡改</p><ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>沙箱机制就是讲Java代码限定在<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>JVM特定的运行范围中，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。</p><p>沙箱主要限制系统资源访问，例如：CPU、内存、文件系统、网络。不同级别的啥想对这些资源访问的限制也可以不一样</p><ol><li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li><li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li></ol><p>沙箱：它是一个轻量级虚拟机，软件的操作都不会影响真正的系统，包括文件、注册表等等资源，可以放肆地想干嘛干嘛(简单理解)</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li>类的完整类名必须一致，包括包名</li><li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li><li>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li></ol><h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><ol><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li><li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面讲）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第2章-类加载子系统&quot;&gt;&lt;a href=&quot;#第2章-类加载子系统&quot; class=&quot;headerlink&quot; title=&quot;第2章-类加载子系统&quot;&gt;&lt;/a&gt;第2章-类加载子系统&lt;/h1&gt;&lt;h2 id=&quot;内存结构概述&quot;&gt;&lt;a href=&quot;#内存结构概述&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>1.JVM系列-JVM与Java体系结构</title>
    <link href="http://example.com/2023/03/12/1.JVM%E7%B3%BB%E5%88%97-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/03/12/1.JVM%E7%B3%BB%E5%88%97-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2023-03-12T07:56:19.000Z</published>
    <updated>2024-03-12T09:35:17.167Z</updated>
    
    <content type="html"><![CDATA[<p>以前我是堆，你是栈<br>你总是能精准的找到我，给我指明出路<br>后来有一天我明白了<br>我变成了栈，你却隐身堆海<br>我却找不到你了，空指针了<br>我不愿意如此，在下一轮full gc前<br>我找到了object家的finalize<br>又找到了你，这次我不会放手</p><p>在世界重启前，一边躲着full gc一边老去</p><p><span style="color:red;background:rgb(165, 216, 185);font-size:35px;font-family:微软雅黑;">java 不是最强的语言 jvm是最强的虚拟机</span></p><h1 id="第1章-JVM和Java体系架构"><a href="#第1章-JVM和Java体系架构" class="headerlink" title="第1章-JVM和Java体系架构"></a>第1章-JVM和Java体系架构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你是否也遇到过这些问题？</p><ol><li><p>运行着的线上系统突然卡死，系统无法访问，甚至直接OOM！</p><blockquote><p>OOM 内存溢出</p></blockquote></li><li><p>想解决线上JVM GC问题，但却无从下手。</p><blockquote><p>GC 垃圾回收机制</p></blockquote></li><li><p>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了。</p></li><li><p>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</p></li></ol><img src="/chapter_001/0001.png"><p>大部分Java开发人员，除了会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。</p><h2 id="我们为什么要学习JVM"><a href="#我们为什么要学习JVM" class="headerlink" title="我们为什么要学习JVM"></a>我们为什么要学习JVM</h2><ol><li>面试的需要（BATJ、TMD，PKQ等面试都爱问）</li><li>中高级程序员必备技能</li></ol><ul><li>项目管理、调优的需要</li></ul><ol start="3"><li>追求极客的精神，<ul><li>比如：垃圾回收算法、JIT、底层原理</li></ul></li></ol><h2 id="Java-跨平台的语言"><a href="#Java-跨平台的语言" class="headerlink" title="Java-跨平台的语言"></a>Java-跨平台的语言</h2><img src="D:/software_engineering/java/JVM/01内存与垃圾回收篇_上篇/image/chapter_001/0009.png"><h2 id="JVM-跨语言的平台"><a href="#JVM-跨语言的平台" class="headerlink" title="JVM-跨语言的平台"></a>JVM-跨语言的平台</h2><img src="D:/software_engineering/java/JVM/01内存与垃圾回收篇_上篇/image/chapter_001/0010.png"><ol><li>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</li><li>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</li></ol><ul><li><strong>Java不是最强大的语言，但是JVM是最强大的虚拟机</strong></li></ul><ol><li><p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：<span style="color:red">jvm字节码</span>。</p></li><li><p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p></li><li><p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</p></li></ol><h2 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h2><ol><li><span style="color:red">Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向</span>。</li><li>试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby&#x2F;Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<span style="color:red">各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上</span>。</li><li>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），<span style="color:red">推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展</span>。</li></ol><h2 id="Open-JDK和Oracle-JDK"><a href="#Open-JDK和Oracle-JDK" class="headerlink" title="Open JDK和Oracle JDK"></a>Open JDK和Oracle JDK</h2><img src="D:/software_engineering/java/JVM/01内存与垃圾回收篇_上篇/image/chapter_001/0012.png"><ul><li>在JDK11之前，Oracle JDK中还会存在一些Open JDK中没有的，闭源的功能。但在JDK11中，我们可以认为Open JDK和Oracle JDK代码实质上已经达到完全一致的程度了。</li><li>主要的区别就是两者更新周期不一样</li></ul><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="虚拟机概念"><a href="#虚拟机概念" class="headerlink" title="虚拟机概念"></a>虚拟机概念</h3><ul><li><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，<span style="color:red">虚拟机可以分为系统虚拟机和程序虚拟机</span>。</p><ul><li>大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们<span style="color:red">完全是对物理计算机硬件的仿真(模拟)</span>，提供了一个可运行完整操作系统的软件平台。</li></ul><ul><li>程序虚拟机的典型代表就是Java虚拟机，它<span style="color:red">专门为执行单个计算机程序而设计</span>，在Java虚拟机中执行的指令我们称为Java字节码指令。</li></ul></li><li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p></li></ul><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><ol><li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li><li><span style="color:red">JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器</span>。</li><li><span style="color:red"><strong>Java技术的核心就是Java虚拟机</strong></span>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li></ol><p><strong>作用：</strong></p><p><span style="color:red">Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行</span>。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><p><strong>特点：</strong></p><ol><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ol><blockquote><p>c语言 一次编写 到处编译 </p></blockquote><h2 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h2><p><span style="color:red">JVM是运行在操作系统之上的，它与硬件没有直接的交互</span></p><img src="D:/software_engineering/java/JVM/01内存与垃圾回收篇_上篇/image/chapter_001/0013.png"><p>jvm 解释某一个应用程序</p><img src="D:/software_engineering/java/JVM/01内存与垃圾回收篇_上篇/image/chapter_001/0014.png"><blockquote><h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h2><blockquote><p>JVM是JRE的一部分,是虚拟出来的一台计算机.通过实体计算机仿真各种计算功能来实现,JVM有自己完善的硬件架构,如处理器,堆栈,寄存器等,还有相应的指令集.JVM是Java跨平台的核心,Java程序通过JVM的跨平台,从而使Java程序跨平台.Java程序首选会被编译成字节码文件(.class),JVM的核心任务就是解释字节码文件(.class)并映射到真实CPU指令集或者系统调用.JVM不关心上层Java程序,只关心字节码(.class).</p></blockquote><h2 id="什么是JRE"><a href="#什么是JRE" class="headerlink" title="什么是JRE"></a>什么是JRE</h2><blockquote><p>JRE是Java运行环境,所有Java程序必须依赖JRE才能运行.只有JVM是不能运行字节码文件的(.class),因为解释的字节码的时候需要lib库. JRE里面有两个文件夹<code>bin/</code>,<code>lib/</code>。<code>bin/</code>就是JVM,<code>lib</code>就是JVM所需要库。JVM+<code>lib</code>&#x3D;JRE</p></blockquote><h2 id="什么是JDK"><a href="#什么是JDK" class="headerlink" title="什么是JDK"></a>什么是JDK</h2><blockquote><p>JDK是Java的核心,包含运行Java运行环境(JRE)和一些Java工具及Java基础类库 。</p></blockquote></blockquote><h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><ol><li><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</p></li><li><p>它采用解释器与即时编译器并存的架构。</p></li><li><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++程序一较高下的地步。</p></li></ol><img src="D:/software_engineering/java/JVM/01内存与垃圾回收篇_上篇/image/chapter_001/0015.png"><h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><p>凡是能生成被Java虚拟机所能解释、运行的字节码文件，那么理论上我们就可以自己设计一套语言了</p><img src="D:/software_engineering/java/JVM/01内存与垃圾回收篇_上篇/image/chapter_001/0016.png"><h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种<span style="color:red"><strong>基于栈的指令集架构</strong></span>，另外一种指令集架构则是<span style="color:red"><strong>基于寄存器的指令集架构</strong></span>。具体来说：这两种架构之间的区别：</p><h3 id="基于栈的指令集架构"><a href="#基于栈的指令集架构" class="headerlink" title="基于栈的指令集架构"></a>基于栈的指令集架构</h3><p><strong>基于栈式架构的特点：</strong></p><ol><li>设计和实现更简单，适用于资源受限的系统；</li><li><strong>避开了寄存器的分配难题：使用零地址指令方式分配</strong></li><li><span style="color:red">指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</span><ul><li>在栈中数据是先进后出 只操作栈顶元素 不需要使用 地址位 来确认该指令的位置</li><li>指令集小 但指令多</li></ul></li><li>栈基于内存 不需要硬件支持，可移植性更好，更好实现跨平台</li></ol><h3 id="基于寄存器的指令级架构"><a href="#基于寄存器的指令级架构" class="headerlink" title="基于寄存器的指令级架构"></a>基于寄存器的指令级架构</h3><p><strong>基于寄存器架构的特点：</strong></p><ol><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li><span style="color:red">指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差</span></li><li><span style="color:red">性能优秀和执行更高效</span></li><li>花费更少的指令去完成一项操作</li><li>在大部分情况下，基于寄存器架构的</li><li>指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li></ol><h3 id="两种架构的举例"><a href="#两种架构的举例" class="headerlink" title="两种架构的举例"></a>两种架构的举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p><ul><li><p><strong>基于栈的计算流程（以Java虚拟机为例）：</strong></p><pre><code class="hljs java">iconst_2 <span class="hljs-comment">//常量2入栈</span>istore_1iconst_3 <span class="hljs-comment">// 常量3入栈</span>istore_2iload_1iload_2iadd <span class="hljs-comment">//常量2/3出栈，执行相加</span>istore_0 <span class="hljs-comment">// 结果5入栈</span></code></pre><p>8个指令</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">jvmtest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<span class="hljs-comment">//        int i =2 + 3;</span>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">2</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span><span class="hljs-number">3</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i+j;    &#125;&#125;</code></pre><img src="D:/software_engineering/java/JVM/01内存与垃圾回收篇_上篇/image/chapter_001/Snipaste_2023-03-12_15-05-00.png"></li><li><p><strong>而基于寄存器的计算流程</strong></p><pre><code class="hljs java">mov eax,<span class="hljs-number">2</span> <span class="hljs-comment">//将eax寄存器的值设为1</span>add eax,<span class="hljs-number">3</span> <span class="hljs-comment">//使eax寄存器的值加3</span></code></pre><p>2个指令</p></li></ul><blockquote><p>具体后面会讲</p></blockquote><h3 id="JVM架构总结"><a href="#JVM架构总结" class="headerlink" title="JVM架构总结"></a>JVM架构总结</h3><ol><li><span style="color:red"><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong></span>。不同平台CPU架构不同，所以不能设计为基于寄存器的。<strong>栈的优点：跨平台，指令集小，编译器容易实现，缺点是 指令数量多 性能比寄存器差一些</strong>。</li><li>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？<ul><li>因为基于栈的架构跨平台性好、指令集小，虽然相对于基于寄存器的架构来说，基于栈的架构编译得到的指令更多，执行性能也不如基于寄存器的架构好，但考虑到其跨平台性与移植性，我们还是选用栈的架构</li></ul></li></ol><h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ol><li><p>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</p></li><li><p>程序开始执行时他才运行，程序结束时他就停止</p></li><li><p><span style="color:red"><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</strong></span></p><blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">jvmtest</span> &#123; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<span class="hljs-comment">//        int i =2 + 3;</span>     <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">2</span>;     <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span><span class="hljs-number">3</span>;     <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i+j;     <span class="hljs-keyword">try</span> &#123;         Thread.sleep(<span class="hljs-number">6000</span>);     &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;         e.printStackTrace();     &#125;     System.out.println(<span class="hljs-string">&quot;hello&quot;</span>); &#125;&#125;</code></pre><p><img src="D:/software_engineering/java/JVM/01内存与垃圾回收篇_上篇/image/chapter_001/Snipaste_2023-03-12_15-18-33.png"></p></blockquote></li></ol><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p><strong>有如下的几种情况：</strong></p><ol><li><p>程序正常执行结束</p></li><li><p>程序在执行过程中遇到了异常或错误而异常终止</p></li><li><p>由于操作系统用现错误而导致Java虚拟机进程终止</p></li><li><p>某线程调用Runtime类或System类的exit()方法，或Runtime类的halt()方法，并且Java安全管理器也允许这次exit()或halt()操作。</p></li><li><p>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</p></li></ol><h2 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ol><li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是<strong>世界上第一款商用Java虚拟机</strong>，JDK1.4时完全被淘汰。</li><li>这款虚拟机内部只提供解释器，没有即时编译器，因此效率比较低。【即时编译器会把热点代码的本地机器指令缓存起来，那么以后使用热点代码的时候，效率就比较高】</li><li><span style="color:rgb(204, 169, 87)">如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作，解释器和编译器不能配合工作</span>。<ul><li>我们将字节码指令翻译成机器指令也是需要花时间的，如果只使用JIT，就需要把所有字节码指令都翻译成机器指令，就会导致翻译时间过长，也就是说在程序刚启动的时候，等待时间会很长。</li><li>而解释器就是走到哪，解释到哪。</li><li>classicvm jvm的引擎中往往是 解释器和 JIT结合使用 有点像是（并发大概理解下…. )</li></ul></li><li>现在Hotspot内置了此虚拟机(classic VM)<ul><li><em>classic VM 的引擎中有解释器 没有及时编译器 (JIT)  效率低下</em></li></ul></li></ol><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ol><li><p>为了解决上一个虚拟机问题，jdk1.2时，Sun提供了此虚拟机。</p></li><li><p>Exact Memory Management：准确式内存管理</p><ul><li><p>也可以叫Non-Conservative&#x2F;Accurate Memory Management</p></li><li><p>虚拟机可以知道内存中某个位置的数据具体是什么类型。</p></li></ul></li><li><p>具备现代高性能虚拟机的维形</p><ul><li><p>热点探测（寻找出热点代码进行缓存）</p></li><li><p>编译器与解释器混合工作模式</p></li></ul></li><li><p>只在Solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</p></li></ol><h3 id="HotSpot-VM（重点）"><a href="#HotSpot-VM（重点）" class="headerlink" title="HotSpot VM（重点）"></a>HotSpot VM（重点）</h3><ol><li><p>HotSpot历史</p><ul><li><p>最初由一家名为“Longview Technologies”的小公司设计</p></li><li><p>1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。</p></li><li><p>JDK1.3时，HotSpot VM成为默认虚拟机</p></li></ul></li><li><p>目前<strong>Hotspot占有绝对的市场地位，称霸武林</strong>。</p><ul><li><p>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</p></li><li><p>Sun&#x2F;oracle JDK和openJDK的默认虚拟机</p></li><li><p>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。（比如其他两个商用虚机都没有方法区的概念）</p></li></ul></li><li><p>从服务器、桌面到移动端、嵌入式都有应用。</p></li><li><p>名称中的HotSpot指的就是它的<span style="color:red">热点代码探测技术</span>。</p><ul><li><p>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</p></li><li><p><span style="color:red">通过编译器与解释器协同工作</span>，在最优化的程序响应时间与最佳执行性能中取得平衡</p></li></ul></li></ol><h3 id="JRockit（商用三大虚拟机之一）"><a href="#JRockit（商用三大虚拟机之一）" class="headerlink" title="JRockit（商用三大虚拟机之一）"></a>JRockit（商用三大虚拟机之一）</h3><ol><li><p><span style="color:red">专注于服务器端应用</span>：它可以不太关注程序启动速度，<strong>因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行</strong>。</p></li><li><p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM</p><ul><li>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li></ul></li><li><p>优势：全面的Java运行时解决方案组合</p><ul><li><p>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</p></li><li><p>Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</p></li></ul></li><li><p>2008年，JRockit被Oracle收购。</p></li><li><p>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p></li><li><p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p></li></ol><h3 id="IBM的J9（商用三大虚拟机之一）"><a href="#IBM的J9（商用三大虚拟机之一）" class="headerlink" title="IBM的J9（商用三大虚拟机之一）"></a>IBM的J9（商用三大虚拟机之一）</h3><ol><li><p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</p></li><li><p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</p></li><li><p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机(在自己的产品中使用 )。</p></li><li><p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9</p></li><li><p>OpenJDK -&gt; 是JDK开源了，包括了虚拟机</p></li></ol><h3 id="KVM和CDC-CLDC-Hotspot"><a href="#KVM和CDC-CLDC-Hotspot" class="headerlink" title="KVM和CDC&#x2F;CLDC Hotspot"></a>KVM和CDC&#x2F;CLDC Hotspot</h3><ol><li><p>Oracle在Java ME产品线上的两款虚拟机为：CDC&#x2F;CLDC HotSpot Implementation VM </p></li><li><p>KVM（Kilobyte）是CLDC-HI早期产品</p></li><li><p>目前移动领域地位尴尬，智能机被Android和iOS二分天下。</p></li><li><p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li><p>智能控制器、传感器</p></li><li><p>老人手机、经济欠发达地区的功能手机</p></li></ul></li><li><p>所有的虚拟机的原则：一次编译，到处运行。</p></li></ol><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><ol><li>前面三大“高性能Java虚拟机”使用在<strong>通用硬件平台上</strong></li><li>这里Azul VW和BEA Liquid VM是与<strong>特定硬件平台绑定</strong>、软硬件配合的专有虚拟机：高性能Java虚拟机中的战斗机。</li><li>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机。</li><li>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</li><li>2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</li></ol><h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><ol><li>高性能Java虚拟机中的战斗机。</li><li>BEA公司开发的，直接运行在自家Hypervisor系统上</li><li>Liquid VM即是现在的JRockit VE（Virtual Edition）。<strong>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等</strong>。</li><li>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</li></ol><h3 id="Apache-Marmony"><a href="#Apache-Marmony" class="headerlink" title="Apache Marmony"></a>Apache Marmony</h3><ol><li><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</p></li><li><p>它是IElf和Intel联合开发的开源JVM，受到同样开源的Open JDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p></li><li><p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p></li></ol><h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><ol><li><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p></li><li><p>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</p></li><li><p>1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了Sun很多钱。微软WindowsXP SP3中抹掉了其VM。现在Windows上安装的jdk都是HotSpot。</p></li></ol><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><ol><li><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p></li><li><p><strong>基于OpenJDK开发了自己的定制版本AlibabaJDK</strong>，简称AJDK。是整个阿里Java体系的基石。</p></li><li><p>基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p><ul><li>创新的GCIH（GCinvisible heap）技术实现了off-heap，<strong>即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的</strong>。</li><li>GCIH中的<strong>对象还能够在多个Java虚拟机进程中实现共享</strong></li><li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li><li>PMU hardware的Java profiling tool和诊断协助功能</li><li>针对大数据场景的ZenGC</li></ul></li><li><p>taobao vm应用在阿里产品上性能高，<strong>硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</strong></p></li></ol><ul><li>目前已经在淘宝、天猫上线，把Oracle官方JvM版本全部替换了。</li></ul><h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><ol><li><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p></li><li><p><strong>Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”</strong>，它没有遵循 Java虚拟机规范</p></li><li><p>不能直接执行Java的Class文件</p></li><li><p>基于寄存器架构，不是jvm的栈架构。</p></li><li><p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p></li></ol><ul><li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li></ul><ol start="7"><li>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</li></ol><h3 id="Graal-VM（未来虚拟机）"><a href="#Graal-VM（未来虚拟机）" class="headerlink" title="Graal VM（未来虚拟机）"></a>Graal VM（未来虚拟机）</h3><ol><li><p>2018年4月，Oracle Labs公开了GraalvM，号称 “<strong>Run Programs Faster Anywhere</strong>”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</p></li><li><p>GraalVM在HotSpot VM基础上增强而成的<strong>跨语言全栈虚拟机，可以作为“任何语言”</strong>的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</p></li><li><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p></li><li><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p></li><li><p><strong>如果说HotSpot有一天真的被取代，Graalvm希望最大</strong>。但是Java的软件生态没有丝毫变化。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以前我是堆，你是栈&lt;br&gt;你总是能精准的找到我，给我指明出路&lt;br&gt;后来有一天我明白了&lt;br&gt;我变成了栈，你却隐身堆海&lt;br&gt;我却找不到你了，空指针了&lt;br&gt;我不愿意如此，在下一轮full gc前&lt;br&gt;我找到了object家的finalize&lt;br&gt;又找到了你，这次我不会</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Docker-高阶</title>
    <link href="http://example.com/2022/11/25/Docker%E9%AB%98%E9%98%B6%E7%AF%87/"/>
    <id>http://example.com/2022/11/25/Docker%E9%AB%98%E9%98%B6%E7%AF%87/</id>
    <published>2022-11-25T05:20:24.000Z</published>
    <updated>2024-03-12T09:43:43.748Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.yuque.com/tmfl/cloud">Docker笔记</a></p><h3 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h3><p><strong>主从复制原理</strong>：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/164518315">小白都能懂的Mysql主从复制原理（原理+实操） - 知乎 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/panrenjun/article/details/114219097">Mysql主从同步时Slave_IO_Running：Connecting ； Slave_SQL_Running：Yes的情况故障排除_slave-sql-running防火墙-CSDN博客</a></li><li></li></ul><ol><li>创建主服务器容器实例</li></ol><pre><code class="hljs shell">docker run --name Mysql_master -v /DockerRegistry/mysql-master/logs:/var/log/mysql -v /DockerRegistry/mysql-master/data:/var/lib/mysql -v/DockerRegistry/mysql-master/conf:/etc/mysql/conf.d -v /DockerRegistry/mysql-master/mysql-files:/var/lib/mysql-files -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root   -d mysql:8.0.21<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">已开启数量卷备份   备份了数据  日志  配置</span></code></pre><ol start="2"><li>在配置页面下面新建my.cnf</li></ol><pre><code class="hljs shell">[mysqld]<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 设置server_id, 同一个局域网中需要唯一</span></span>server_id=101<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 指定不需要同步的数据库名称</span></span>binlog-ignore-db=mysql<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 开启二进制日志功能</span></span>log-bin=mall-mysql-bin<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 设置二进制日志使用内存大小（事务）</span></span>binlog_cache_size=1M<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 设置使用的二进制日志格式（mixed,statement,row）</span></span>binlog_format=mixed<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 二进制日志过期清理时间。默认值为0，表示不自动清理</span></span>expire_logs_days=7<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断</span></span><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span>slave_skip_errors=1062</code></pre><ol start="3"><li>重启mysql_master 主机实例</li></ol><pre><code class="hljs shell">docker restart</code></pre><ol start="4"><li>进入mysql主机,并且授予对应权限</li></ol><pre><code class="hljs mysql">create user &#x27;slave&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</code></pre><ol start="5"><li><p>创建从服务器</p><pre><code class="hljs shell">docker run --name Mysql_slave -v /DockerRegistry/mysql-slave/logs:/var/log/mysql -v /DockerRegistry/mysql-slave/data:/var/lib/mysql -v /DockerRegistry/mysql-slave/conf:/etc/mysql/conf.d -v /DockerRegistry/mysql-slave/mysql-files:/var/lib/mysql-files  -p 3308:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0.21<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">已开启数量卷备份   备份了数据  日志  配置</span></code></pre></li><li><p>配置从mysql的配置文件</p></li></ol><pre><code class="hljs shell">[mysqld]<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 设置server_id, 同一个局域网内需要唯一</span></span>server_id=102<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 指定不需要同步的数据库名称</span></span>binlog-ignore-db=mysql<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 开启二进制日志功能，以备slave作为其它数据库实例的Master时使用</span></span>log-bin=mall-mysql-slave1-bin<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 设置二进制日志使用内存大小（事务）</span></span>binlog_cache_size=1M<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 设置使用的二进制日志格式（mixed,statement,row）</span></span>binlog_format=mixed<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 二进制日志过期清理时间。默认值为0，表示不自动清理</span></span>expire_logs_days=7<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断</span></span><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 如：1062错误是指一些主键重复，1032是因为主从数据库数据不一致</span></span>slave_skip_errors=1062<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># relay_log配置中继日志</span></span>relay_log=mall-mysql-relay-bin<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span>log_slave_updates=1<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># slave设置只读（具有super权限的用户除外）</span></span>read_only=1</code></pre><ol start="7"><li>进入主mysql中查看mysql同步状态</li></ol><pre><code class="hljs mysql">show master status;</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-05_12-48-02.png"></p><ol start="8"><li><p>配置从数据库所属的主数据库  重启 从mysql 进入 从mysql  </p><pre><code class="hljs mysql">-- 格式：-- change master to master_host=&#x27;宿主机ip&#x27;,master_user=&#x27;主数据库配置的主从复制用户名&#x27;,master_password=&#x27;主数据库配置的主从复制用户密码&#x27;,master_port=宿主机主数据库端口,master_log_file=&#x27;主数据库主从同步状态的文件名File&#x27;,master_log_pos=主数据库主从同步状态的Position,master_connect_retry=连接失败重试时间间隔（秒）;change master to master_host=&#x27;192.168.70.138&#x27;,master_user=&#x27;slave&#x27;,master_password=&#x27;123456&#x27;,master_port=3307,master_log_file=&#x27;mall-mysql-bin.000002&#x27;,master_log_pos=156,master_connect_retry=30;</code></pre></li><li><p>在从数据库中查看主从同步状态</p><pre><code class="hljs MYSQL">show slave status /G;-- /G 另一种显示格式      不加\G 是从左到右的表格格式   加\G 是键值对的形式显示数据</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-05_13-06-25.png"></p></li><li><p>在从数据库中开启主从复制</p><pre><code class="hljs mysql">start slave</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-05_15-54-53.png"></p></li></ol><blockquote><p>配置小坑</p><ol><li>在远程连接中 必须使用防火墙开启指定端口 不安比防火墙无法访问所有端口</li><li>mysql8必须将plugin修改为<em><strong>mysql_native_password</strong></em></li></ol></blockquote><h3 id="Redis集群配置"><a href="#Redis集群配置" class="headerlink" title="Redis集群配置"></a>Redis集群配置</h3><ol><li>创建六台redis集群</li></ol><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">--cluster-enabled <span class="hljs-built_in">yes</span>   开启集群模式</span><span class="hljs-meta prompt_"># </span><span class="language-bash">--net host使用宿主机的IP和端口，默认</span>docker run -d --name redis-node-1 --net host --privileged=true -v /DockerRegistry/redis-cluster/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381docker run -d --name redis-node-2 --net host --privileged=true -v /DockerRegistry/redis-cluster/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382docker run -d --name redis-node-3 --net host --privileged=true -v /DockerRegistry/redis-cluster/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383docker run -d --name redis-node-4 --net host --privileged=true -v /DockerRegistry/redis-cluster/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384docker run -d --name redis-node-5 --net host --privileged=true -v /DockerRegistry/redis-cluster/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385docker run -d --name redis-node-6 --net host --privileged=true -v /DockerRegistry/redis-cluster/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386</code></pre><ol start="2"><li><p>构建主从关系：</p><ol><li>进入节点1（或其中任意一个节点）:</li></ol>   <pre><code class="hljs shell">docker exec -it redis-node-1 /bin/bash</code></pre><ol start="2"><li><p>构建主从关系</p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">宿主机IP:端口</span>   <span class="hljs-meta prompt_"># </span><span class="language-bash">--cluster-replicas 1 表示为每个master创建一个slave节点</span>redis-cli --cluster create 192.168.70.138:6381 192.168.70.138:6382 192.168.70.138:6383 192.168.70.138:6384 192.168.70.138:6385 192.168.70.138:6386 --cluster-replicas 1</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-05_17-56-02.png"></p><p><img src="/%5Cimage%5CSnipaste_2023-11-05_17-56-46.png"></p></li><li><p>查看集群状态redis-cli -p 6381：</p><pre><code class="hljs shell">redis-cli -p 6381cluster infocluster nodes</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-05_18-04-00.png"></p></li></ol></li><li><p>主从容错迁移案例</p><ol><li><p>数据读写存储</p><ul><li><p>当使用 <code>redis-cli</code>连接redis集群时，需要添加 <code>-c</code>参数，否则可能会出现读写出错。</p><blockquote><p>因为根据哈希槽算法中，不同的取余值要在不用的节点中存放(书写）,我们在redis中输入的存放命令要先在CRC16中进行映射，获取数值，再将该数据进行16384进行取余，根据获取的取余数值确定应该在哪个redis-master中进行存值。不在指定的主数据库中存值会报错。</p></blockquote><img src="\image\Snipaste_2023-11-05_19-08-37.png" style="zoom:50%;" /><img src="\image\Snipaste_2023-11-05_19-09-11.png" style="zoom:50%;" /></li><li><p>查看集群信息</p><pre><code class="hljs shell">redis-cli --cluster check 192.168.70.138:6381</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-05_19-15-36.png"></p></li></ul></li><li><p><strong>主从容错切换迁移</strong></p><ul><li><p>停掉 6381 redis     对应的从机变成了主机</p><p><img src="/%5Cimage%5CSnipaste_2023-11-05_19-28-45.png"></p><p><img src="/%5Cimage%5CSnipaste_2023-11-05_19-29-27.png"></p></li><li><p>恢复6381    6381变为了从机   6384变为了主机</p><p><img src="/%5Cimage%5CSnipaste_2023-11-05_19-30-20.png"></p></li><li><p>恢复6381的主机地位    停掉6384 一段时间后 再开启6384   6381主机地位恢复</p><p><img src="/%5Cimage%5CSnipaste_2023-11-05_19-37-11.png"></p></li></ul></li></ol></li><li><p>主从的扩容于缩容</p><ul><li><p>主从扩容</p><ul><li><p>新建6387、6388两个节点+新建后启动+查看是否8节点</p><pre><code class="hljs shell">docker run -d --name redis-node-7 --net host --privileged=true -v /DockerRegistry/redis-cluster/share/redis-node-7:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387docker run -d --name redis-node-8 --net host --privileged=true -v /DockerRegistry/redis-cluster/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388</code></pre></li><li><p>进入6387容器实例内部</p></li><li><p>将新增的6387节点（空槽号）作为master节点加入原集群</p><ul><li>将新增的6387作为master节点加入集群<br><code>redis-cli --cluster add-node自己实际lP地址:6387自己实际lP地址:6381 6387就是将要作为master新增节点</code><br>6381就是原来集群节点里面的领路人，相当于6387拜拜6381的码头从而找到组织加入集群</li></ul><pre><code class="hljs shell">redis-cli --cluster add-node 192.168.70.138:6387 192.168.70.138:6381</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-05_19-47-38.png"></p><p>还未分配槽位</p><p><img src="/%5Cimage%5CSnipaste_2023-11-05_19-53-09.png"></p><p><strong>重新分配槽号</strong></p><pre><code class="hljs shell">redis-cli --cluster reshard 192.168.70.138:6381</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-05_19-58-54.png"></p><p><img src="/%5Cimage%5CSnipaste_2023-11-05_20-01-32.png"></p></li><li><p>检查集群情况      不是从新分配，每个主机匀点给6387</p><p><img src="/%5Cimage%5CSnipaste_2023-11-05_20-03-05.png"></p></li><li><p>将6388 添加为6387的从主机</p><pre><code class="hljs shell">redis-cli --cluster add-node 192.168.70.138:6388 192.168.70.138:6387 --cluster-slave --cluster-master-id 1ff3a5d59f77fd8454fc531a1b8867cd2178b65b</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-05_20-22-12.png"></p><p><img src="/%5Cimage%5CSnipaste_2023-11-05_20-24-45.png"></p></li></ul></li><li><p>组从缩容   删除6387 和  6388</p><ul><li><p>先删除从机</p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 检查容器状态，获取6388的节点编号</span> redis-cli --cluster check 192.168.70.138:6381<span class="hljs-meta prompt_"># </span><span class="language-bash">2.将6388从集群中移除</span>  redis-cli --cluster del-node 192.168.70.138:6388 6388节点编号</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-05_20-33-55.png"></p></li><li><p>对node7重新分配哈希槽：</p><ol><li>对集群重新分配哈希槽</li></ol>   <pre><code class="hljs shell">redis-cli --cluster reshard 192.168.70.138:6381</code></pre><p>   <img src="/%5Cimage%5CSnipaste_2023-11-05_20-41-07.png"></p><ol start="2"><li><p>检查集群状态</p><pre><code class="hljs shell">redis-cli --cluster check 192.168.70.138:6381</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-05_20-43-49.png"></p></li><li><p>删除主节点 6387</p><pre><code class="hljs shell">redis-cli --cluster del-node 192.168.70.138:6387</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-05_20-46-08.png"></p></li></ol></li></ul></li></ul></li></ol><h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p><img src="/%5Cimage%5CSnipaste_2023-11-06_16-20-26.png" alt="独立于docker容器和镜像之外"></p><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条<strong>构建镜像</strong>所需的指令和参数构成的<strong>脚本</strong></p><blockquote><p>第二种构建镜像的方法</p></blockquote><p>构建三步骤</p><ol><li>编写DockerFile文件</li><li>docker build命令构建镜像</li><li>docker run 运行镜像</li></ol><p>DockerFile内容基础知识</p><ul><li>每条保留字指令都必须为大写字母且后面至少跟随一个参数</li><li>指令按照从上到下，顺序执行</li><li><code>#</code>表示注释</li><li>每条指令都会创建一个新的镜像层并对镜像进行提交</li></ul><blockquote><p>保留字 就是关键字</p></blockquote><p>Docker引擎执行Docker的大致流程：</p><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器做出修改</li><li>执行类似<code>docker commit</code>的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新容器</li><li>执行Dockerfile中的下一条指令，直到所有指令都执行完成</li></ol><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p><ul><li>Dockerfile是软件的原材料</li><li>Dockert镜像是软件的交付品</li><li>Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</li></ul><p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p><p><img src="/%5Cimage%5CSnipaste_2023-11-06_16-31-44.png"></p><h4 id="dockerfile-保留字"><a href="#dockerfile-保留字" class="headerlink" title="dockerfile 保留字"></a>dockerfile 保留字</h4><h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># FROM 镜像名</span><span class="hljs-keyword">FROM</span> hub.c.<span class="hljs-number">163</span>.com/library/tomcat</code></pre><h5 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h5><p>镜像维护者的姓名和邮箱地址</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># 非必须</span><span class="hljs-keyword">MAINTAINER</span> ZhangSan zs@<span class="hljs-number">163</span>.com</code></pre><h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p>容器构建时需要运行的命令。</p><p>有两种格式：</p><ul><li>shell格式</li></ul>  <pre><code class="hljs dockerfile"><span class="hljs-comment"># 等同于在终端操作的shell命令</span><span class="hljs-comment"># 格式：RUN &lt;命令行命令&gt;</span><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install vim</span></code></pre><ul><li><p>exec格式 </p><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式：RUN [&quot;可执行文件&quot; , &quot;参数1&quot;, &quot;参数2&quot;]</span><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;./test.php&quot;</span>, <span class="hljs-string">&quot;dev&quot;</span>, <span class="hljs-string">&quot;offline&quot;</span>]  <span class="hljs-comment"># 等价于 RUN ./test.php dev offline</span></span></code></pre><blockquote><p><code>RUN</code>是在<code>docker build</code>时运行</p></blockquote></li></ul><h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><p>当前容器对外暴露出的端口。</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># EXPOSE 要暴露的端口</span><span class="hljs-comment"># EXPOSE &lt;port&gt;[/&lt;protocol] ....</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3306</span> <span class="hljs-number">33060</span></code></pre><h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><p>指定在创建容器后， 终端默认登录进来的工作目录。</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> CATALINA_HOME /usr/local/tomcat<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$CATALINA_HOME</span></span></code></pre><h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><p>用来在构建镜像过程中设置环境变量。</p><p>这个环境变量可以在后续的任何<code>RUN</code>指令或其他指令中使用</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式 ENV 环境变量名 环境变量值</span><span class="hljs-comment"># 或者 ENV 环境变量名=值</span><span class="hljs-keyword">ENV</span> MY_PATH /usr/mytest<span class="hljs-comment"># 使用环境变量</span><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$MY_PATH</span></span></code></pre><h5 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h5><p>指定该镜像以什么样的用户去执行，如果不指定，默认是<code>root</code>。（一般不修改该配置）</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># USER &lt;user&gt;[:&lt;group&gt;]</span><span class="hljs-keyword">USER</span> patrick</code></pre><h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><p>容器数据卷，用于数据保存和持久化工作。类似于 <code>docker run</code> 的<code>-v</code>参数。</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># VOLUME 挂载点</span><span class="hljs-comment"># 挂载点可以是一个路径，也可以是数组（数组中的每一项必须用双引号）</span><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /var/lib/mysql</span></code></pre><h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><p>将宿主机目录下（或远程文件）的文件拷贝进镜像，且会自动处理URL和解压tar压缩包。</p><h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p>类似<code>ADD</code>，拷贝文件和目录到镜像中。</p><p>将从构建上下文目录中<code>&lt;源路径&gt;</code>的文件目录复制到新的一层镜像内的<code>&lt;目标路径&gt;</code>位置。</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> src dest</span><span class="hljs-keyword">COPY</span><span class="language-bash"> [<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;dest&quot;</span>]</span><span class="hljs-comment"># &lt;src源路径&gt;：源文件或者源目录</span><span class="hljs-comment"># &lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好。如果不存在会自动创建</span></code></pre><h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><p>指定容器启动后要干的事情。</p><p>有两种格式：</p><ul><li>shell格式</li></ul>  <pre><code class="hljs dockerfile"><span class="hljs-comment"># CMD &lt;命令&gt;</span><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span></span></code></pre><ul><li>exec格式</li></ul>  <pre><code class="hljs dockerfile"><span class="hljs-comment"># CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]</span><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;catalina.sh&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span></code></pre><ul><li><p>参数列表格式 </p><pre><code class="hljs dockerfile"><span class="hljs-comment"># CMD [&quot;参数1&quot;, &quot;参数2&quot; ....]，与ENTRYPOINT指令配合使用</span></code></pre><p>Dockerfile中如果出现多个<code>CMD</code>指令，只有最后一个生效。<code>CMD</code>会被<code>docker run</code>之后的参数替换。</p><p>例如，对于tomcat镜像，执行以下命令会有不同的效果：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">因为tomcat的Dockerfile中指定了 CMD [<span class="hljs-string">&quot;catalina.sh&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span><span class="hljs-meta prompt_"># </span><span class="language-bash">所以直接docker run 时，容器启动后会自动执行 catalina.sh run</span>docker run -it -p 8080:8080 tomcat<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">指定容器启动后执行 /bin/bash</span><span class="hljs-meta prompt_"># </span><span class="language-bash">此时指定的/bin/bash会覆盖掉Dockerfile中指定的 CMD [<span class="hljs-string">&quot;catalina.sh&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span>docker run -it -p 8080:8080 tomcat /bin/bash</code></pre><p><code>CMD</code>是在<code>docker run</code>时运行，而 <code>RUN</code>是在<code>docker build</code>时运行。</p></li></ul><h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><p>用来指定一个容器启动时要运行的命令。</p><p>类似于<code>CMD</code>命令，但是<code>ENTRYPOINT</code>不会被<code>docker run</code>后面的命令覆盖，这些命令参数会被当做参数送给<code>ENTRYPOINT</code>指令指定的程序。</p><p><code>ENTRYPOINT</code>可以和<code>CMD</code>一起用，一般是可变参数才会使用<code>CMD</code>，这里的<code>CMD</code>等于是在给<code>ENTRYPOINT</code>传参。</p><p>当指定了<code>ENTRYPOINT</code>后，<code>CMD</code>的含义就发生了变化，不再是直接运行期命令，而是将<code>CMD</code>的内容作为参数传递给<code>ENTRYPOINT</code>指令，它们两个组合会变成 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code>。</p><p>例如：</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>]  <span class="hljs-comment"># 定参</span></span><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参</span></span></code></pre><p>对于此Dockerfile，构建成镜像 <code>nginx:test</code>后，如果执行；</p><ul><li><p><code>docker run nginx test</code>，则容器启动后，会执行 <code>nginx -c /etc/nginx/nginx.conf</code></p></li><li><p><code>docker run nginx:test /app/nginx/new.conf</code>，则容器启动后，会执行 <code>nginx -c /app/nginx/new.conf</code></p></li></ul><h4 id="dockerfile案例演示"><a href="#dockerfile案例演示" class="headerlink" title="dockerfile案例演示"></a>dockerfile案例演示</h4><p>创建centos具有vim ifconfig java8的镜像</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><span class="hljs-keyword">MAINTAINER</span> zzyy&lt;zzyybs@<span class="hljs-number">126</span>.com&gt;<span class="hljs-keyword">ENV</span> MYPATH /usr/local <span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$MYPATH</span></span><span class="hljs-comment">#安装vim编辑器</span><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install vim</span><span class="hljs-comment">#安装1 fconfig命令查看网络IP </span><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install net-tools</span><span class="hljs-comment">#安装java8及lib库</span><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install glibc.i686</span><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /usr/local/java</span><span class="hljs-comment">#ADD是相对路径jar，把jdk8u171-1inux.x64.tar.gz添加到容器中，安装包必须要和Dockerfile文件在同一位置</span><span class="hljs-keyword">ADD</span><span class="language-bash"> jdk-8u181-linux-x64.tar.gz /usr/local/java/</span><span class="hljs-comment">#配置java环境变量</span><span class="hljs-keyword">ENV</span> JAVA_HOME /usr/local/java/jdk1.<span class="hljs-number">8.0</span>_181<span class="hljs-keyword">ENV</span> JRE HOME $JAVA_HOME/jre <span class="hljs-keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH <span class="hljs-keyword">ENV</span> PATH $JAVA_HOME/bin:$PATH <span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$MYPATH</span></span><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;success--------------ok&quot;</span></span><span class="hljs-keyword">CMD</span><span class="language-bash"> /bin/bash</span></code></pre><p>执行命令 docker build</p><pre><code class="hljs shell">docker build -t centosjava8:1.5 .</code></pre><blockquote><p>显示vim安装失败的话 先将centos版本号变为7 同时 写为 FROM centos:7 ，并且重启 vm即可</p></blockquote><h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>仓库名和镜像名都是none的镜像的，俗称dangling image</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;action success &#x27;</span></span></code></pre><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">构建时候没有镜像名、tag</span>docker build .</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-07_12-10-52.png"></p><p>列出docker中的虚悬镜像：</p><pre><code class="hljs shell">docker image ls -f dangling=true</code></pre><p>虚悬镜像一般是因为一些错误而出现的，没有存在价值，可以删除：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除所有的虚悬镜像</span>docker image prune</code></pre><p>.</p><h3 id="发布微服务项目到Docker容器"><a href="#发布微服务项目到Docker容器" class="headerlink" title="发布微服务项目到Docker容器"></a>发布微服务项目到Docker容器</h3><ol><li>将项目jar包发送到 服务器上面</li><li>编写dockerfile文件</li></ol><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><span class="hljs-keyword">MAINTAINER</span> hcj<span class="hljs-comment"># 在主机 /var/lib/docker目录下创建一个临时文件，并链接到容器的 /tmp</span><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp2</span><span class="hljs-comment"># 将jar包添加到容器中，并命名为 springboot_docker.jar</span><span class="hljs-keyword">ADD</span><span class="language-bash"> SpringBoot-Demo_1-1.0-SNAPSHOT.jar /springboot_docker.jar</span><span class="hljs-comment"># 运行jar包</span><span class="hljs-keyword">RUN</span><span class="language-bash"> bash -c <span class="hljs-string">&#x27;touch /springboot_docker.jar&#x27;</span></span><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/springboot_docker.jar&quot;</span>]</span><span class="hljs-comment"># SpringBoot项目配置的端口号为8080，需要将8080暴露出去</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span></code></pre><ol start="3"><li>运行docker容器</li></ol><pre><code class="hljs shell">docker build -t hcj_jar:1.3 .</code></pre><ol start="4"><li>启动容器：</li></ol><pre><code class="hljs shell">docker run -p8081:8080 --name springbootjar b16d189b87be</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-07_13-49-50.png"></p><h3 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h3><p>docker安装并启动服务后，会在宿主机中添加一个虚拟网卡。</p><p>在Docker服务启动前，使用 <code>ifconfig</code> 或 <code>ip addr</code> 查看网卡信息：</p><ul><li><p><code>ens33</code>或<code>eth0</code>：本机网卡</p></li><li><p><code>lo</code>：本机回环网络网卡</p><blockquote><p> 计算机以回环地址发送的消息，并不会由链路层送走，而是被本机网络层捕获。</p></blockquote></li><li><p>可能有<code>virbr0</code>（CentOS安装时如果选择的有相关虚拟化服务，就会多一个以网桥连接的私网地址的<code>virbr0</code>网卡，作用是为连接虚拟网卡提供NAT访问外网的功能。如果要移除该服务，可以使用 <code>yum remove libvirt-libs.x86_64</code>）</p></li></ul><p>使用 <code>systemctl start docker</code>启动Docker服务后，会多出一个 <code>docker0</code> 网卡。</p><p><strong>作用：</strong></p><ul><li><p>容器间的互联和通信以及端口映射</p></li><li><p>容器IP变动时候可以通过服务名直接网络通信而不受到影响</p></li></ul><p>Docker容器的网络隔离，是通过Linux内核特性 <code>namespace</code>和 <code>cgroup</code> 实现的。</p><h4 id="docker-网络模式命令"><a href="#docker-网络模式命令" class="headerlink" title="docker 网络模式命令"></a>docker 网络模式命令</h4><p>查看Docker网络模式：</p><pre><code class="hljs shell">docker network ls</code></pre><p>如果没有修改过docker network，则默认有3个网络模式：</p><ul><li><p><code>bridge</code></p></li><li><p><code>host</code></p></li><li><p><code>none</code></p></li></ul><img src="\image\Snipaste_2023-11-07_14-21-44.png" style="zoom:50%;" /><p><strong>添加Docker网络：</strong></p><pre><code class="hljs shell">docker network add xxx</code></pre><p><strong>删除Docker网络：</strong></p><pre><code class="hljs shell">docker network rm xxx</code></pre><p><strong>查看网络元数据：</strong></p><pre><code class="hljs shell">docker network inspect xxx</code></pre><p><strong>删除所有无效的网络：</strong></p><pre><code class="hljs shell">docker network prune</code></pre><h4 id="常见的Docker-网络模式"><a href="#常见的Docker-网络模式" class="headerlink" title="常见的Docker 网络模式"></a>常见的Docker 网络模式</h4><p>Docker 的网络模式：</p><table><thead><tr><th>网络模式</th><th>简介</th><th>使用方式</th></tr></thead><tbody><tr><td>bridge</td><td>为每一个容器分配、设置IP等，并将容器连接到一个<code>docker0</code>虚拟网桥，默认为该模式</td><td><code>--network bridge</code></td></tr><tr><td>host</td><td>容器将不会虚拟出自己的网卡、配置自己的IP等，而是使用宿主机的IP和端口</td><td><code>--network host</code></td></tr><tr><td>none</td><td>容器有独立的 Network namespace，但并没有对齐进行任何网络设置，如分配 <code>veth pari</code> 和 网桥连接、IP等</td><td><code>--network none</code></td></tr><tr><td>container</td><td>新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等</td><td><code>--network container:NAME或者容器ID</code></td></tr></tbody></table><blockquote><p>none网络模式是一种特殊的模式，它将容器与宿主机隔离开来，不提供任何网络能力。</p><p>在none网络模式下，容器将无法访问外部网络，也无法被外部网络访问到。这种模式适用于某些特殊场景，比如需要在容器内运行一些独立的、与网络无关的应用程序。</p><p><a href="https://blog.51cto.com/u_16213450/8157554">docker 网络 none_mob64ca12f4d1ad的技术博客_51CTO博客</a></p></blockquote><p>查看某个容器的网络模式：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过inspect获取容器信息，最后20行即为容器的网络模式信息</span>docker inspect 容器ID | tail -n 20</code></pre><h5 id="bridge-网络模式"><a href="#bridge-网络模式" class="headerlink" title="bridge 网络模式"></a>bridge 网络模式</h5><p>外界通过宿主机端口访问后，再交由底层NAT进行转发到docker容器网络中。</p><p><strong>docker0</strong></p><p>Docker 服务默认会创建一个<code>docker0</code>网桥（其上有一个<code>docker0</code>内部接口），该桥接网络的名称为 <code>docker0</code>，它在<strong>内核层</strong>连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到<code>同一个物理网络</code>。</p><p>Docker默认指定了<code>docker0</code>接口的IP地址和子网掩码，让主机和容器之间可以通过网桥互相通信。</p><p>查看<code>bridge</code>网络的详细信息，并通过<code>grep</code>获取名称：</p><pre><code class="hljs shell">docker network inspect bridge | grep name</code></pre><p>可以看到其名称为<code>docker0</code>。</p><img src="\image\Snipaste_2023-11-07_15-25-50.png" style="zoom:50%;" /><p><strong>bridge</strong></p><p>Docker使用Linux桥接，在宿主机虚拟一个<code>Docker</code>容器网桥（<code>docker0</code>），Docker启动一个容器时会根据<code>Docker</code>网桥的网段分配给容器一个IP地址，称为<code>Container-IP</code>，同时Docker网桥是每个容器的默认网关。因为在同一个宿主机内的容器接入同一个网桥，这样容器之间就能够通过容器的<code>Container-IP</code>直接通信。</p><p><code>docker run</code>的时候，没有指定<code>--network</code>的话，默认使用的网桥模式就是<code>bridge</code>，使用的就是<code>docker0</code>。在宿主机<code>ifconfig</code>就可以看到<code>docker0</code>和自己<code>create</code>的<code>network</code>。</p><p>网桥<code>docker0</code>创建一对对等虚拟设备接口，一个叫<code>veth</code>，另一个叫<code>eth0</code>，成对匹配：</p><p>整个宿主机的网桥模式都是<code>docker0</code>，类似一个交换机有一堆接口，每个接口叫 <code>veth</code>，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫做 <code>veth pair</code>）。</p><p>每个容器实例内部也有一块网卡，容器内的网卡接口叫做<code>eth0</code>。</p><p><code>docker0</code>上面的每个<code>veth</code>匹配某个容器实例内部的<code>eth0</code>，两两配对，一一匹配。</p><img src="\image\Snipaste_2023-11-07_15-29-01.png" style="zoom:50%;" /><p>例如：</p><p>宿主机</p><pre><code class="hljs shell">ip addr<span class="hljs-meta prompt_"># </span><span class="language-bash">每个veth都有个编号：vethXXXXXX</span><span class="hljs-meta prompt_"># </span><span class="language-bash">@符号后面对应就是容器内的eth0网卡编号9</span></code></pre><img src="\image\Snipaste_2023-11-07_15-48-29.png" style="zoom:50%;" /><p>docker容器</p><pre><code class="hljs shell">ip addr<span class="hljs-meta prompt_"># </span><span class="language-bash">容器内的网卡为 eth0</span><span class="hljs-meta prompt_"># </span><span class="language-bash">@符号后面就是宿主机上对应的veth网卡的编号10</span></code></pre><img src="\image\Snipaste_2023-11-07_15-48-56.png" style="zoom:50%;" /><p>.</p><h5 id="host-网络模式"><a href="#host-网络模式" class="headerlink" title="host 网络模式"></a>host 网络模式</h5><p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行 NAT 转换。</p><p>容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network space。</p><p>容器将不会虚拟出自己的网卡，而是直接使用宿主机的 IP 和端口。</p><img src="\image\Snipaste_2023-11-07_15-57-43.png" style="zoom:50%;" /><p>如果在 <code>docker run</code> 命令中同时使用了 <code>--network host</code> 和 <code>-p</code>端口映射，例如：</p><pre><code class="hljs shell">docker run -p 8082:8080 --network host tomcat</code></pre><p>那么会出现一个警告：</p><pre><code class="hljs plain">WARNING: Published ports are discarded when using host network mode</code></pre><p>因为此时已经使用了<code>host</code>模式，本身就是直接使用的宿主机的IP和端口，此时的<code>-p</code>端口映射就没有了意义，也不会生效，端口号还是会以主机端口号为主。p</p><p>正确做法是：不再进行<code>-p</code>端口映射，或者改用<code>bridge</code>模式</p><h5 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h5><p>禁用网络功能。</p><p>在<code>none</code>模式下，并不为docker容器进行任何网络配置。进入容器内，使用 <code>ip addr</code>查看网卡信息，只能看到 <code>lo</code>（本地回环网络<code>127.0.0.1</code>网卡）。</p><pre><code class="hljs shell">docker run -p 8082:8080 --network host tomcat</code></pre><h5 id="container-模式"><a href="#container-模式" class="headerlink" title="container 模式"></a>container 模式</h5><p>新建的容器和已经存在的一个容器共享网络IP配置，而不是和宿主机共享。</p><p>新创建的容器不会创建自己的网卡、IP，而是和一个指定的容器共享IP、端口范围。两个容器除了网络共享，其他的如文件系统、进程列表依然是隔离的。</p><img src="\image\Snipaste_2023-11-07_16-22-03.png" style="zoom:50%;" /><pre><code class="hljs shell">docker run -it --name alpine1 alpine /bin/sh<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">指定和 alpine1 容器共享网络</span>docker run -it --name alpine2 --network container:alpine1 alpine</code></pre><blockquote><p>Alpine Linux是一款独立的、非商业的通用Linux发行版，专为追求安全性、简单性和资源效率的用户而设计。可能很多人没听说过这个Liux发行版本，但是经常用Docker的朋友可能都用过，因为他小，简单，安全而著称，所以作为基础镜像是非常好的一个选择，可谓是麻雀虽小但五脏俱全，镜像非常小巧，不到6M的大小，所以特别适合容器打包I</p></blockquote><img src="\image\Snipaste_2023-11-07_16-29-41.png" style="zoom:50%;" /><p>此时使用 <code>ip addr</code>查看两台容器的网络，会发现两台容器的<code>eth0</code>网卡内的IP等信息完全相同。</p><p>如果关掉了<code>alpine1</code>容器，因为<code>alpine2</code>的网络使用的<code>alpine1</code>共享网络，所以关掉<code>alpin1</code>后，<code>alpine2</code>的<code>eth0</code>网卡也随之消失了。</p><h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><p>容器间的互联和通信以及端口映射。</p><p>容器 IP 变动时候可以通过服务名直接网络通信而不受影响。（类似Eureka，通过服务名直接互相通信，而不是写死IP地址）。</p><p>docker中还有一个 <code>--link</code> 进行容器网络互联，但是已经被标记为过时的，可能会在将来的版本中移除这个功能。推荐使用自定义网络替换link。</p><blockquote><p>在自定义网络中，可以使用Docker的DNS功能来为容器提供名称解析服务。当一个容器需要访问另一个容器时，它可以通过容器的名称或服务名来获取对方的IP地址，从而实现主机名和IP地址的对应关系。</p></blockquote><p>自定义桥接网络（自定义网络默认使用的是桥接网络 <code>bridge</code>）：</p><ol><li>新建自定义网络</li></ol>   <pre><code class="hljs shell">docker network create hcj_network</code></pre><ol start="2"><li><p>查看网络列表</p><pre><code class="hljs shell">docker network ls</code></pre></li><li><p>创建容器时 加入我们指定的自定义网络</p><pre><code class="hljs shell">docker run -it --name alpine1 --network hcj_networke alpinedocker run -it --name alpine2 --network hcj_networke alpine</code></pre></li><li><p>进入容器  使用ping命令测试连接alpine2容器名字 </p><img src="\image\Snipaste_2023-11-07_17-03-57.png" style="zoom:50%;" /></li></ol><h3 id="Docker-compose容器编排"><a href="#Docker-compose容器编排" class="headerlink" title="Docker-compose容器编排"></a><strong>Docker-compose容器编排</strong></h3><p><code>Docker-Compose</code> 是 Docker 官方的开源项目，负责实现对Docker容器集群的快速编排。</p><p><code>Docker-Compose</code>可以管理多个Docker容器组成一个应用。需要定义一个yaml格式的配置文件 <code>docker-compose.yml</code>，配置好多个容器之间的调用关系，然后只需要一个命令就能同时启动&#x2F;关闭这些容器。</p><p>Docker建议我们每个容器中只运行一个服务，因为Docker容器本身占用资源极少，所以最好是将每个服务单独的分割开来。但是如果我们需要同时部署多个服务，每个服务单独构建镜像构建容器就会比较麻烦。所以 Docker 官方推出了 <code>docker-compose</code> 多服务部署的工具。</p><p>Compose允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件来定义一组相关联的应用容器为一个项目（<code>project</code>）。<strong>可以很容易的用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建</strong>。</p><p>新版docker自带compose</p><pre><code class="hljs shell">docker compose version  <span class="hljs-meta prompt_"># </span><span class="language-bash">Docker Compose version v2.21.0</span></code></pre><p><strong>compose核心概念</strong></p><ul><li>一个文件 docker-compose.yml</li><li>两要素<ul><li>服务：一个个应用容器实例</li><li>工程：一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml文件中定义。</li></ul></li></ul><p><strong>compose常见命令</strong></p><img src="\image\Snipaste_2023-11-07_19-31-00.png" style="zoom:50%;" /><h4 id="使用compose编排服务器"><a href="#使用compose编排服务器" class="headerlink" title="使用compose编排服务器"></a>使用compose编排服务器</h4><ol><li><p>编排application.yml文件</p><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><span class="hljs-comment"># 配置各个容器服务</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">micr_yinglibao_api:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">micr-api-1.0.0</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">micr-api</span>  <span class="hljs-comment"># 容器名称，如果不指定，会生成一个服务名加上前缀的容器名</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/DockerRegistry/yinglibao/api:/data</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">springboot_yinglibao</span>        <span class="hljs-attr">micr_yinglibao_commo:</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">micr-common-1.0.0</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">micr-common</span>  <span class="hljs-comment"># 容器名称，如果不指定，会生成一个服务名加上前缀的容器名</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/DockerRegistry/yinglibao/common:/data</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">springboot_yinglibao</span>         <span class="hljs-attr">micr_yinglibao_dataservice:</span>          <span class="hljs-attr">image:</span> <span class="hljs-string">micr-dataservice-0.0.1-SNAPSHOT</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">micr-dataservice</span>  <span class="hljs-comment"># 容器名称，如果不指定，会生成一个服务名加上前缀的容器名</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/DockerRegistry/yinglibao/dataservice:/data</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">springboot_yinglibao</span>     <span class="hljs-attr">ports:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8086:8086&quot;</span>  <span class="hljs-attr">micr_yinglibao_web:</span>          <span class="hljs-attr">image:</span> <span class="hljs-string">mirc-web-0.0.1-SNAPSHOT</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">micr-web</span>  <span class="hljs-comment"># 容器名称，如果不指定，会生成一个服务名加上前缀的容器名</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/DockerRegistry/yinglibao/web:/data</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">springboot_yinglibao</span>     <span class="hljs-attr">ports:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8088:8088&quot;</span>  <span class="hljs-attr">micr_yinglibao_pay:</span>          <span class="hljs-attr">image:</span> <span class="hljs-string">micr-pay-0.0.1-SNAPSHOT</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">micr-pay</span>  <span class="hljs-comment"># 容器名称，如果不指定，会生成一个服务名加上前缀的容器名</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/DockerRegistry/yinglibao/pay:/data</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">springboot_yinglibao</span>     <span class="hljs-attr">ports:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9000:9000&quot;</span>  <span class="hljs-attr">micr_yinglibao_task:</span>          <span class="hljs-attr">image:</span> <span class="hljs-string">micr-task-0.0.1-SNAPSHOT</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">micr-task</span>  <span class="hljs-comment"># 容器名称，如果不指定，会生成一个服务名加上前缀的容器名</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/DockerRegistry/yinglibao/task:/data</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">springboot_yinglibao</span>     <span class="hljs-attr">ports:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8087:8087&quot;</span>     <span class="hljs-comment">#redis:</span><span class="hljs-comment">#   image: redis:6.0.8</span><span class="hljs-comment">#   ports:</span><span class="hljs-comment">#     - &quot;6379:6379&quot;</span><span class="hljs-comment">#   volumes:</span><span class="hljs-comment">#     - /app/redis/redis.conf:/etc/redis/redis.conf</span><span class="hljs-comment">#     - /app/redis/data:data</span><span class="hljs-comment">#   networks:</span><span class="hljs-comment">#     - springboot_network</span><span class="hljs-comment">#   command: redis-server /etc/redis/redis.conf</span><span class="hljs-comment"># mysql:</span><span class="hljs-comment">#   image: mysql:</span><span class="hljs-comment">#   environment:</span><span class="hljs-comment">#     MYSQL_ROOT_PASSWORD: &#x27;root&#x27;</span><span class="hljs-comment">#     MYSQL_ALLOW_EMPTY_PASSWORD: &#x27;no&#x27;</span><span class="hljs-comment">#     MYSQL_DATABASE: &#x27;yinglibao</span><span class="hljs-comment">#     MYSQL_USER: &#x27;springboot&#x27;</span><span class="hljs-comment">#     MYSQL_PASSWORD: &#x27;springboot&#x27;</span><span class="hljs-comment">#   ports:</span><span class="hljs-comment">#     - &quot;3306:3306&quot;</span><span class="hljs-comment">#   volumes:</span><span class="hljs-comment">#     - /app/mysql/db:/var/lib/mysql</span><span class="hljs-comment">#     - /app/mysql/conf/my.cnf:/etc/my.cnf</span><span class="hljs-comment">#     - /app/mysql/init:/docker-entrypoint-initdb.d</span><span class="hljs-comment">#   networks:</span><span class="hljs-comment">#     - springboot_network</span><span class="hljs-comment">#   command: --default-authentication-plugin=mysql_native_password # 解决外部无法访问</span><span class="hljs-attr">networks:</span>  <span class="hljs-comment"># 创建 springboot_network 网桥网络</span>  <span class="hljs-attr">springboot_yinglibao:</span></code></pre></li><li><p>编写完成<code>docker-compose.yml</code>后，进行语法检查：</p></li></ol><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进行语法检查</span>docker compose config -q</code></pre><ol start="3"><li>编写DockerFile 将jar包封装到Docker镜像中</li></ol><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><span class="hljs-keyword">MAINTAINER</span> hcj<span class="hljs-comment"># 在主机 /var/lib/docker目录下创建一个临时文件，并链接到容器的 /tmp</span><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp2</span><span class="hljs-comment"># 将jar包添加到容器中，并命名为 springboot_docker.jar</span><span class="hljs-keyword">ADD</span><span class="language-bash"> micr-api-1.0.0.jar /micr-api-1.0.0.jar</span><span class="hljs-comment"># 运行jar包</span><span class="hljs-keyword">RUN</span><span class="language-bash"> bash -c <span class="hljs-string">&#x27;touch micr-api-1.0.0.jar&#x27;</span></span><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/micr-api-1.0.0.jar&quot;</span>]</span><span class="hljs-comment"># SpringBoot项目配置的端口号为8080，需要将8080暴露出去</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><span class="hljs-keyword">MAINTAINER</span> hcj<span class="hljs-comment"># 在主机 /var/lib/docker目录下创建一个临时文件，并链接到容器的 /tmp</span><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp2</span><span class="hljs-comment"># 将jar包添加到容器中，并命名为 springboot_docker.jar</span><span class="hljs-keyword">ADD</span><span class="language-bash"> micr-common-1.0.0.jar /micr-common-1.0.0.jar</span><span class="hljs-comment"># 运行jar包</span><span class="hljs-keyword">RUN</span><span class="language-bash"> bash -c <span class="hljs-string">&#x27;touch micr-common-1.0.0.jar&#x27;</span></span><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;micr-common-1.0.0.jar&quot;</span>]</span><span class="hljs-comment"># SpringBoot项目配置的端口号为8080，需要将8080暴露出去</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><span class="hljs-keyword">MAINTAINER</span> hcj<span class="hljs-comment"># 在主机 /var/lib/docker目录下创建一个临时文件，并链接到容器的 /tmp</span><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp2</span><span class="hljs-comment"># 将jar包添加到容器中，并命名为 springboot_docker.jar</span><span class="hljs-keyword">ADD</span><span class="language-bash"> micr-dataservice-0.0.1-SNAPSHOT.jar /micr-dataservice-0.0.1-SNAPSHOT.jar</span><span class="hljs-comment"># 运行jar包</span><span class="hljs-keyword">RUN</span><span class="language-bash"> bash -c <span class="hljs-string">&#x27;touch micr-dataservice-0.0.1-SNAPSHOT.jar&#x27;</span></span><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/micr-dataservice-0.0.1-SNAPSHOT.jar&quot;</span>]</span><span class="hljs-comment"># SpringBoot项目配置的端口号为8080，需要将8080暴露出去</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8086</span><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><span class="hljs-keyword">MAINTAINER</span> hcj<span class="hljs-comment"># 在主机 /var/lib/docker目录下创建一个临时文件，并链接到容器的 /tmp</span><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp2</span><span class="hljs-comment"># 将jar包添加到容器中，并命名为 springboot_docker.jar</span><span class="hljs-keyword">ADD</span><span class="language-bash"> mirc-web-0.0.1-SNAPSHOT.jar /mirc-web-0.0.1-SNAPSHOT.jar</span><span class="hljs-comment"># 运行jar包</span><span class="hljs-keyword">RUN</span><span class="language-bash"> bash -c <span class="hljs-string">&#x27;touch mirc-web-0.0.1-SNAPSHOT.jar&#x27;</span></span><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/mirc-web-0.0.1-SNAPSHOT.jar&quot;</span>]</span><span class="hljs-comment"># SpringBoot项目配置的端口号为8080，需要将8080暴露出去</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8088</span><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><span class="hljs-keyword">MAINTAINER</span> hcj<span class="hljs-comment"># 在主机 /var/lib/docker目录下创建一个临时文件，并链接到容器的 /tmp</span><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp2</span><span class="hljs-comment"># 将jar包添加到容器中，并命名为 springboot_docker.jar</span><span class="hljs-keyword">ADD</span><span class="language-bash"> micr-task-0.0.1-SNAPSHOT.jar /micr-task-0.0.1-SNAPSHOT.jar</span><span class="hljs-comment"># 运行jar包</span><span class="hljs-keyword">RUN</span><span class="language-bash"> bash -c <span class="hljs-string">&#x27;touch micr-task-0.0.1-SNAPSHOT.jar&#x27;</span></span><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/micr-task-0.0.1-SNAPSHOT.jar&quot;</span>]</span><span class="hljs-comment"># SpringBoot项目配置的端口号为8080，需要将8080暴露出去</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8087</span><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><span class="hljs-keyword">MAINTAINER</span> hcj<span class="hljs-comment"># 在主机 /var/lib/docker目录下创建一个临时文件，并链接到容器的 /tmp</span><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp2</span><span class="hljs-comment"># 将jar包添加到容器中，并命名为 springboot_docker.jar</span><span class="hljs-keyword">ADD</span><span class="language-bash"> micr-pay-0.0.1-SNAPSHOT.jar micr-pay-0.0.1-SNAPSHOT.jar</span><span class="hljs-comment"># 运行jar包</span><span class="hljs-keyword">RUN</span><span class="language-bash"> bash -c <span class="hljs-string">&#x27;touch micr-pay-0.0.1-SNAPSHOT.jar&#x27;</span></span><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/micr-pay-0.0.1-SNAPSHOT.jar&quot;</span>]</span><span class="hljs-comment"># SpringBoot项目配置的端口号为8080，需要将8080暴露出去</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">9000</span></code></pre><ol start="4"><li>运行docker容器</li></ol><pre><code class="hljs shell">docker build -t hcj_yinglibao:1.3 .</code></pre><ol start="5"><li>如果语法检查没有任何问题，进行创建、启动：</li></ol><pre><code class="hljs shell">docker compose up -d</code></pre><h3 id="Docker轻量级可视化工具Portainer"><a href="#Docker轻量级可视化工具Portainer" class="headerlink" title="Docker轻量级可视化工具Portainer"></a>Docker轻量级可视化工具Portainer</h3><p>一款轻量级的应用，提供了图形化界面，用于方便的管理Docker环境，包括单机环境和集群环境</p><blockquote><p>Portainer分为开源社区版（CE版）和商用版（BE版&#x2F;EE版）。</p></blockquote><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">旧版镜像地址为portainer/portainer，从2022年1月标记为过期</span><span class="hljs-meta prompt_"># </span><span class="language-bash">新版镜像地址为portainer/portainer-ce</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">--restart=always 如果Docker引擎重启了，那么这个容器实例也会在Docker引擎重启后重启，类似开机自启</span>docker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart=always -v/var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce</code></pre><p>启动之后，便可以在浏览器中进行访问：<a href="http://192.168.70.138:9000/">http://192.168.70.138:9000</a></p><p>首次进来时，需要创建 admin 的用户名（默认<code>admin</code>）、密码（必须满足校验规则，例如<code>portainer.io123</code>）。</p><p>选择 <code>local</code>管理本地docker，即可看到本地Docker的详细信息，包括其中的镜像（images）、容器（containers）、网络（networks）、容器卷（volumes）、compose编排（stacks）等等。</p><h3 id="Docker容器监控之-CAdvisor-InfluxDB-Granfana"><a href="#Docker容器监控之-CAdvisor-InfluxDB-Granfana" class="headerlink" title="Docker容器监控之 CAdvisor+InfluxDB+Granfana"></a>Docker容器监控之 CAdvisor+InfluxDB+Granfana</h3><p>简称CIG</p><p>通过docker stats命令可以很方便的看到当前宿主机上所有容器的CPU，内存以及网络流量等数据，。<br>但是，docker stats统计结果只能是当前宿主机的全部容器，数据资料是实时的没有地方存储、没有健康指标过线预警等功能</p><p>CAdvisor（监控收集） + InfluxDB（存储数据） + Granfana（展示图表），合称 <code>CIG</code>。</p><img src="image\Snipaste_2023-11-08_15-40-59.png" style="zoom:50%;" /><h4 id="CAdvisor"><a href="#CAdvisor" class="headerlink" title="CAdvisor"></a>CAdvisor</h4><p>CAdvisor是一个容器资源监控工具，包括容器的内存、CPU、网络IO、磁盘IO等监控，同时提供了一个Web页面用于查看容器的实时运行状态。</p><p>CAdvisor默认存储2分钟的数据，而且只是针对单物理机。不过CAdvisor提供了很多数据集成接口，支持 InfluxDB、Redis、Kafka、Elasticsearch等集成，可以加上对应配置将监控数据发往这些数据库存储起来。</p><p>CAdvisor主要功能：</p><ul><li><p>展示Host和容器两个层次的监控数据</p></li><li><p>展示历史变化数据</p></li></ul><h4 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h4><p>InfluxDB是用Go语言编写的一个开源分布式时序、事件和指标数据库，无需外部依赖。</p><p>CAdvisor默认只在本机保存2分钟的数据，为了持久化存储数据和统一收集展示监控数据，需要将数据存储到InfluxDB中。InfluxDB是一个时序数据库，专门用于存储时序相关数据，很适合存储 CAdvisor 的数据。而且 CAdvisor本身已经提供了InfluxDB的集成方法，在启动容器时指定配置即可。</p><p><strong>InfluxDB主要功能：</strong></p><ul><li><p>基于时间序列，支持与时间有关的相关函数（如最大、最小、求和等）</p></li><li><p>可度量性，可以实时对大量数据进行计算</p></li><li><p>基于事件，支持任意的事件数据</p></li></ul><h4 id="Granfana"><a href="#Granfana" class="headerlink" title="Granfana"></a>Granfana</h4><p>Grafana是一个开源的数据监控分析可视化平台，支持多种数据源配置（支持的数据源包括InfluxDB、MySQL、Elasticsearch、OpenTSDB、Graphite等）和丰富的插件及模板功能，支持图表权限控制和报警。</p><p>Granfana主要功能：</p><ul><li><p>灵活丰富的图形化选项</p></li><li><p>可以混合多种风格</p></li><li><p>支持白天和夜间模式</p></li><li><p>多个数据源</p></li></ul><ol><li>安装部署</li></ol><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><span class="hljs-attr">volumes:</span>  <span class="hljs-attr">grafana_data:</span> &#123;&#125;<span class="hljs-attr">services:</span>  <span class="hljs-attr">influxdb:</span><span class="hljs-comment"># tutum/influxdb 相比influxdb多了web可视化视图。但是该镜像已被标记为已过时</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">tutum/influxdb:0.9</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">PRE_CREATE_DB=cadvisor</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8083:8083&quot;</span>         <span class="hljs-comment"># 数据库web可视化页面端口</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8086:8086&quot;</span>         <span class="hljs-comment"># 数据库端口</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/influxdb:/data</span>  <span class="hljs-attr">cadvisor:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">google/cadvisor:v0.32.0</span>    <span class="hljs-attr">links:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">influxdb:influxsrv</span>    <span class="hljs-attr">command:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">-storage_driver=influxdb</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">-storage_driver_db=cadvisor</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">-storage_driver_host=influxsrv:8086</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:8080&quot;</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/:/rootfs:ro</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run:/var/run:rw</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/sys:/sys:ro</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/lib/docker/:/var/lib/docker:ro</span>  <span class="hljs-attr">grafana:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">grafana/grafana:8.5.2</span>    <span class="hljs-attr">user:</span> <span class="hljs-string">&#x27;104&#x27;</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">links:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">influxdb:influxsrv</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000:3000&quot;</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">grafana_data:/var/lib/grafana</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">HTTP_USER=admin</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">HTTP_PASS=admin</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">INFLUXDB_HOST=influxsrv</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">INFLUXDB_PORT=8086</span></code></pre><ol start="2"><li>检查语法</li></ol><pre><code class="hljs shell">docker compose config -q</code></pre><ol start="3"><li>执行yml</li></ol><pre><code class="hljs shell">docker compose up -d</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/tmfl/cloud&quot;&gt;Docker笔记&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;MySQL主从复制&quot;&gt;&lt;a href=&quot;#MySQL主从复制&quot; class=&quot;headerlink&quot; title=&quot;MySQL主从复制&quot;&gt;</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://example.com/2022/11/15/Docker/"/>
    <id>http://example.com/2022/11/15/Docker/</id>
    <published>2022-11-15T02:30:20.000Z</published>
    <updated>2024-03-12T09:43:38.992Z</updated>
    
    <content type="html"><![CDATA[<h5 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h5><p>firewall-cmd –zone&#x3D;public –add-port&#x3D;2181&#x2F;tcp –permanent</p><p>编码开发微服务<br>上线部署容器化<br>时时刻刻要监控</p><p><img src="/%5Cimage%5CSnipaste_2023-10-28_16-17-45.png"></p><p>Docker基于Go语言实现  </p><p>Docker的主要目标是：<code>Build, Ship and Run Any App, Anywhere</code>，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到<strong>一次镜像,处处运行</strong>。</p><blockquote><p>将源码 + 配置 + 环境 + 版本打包成为一个镜像文件</p><p>docker: DevOps</p></blockquote><h3 id="传统虚拟机和容器"><a href="#传统虚拟机和容器" class="headerlink" title="传统虚拟机和容器"></a>传统虚拟机和容器</h3><p>传统虚拟机</p><ul><li>虚拟机主要是虚拟出各种硬件 在虚拟机上面安装操作系统，在操作系统中安装各种应用</li><li>占用资源多，启动慢</li></ul><p>容器</p><ul><li>容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</li><li>容器不是模拟一个完整的操作系统，而是对进程进行隔离</li><li>容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行。</li></ul><pre><code class="hljs plaintext">yum config-manager--add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><h3 id="Docker运行快的原因："><a href="#Docker运行快的原因：" class="headerlink" title="Docker运行快的原因："></a>Docker运行快的原因：</h3><ol><li>Docker有比虚拟机更少的抽象层：<ul><li>Docker不需要Hypervisor（虚拟机）实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源</li></ul></li><li>Docker利用的是宿主机的内核，而不需要加载操作系统OS内核</li><li>Docker容器的本质就是一个进程</li></ol><h3 id="Docker的基本组成部分："><a href="#Docker的基本组成部分：" class="headerlink" title="Docker的基本组成部分："></a>Docker的基本组成部分：</h3><ul><li><p>镜像（image)</p><ul><li>Docker镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建多个容器。</li></ul></li><li><p>容器（container）</p><ul><li>容器就类似于一个虚拟化的运行环境，<strong>容器是用镜像创建的运行实例</strong></li></ul></li><li><p>仓库（repository）</p><ul><li>集中存放镜像文件的场所。</li></ul></li></ul><h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p>Docker是一个 C&#x2F;S（Client-Server） 结构的系统，后端是一个松耦合架构，众多模块各司其职。</p><p><img src="/%5Cimage%5CSnipaste_2023-10-25_20-21-29.png"></p><p>Docker运行的基本流程为:</p><ol><li>用户是使用Docker Client 与 Docker Daemon 建立通信，并发送请求给后者</li><li>Docker Daemon 作为 Docker 架构的主体部分，首先提供 Docker Server 的功能使其可以接收 Docker Client 的请求</li><li>Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式存在</li><li>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph Driver 将下载镜像以 Graph 的形式存储</li><li>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境</li><li>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成</li><li>Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作</li></ol><blockquote><p>每个容器就是一个job</p></blockquote><p><img src="/%5Cimage%5CSnipaste_2023-10-25_20-27-59.png"></p><h3 id="Docker指令"><a href="#Docker指令" class="headerlink" title="Docker指令"></a>Docker指令</h3><p>docker指令 中 一般是两道杠 一到杠是简写</p><p>单个字母是一个杠，否则两个杠</p><pre><code class="hljs shell">systemctl start docker   docker启动systemctl stop docker    停止Dockersystemctl restart docker  重启Dockersystemctl status docke    查看状态systemctl enable docker   设置开机自启</code></pre><p>帮助类命令</p><pre><code class="hljs shell">docker version      查看Docker版本docker info         查看Docker概要信息docker --help       查看Docker总体帮助文档docker 具体命令 --help   查看docker具体命令帮助文档</code></pre><p>镜像命令</p><pre><code class="hljs shell">docker images          列出本地主机上的镜像● -a：列出所有镜像（含历史镜像）● -q：只显示镜像ID● -f：过滤docker search 镜像名称     在远程仓库中搜索镜像● -f：过滤● --limit 数量：只展示前几项docker pull 镜像名称[:tag]   下载镜像    不加 tag 时，默认下载最新的镜像（即tag为latest）。● docker pull redis:6.0.3  下载 redis 6.0.3版本docker system df     查看镜像/容器/数据卷所占的空间docker rmi -f 镜像名称/ID  删除镜像可以使用空格分隔，删除多个镜像：docker rmi 镜像1 镜像2 镜像3删除全部镜像：docker rmi -f $(docker images -qa)</code></pre><blockquote><p>“docker search” requires exactly 1 argument.</p><p>出错原因是命令最后需要****一个空格和一个点****，即：</p></blockquote><h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>仓库名、标签都是<code>&lt;none&gt;</code>的镜像，俗称虚悬镜像（dangling image）。</p><p><img src="/%5Cimage%5CSnipaste_2023-10-26_16-34-36.png"></p><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p><strong>新建启动容器</strong></p><pre><code class="hljs shell">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre><p>常用的参数：</p><ul><li><p><code>--name</code>：为容器指定一个名称</p></li><li><p><code>-d</code>：后台运行容器并返回容器ID，也即启动守护式容器    （后台运行）</p><blockquote><p>Docker容器后台运行，必须由一个前台进程</p><ul><li>如果不是前台进程 使用-d 该docker会自动关闭 例如 ubuntu使用-d会自动关闭，使用redis就不会 会在前台进行端口监听 使用-d不会自动关闭</li></ul><p>容器运行的命令如果不是那些一致挂起的命令（top tail），就是会自动退出</p><p>最佳的解决方案是 将要运行到的程序以前台进程的形式运行，就是命令行形式  -it</p></blockquote></li><li><p><code>-i</code>：以交互模式（interactive）运行容器，通常与<code>-t</code>同时使用  （在前台运行）</p></li><li><p><code>-t</code>：为容器重新分配一个伪输入终端（tty），通常与<code>-i</code>同时使用。也即启动交互式容器（前台有伪终端，等待交互）</p></li><li><p><code>-e</code>：为容器添加环境变量</p></li><li><p><code>-P</code>：大P 随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口</p></li><li><p><code>-p</code>：小p 指定端口映射</p></li></ul><p>以交互方式启动ubuntu镜像</p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-i 交互模式</span><span class="hljs-meta prompt_"># </span><span class="language-bash">-t 分配一个伪输入终端<span class="hljs-built_in">tty</span></span><span class="hljs-meta prompt_"># </span><span class="language-bash">ubuntu 镜像名称</span><span class="hljs-meta prompt_"># </span><span class="language-bash">/bin/bash（或者bash） shell交互的接口</span>docker run -it ubuntu /bin/bashdocker run --name hcjDocker -it ubuntu bash</code></pre><p>退出交互模式：</p><p>方式1：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在交互shell中<span class="hljs-built_in">exit</span>即可退回宿主机</span>exit;</code></pre><p>方式2：</p><p>使用快捷键<code>ctrl</code> + <code>P</code> + <code>Q</code></p><p>方式1 退出后，容器会停止；</p><p>方式2 退出后容器依然正在运行。</p><p><strong>列出正在运行的容器</strong></p><pre><code class="hljs shell">docker ps [OPTIONS]</code></pre><p>常用参数：</p><ul><li><p><code>-a</code>：列出当前所有正在运行的容器+历史上运行过的容器</p></li><li><p><code>-l</code>：显示最近创建的容器</p></li><li><p><code>-n</code>：显示最近n个创建的容器</p></li><li><p><code>-q</code>：静默模式，只显示容器编号</p></li></ul><p><strong>启动已经停止的容器</strong></p><pre><code class="hljs shell">docker start 容器ID或容器名</code></pre><p><strong>重启容器</strong></p><pre><code class="hljs shell">docker restart 容器ID或容器名</code></pre><p><strong>停止容器</strong></p><pre><code class="hljs shell">docker stop 容器ID或容器名</code></pre><p><strong>强制停止容器</strong></p><pre><code class="hljs shell">docker kill 容器ID或容器名</code></pre><p><strong>删除已经停止的容器</strong>：</p><pre><code class="hljs shell">docker rm 容器ID或容器名</code></pre><blockquote><p>删除容器是 <code>docker rm</code>，删除镜像是 <code>docker rmi</code>，注意区分。</p></blockquote><p><strong>强制删除正在运行的容器</strong></p><pre><code class="hljs shell">docker rm -f 容器ID或容器名</code></pre><p><strong>一次删除多个容器实例</strong>：</p><pre><code class="hljs shell">docker rm -f $(docker ps -a  -q)<span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span>docker ps -a -q | xargs docker rm</code></pre><p><strong>查看容器日志</strong></p><pre><code class="hljs shell">docker logs 容器ID或容器名</code></pre><p><strong>查看容器内的进程</strong></p><pre><code class="hljs shell">docker top 容器ID或容器名</code></pre><p><strong>查看容器内部运行情况</strong></p><pre><code class="hljs shell">docker inspect 容器ID或容器名</code></pre><p><strong>进去正在运行的容器并以命令行交互</strong>   推荐使用</p><pre><code class="hljs shell">docker exec -it 容器ID bashShell</code></pre><blockquote><p>就是使用-it启动一个伪终端之后立即执行的一个命令,&#x2F;bin&#x2F;bash表示你在容器使用bash类型的shell进行交互</p><p>Ctrl + p + q 后台运行容器，但是当你在使用 run 是重新创建一个新的容器，而 exec 是进入之前创建的容器</p></blockquote><p><img src="/%5Cimage%5CSnipaste_2023-10-28_16-25-27.png"></p><p><strong>重新进入容器</strong></p><pre><code class="hljs shell">docker attach 容器ID</code></pre><ul><li>attach直接进入容器启动命令的终端，不会启动新的进程     用exit退出，会导致容器的停止。</li><li>exec是在容器中打开新的终端，并且可以启动新的进程      用exit退出，不会导致容器的停止。</li></ul><p><strong>从容器内部拷贝文件到主机上</strong></p><pre><code class="hljs shell">docker cp 容器ID：容器内路径 目的主机路径</code></pre><p><strong>导入和导出容器</strong></p><p>export 导出容器的内容流作为一个tar归档文件[对应import命令]<br>import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]</p><pre><code class="hljs shell">docker export  容器ID&gt;文件名tarcat 文件名.tar | docker import -镜像用户/镜像名：镜像版本号</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-10-28_17-14-08.png"></p><p><img src="/%5Cimage%5CSnipaste_2023-10-28_17-21-05.png"></p><p>利用tar包生成的镜像文件 镜像文件生成的容器和原来删除的容器一样</p><blockquote><p><img src="/%5Cimage%5CSnipaste_2023-10-28_17-23-23.png"></p></blockquote><p><strong>所有命令示意图</strong></p><p><img src="/"><img src="/%5Cimage%5CSnipaste_2023-10-28_17-25-10.png" alt="Snipaste_2023-10-28_17-25-10"></p><h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><p>镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好行程一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是image镜像文件。</p><h4 id="Docker-镜像加载原理"><a href="#Docker-镜像加载原理" class="headerlink" title="Docker 镜像加载原理"></a>Docker 镜像加载原理</h4><p><strong>UnionFS（联合文件系统）</strong>：Union文件系统（UnionFS）是一种<strong>分层、轻量级并且高性能的（支持聚合）文件系统</strong>，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各利具体的应用镜像</p><blockquote><p>它是在不修改其原始（物理）源的情况下创建将多个目录的内容合并为一个逻辑目录。更有创意的用法是：能将相关的文件集存储在<a href="https://so.csdn.net/so/search?q=%E4%B8%8D%E5%90%8C%E7%9A%84&spm=1001.2101.3001.7020">不同的</a>磁盘或媒体中，但我们在单个视图中显示它们。总之，将多个、种类不同的数据源整合成一个逻辑数据源是有意义的。</p></blockquote><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Un0ⅸ.系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由pootfs转交给内核，此.时系统也会卸载pootfs。</p><p>rootfs（root file system），在pootfs之上。包含的就是典型Linux系统中的&#x2F;dev，proc，bin，&#x2F;etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如ubuntu，Centos等等。</p><p><strong>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</strong></p><p>比如说有多个镜像都从相同的base镜像构建而来，那么Docker Host只需在磁盘上保存一份base镜像；同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><p><strong>Docker镜像层都是只读的，容器层是可写的</strong></p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>所有对容器的改动:无论添加、删除、还是修改文件都只发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p><p><img src="/%5Cimage%5CSnipaste_2023-10-30_20-28-32.png"></p><p><strong>Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。</strong></p><p><strong>新镜像是从base镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</strong></p><img src="\image\Snipaste_2023-10-30_20-55-18.png" style="zoom:50%;" /><h4 id="创建自己镜像-并且发布"><a href="#创建自己镜像-并且发布" class="headerlink" title="创建自己镜像 并且发布"></a>创建自己镜像 并且发布</h4><p><img src="/%5Cimage%5CSnipaste_2023-11-02_14-19-00.png"></p><h5 id="发布到公有镜像"><a href="#发布到公有镜像" class="headerlink" title="发布到公有镜像"></a>发布到公有镜像</h5><p>eg: 创建由vim的ubuntu镜像</p><ol><li>下载vim</li></ol><pre><code class="hljs shell">apt-get updateapt-get -y install vim</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-10-30_20-42-32.png"></p><p>2.使用 commit命令</p><pre><code class="hljs shell">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名：[标签名]</code></pre><blockquote><p> import导入的镜像只保留文件，像redis里面的东西是没有的，commmit提交时是包含所有内容的，导入时也包含所有内容，有文件和redis内部数据等。。</p></blockquote><p><img src="/%5Cimage%5CSnipaste_2023-10-30_20-48-01.png"></p><ol start="3"><li>和原镜像比较</li></ol><p><img src="/%5Cimage%5CSnipaste_2023-10-30_20-53-30.png"></p><p>完全一样</p><ol start="4"><li><p>发布到aliyun镜像</p><ul><li><p>登录到aliyun官网 进入 容器镜像服务</p></li><li><p>创建镜像仓库,先创建命名空间 再创建镜像仓库</p></li><li><p>将镜像推送到阿里云</p><ul><li><p><a href="https://cr.console.aliyun.com/repository/cn-beijing/nuc_hcjdocker/test/details">容器镜像服务 (aliyun.com)</a></p></li><li><p><img src="/%5Cimage%5CSnipaste_2023-11-02_13-55-15.png"></p></li><li><p><img src="/%5Cimage%5CSnipaste_2023-11-02_14-12-58.png"></p></li><li><p>从仓库中拉取镜像</p><p><img src="/%5Cimage%5CSnipaste_2023-11-02_14-14-57.png"></p></li></ul></li></ul></li></ol><h5 id="发布到私有镜像"><a href="#发布到私有镜像" class="headerlink" title="发布到私有镜像"></a>发布到私有镜像</h5><p>Docker Registry是官方提供的工具，用于构建私有的镜像仓库</p><blockquote><p>创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。</p><p>放在公共镜像的docker 有秘密被泄露的风险</p></blockquote><ol><li><p>下载镜像 registry 用于搭建 docker仓库私服版本</p><p><img src="/%5Cimage%5CSnipaste_2023-11-02_14-29-04.png"></p></li><li><p>运行私有库Registry，相当于本地有个私有Docker hub</p><ul><li><pre><code class="shell">docker run -d -p 5000:5000 -v /zzyyuse/myregistry/:/tmp/registry --privileged=true registry<pre><code class="hljs plaintext">   + 3. commit 新镜像4. 将新镜像修改符合私服规范的Tag   ![](\image\Snipaste_2023-11-02_14-43-15.png)5. 修改配置文件 使之支持http   ```shell   vim /etc/docker/daemon.json</code></pre></code></pre></li></ul><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;https://z3o7c80u.mirror.aliyuncs.com&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;insecure-registries&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;192.168.70.138:5000&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></li><li><p>push推送到私有仓库</p><ul><li><pre><code class="shell">docker push 192.168.111.167:5000/zzyyubuntu:1.2<pre><code class="hljs plaintext">7. pull到本地并运行   ```shell   docker pull 192.168.111.167:5000/zyyubuntu:1.2</code></pre></code></pre></li></ul></li></ol><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><blockquote><pre><code class="hljs shell">docker run -it -v /DockerRegistry/hcjHostData:/tmp/DockerData --privileged=true ubuntu</code></pre><p>容器卷记得加入   –privileged&#x3D;true</p><p>Docker挂载主机目录访问如果出现cannot open directory.：Permission denied<br>解决办法：在挂载目录后多加一个-privileged&#x3D;-true参数即可</p><p>-v </p><p>Docker容器启动的时候，如果要挂载宿主机的一个目录，可以用-v参数指定</p><p>-v参数中，冒号”:”前面的目录是宿主机目录，后面的目录是容器内目录。</p><p>目录是自动创建</p><p><img src="/%5Cimage%5CSnipaste_2023-11-02_15-23-43.png"></p></blockquote><p><img src="/%5Cimage%5CSnipaste_2023-11-02_15-16-04.png"></p><p>容器卷类似于redis中的rdb和aof</p><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是<strong>数据的持久化</strong>，完全<strong>独立于容器的生存周期</strong>，因此Docker不会在容器删除时删除其挂载的数据卷</p><p>将运用与运行的环境打包镜像，run后形成容器实例运行，但是我们对数据的要求希望是持久化的</p><p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。<br>为了能保存数据在docker中我们使用卷。</p><p>特点：<br>1：数据卷可在容器之间共享或重用数据<br>2：卷中的更改可以直接<strong>实时生效</strong><br>3：数据卷中的更改不会包含在镜像的更新中<br>4：数据卷的生命周期一直持续到没有容器使用它为止</p><p>相当于 虚拟机和主机的共享文件夹 里面的内容是实时共享的</p><p><strong>开启docker容器持久化</strong> （容器和宿主机之间的映射）</p><p><code>docker run -it -privileged=true -v/宿主机绝对路径目录:/容器内日录:ro 镜像名</code></p><pre><code class="hljs shell">docker run -it -v /DockerRegistry/hcjHostData:/tmp/DockerData --privileged=true ubuntu<span class="hljs-meta prompt_">#</span><span class="language-bash">读写规则 默认支持可读可写 rw   相当于</span> docker run -it -v /DockerRegistry/hcjHostData:/tmp/DockerData:rw --privileged=true ubuntu<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">#</span><span class="language-bash">读写规则 只能读   容器内实例被限制，只能读，不能写   宿主机可以读可以写 写的内容可以同步到容器中让其读取到</span>docker run -it -v /DockerRegistry/hcjHostData:/tmp/DockerData:ro --privileged=true ubuntu</code></pre><p><strong>查看数据卷是否挂载成功</strong></p><pre><code class="hljs shell">docker inspect imageId</code></pre><p><img src="/%5Cimage%5CSnipaste_2023-11-02_15-45-20.png"></p><p><strong>容器卷之间的继承</strong></p><pre><code class="hljs shell">docker run -it --privileged=true --volumes-from 父镜像 --name u2 ubuntu</code></pre><p>继承会直接拥有父类容器的映射地址 不能再另外指定映射地址 ，父类创建新文件 子类和宿主机之间也会拥有该文件(子类容器创建文件同理、宿主机创建文件同理)，同时新创建的子类容器会拥有父类的映射地址中原有的文件。</p><blockquote><p><code>在容器的继承中 继承的是规则 不是容器本身 ，所以父容器关闭 不影响子容器于宿主机的消息传递</code></p></blockquote><h3 id="docker-安装tomcat"><a href="#docker-安装tomcat" class="headerlink" title="docker 安装tomcat"></a>docker 安装tomcat</h3><ol><li>拉取镜像</li></ol><pre><code class="hljs shell">docker pull tomcat</code></pre><ol start="2"><li>运行镜像</li></ol><pre><code class="hljs shell">docker run -d -p 8088:8080 --name hcjTomcat tomcat</code></pre><ol start="3"><li>新版的tomcat需要将 webapp.dist 变为 webapp 将原来的webapp删除</li><li>访问tomcat集合成功</li></ol><h3 id="docker-安装-mysql8-0"><a href="#docker-安装-mysql8-0" class="headerlink" title="docker 安装 mysql8.0"></a>docker 安装 mysql8.0</h3><ol><li>拉取镜像</li></ol><pre><code class="hljs shell">docker pull mysql:8.0.21</code></pre><ol start="2"><li>运行镜像</li></ol><pre><code class="hljs shell">docker run --name hcjMysql -v /usr/local/app/mysql/logs:/var/log/mysql -v /usr/local/app/mysql/data:/var/lib/mysql -v /usr/local/app/mysql/conf:/etc/mysql/conf.d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0.21<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">已开启数量卷备份   备份了数据  日志  配置</span></code></pre><p><strong>远程连接</strong><br><a href="https://blog.csdn.net/weixin_49343190/article/details/118511564">Docker 安装 MySQL 8.0，详细步骤_docker安装mysql8.0-CSDN博客</a></p><p>问题 中文乱码   数据备份</p><p><strong>修改中文乱码</strong></p><p>在 &#x2F;usr&#x2F;local&#x2F;app&#x2F;mysql&#x2F;conf 目录创建 my.cnf</p><p>在文件中添加</p><pre><code class="hljs conf">[client]default_character_set=utf8[mysqld]collation_server=utf8_general_cicharacter_set_server=utf8</code></pre><h3 id="docker-安装-redis"><a href="#docker-安装-redis" class="headerlink" title="docker 安装 redis"></a>docker 安装 redis</h3><p>在pull下redis镜像后</p><p>需要设置数据卷区域 进行持久化操作 并且需要修改配置文件</p><ol><li><p>修改配置文件</p><pre><code class="hljs java"><span class="hljs-number">1.</span> 将bind <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> 注释掉 确保能够进行远程连接<span class="hljs-number">2.</span> 将daemonize 设置为 no  将daemonize yes 注释起来或者daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败<span class="hljs-number">3.</span>开启redis持久化appendonly yes</code></pre></li></ol><p>启动redis容器</p><pre><code class="hljs shell">docker run -p 6378:6379 --name hcjRedis --privileged=true -v /DockerRegistry/redis/redis.conf:/etc/redis/redis.conf -v /DockerRegistry/redis/data:/data  -d redis:6.0.8 redis-server /etc/redis/redis.conf</code></pre><p>redis<strong>没有密码无法远程连接</strong></p><h3 id="docker-安装-rabbitMq"><a href="#docker-安装-rabbitMq" class="headerlink" title="docker 安装 rabbitMq"></a>docker 安装 rabbitMq</h3><pre><code class="hljs shell">docker volume create rabbitmq-homedocker run -id --name=rabbitmq -v rabbitmq-home:/var/lib/rabbitmq -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=swsk33 -e RABBITMQ_DEFAULT_PASS=123456 rabbitmq:management</code></pre><p>注意docker空间 <strong>空间不足服务无法启动</strong></p><p><a href="https://zhuanlan.zhihu.com/p/497785315">记rabbitmq登录web管理页面，不是私密连接问题 - 知乎 (zhihu.com)</a></p><h3 id="docker-创建zookeeper"><a href="#docker-创建zookeeper" class="headerlink" title="docker 创建zookeeper"></a>docker 创建zookeeper</h3><pre><code class="hljs shell">docker run -d --name zookeeper --privileged=true -p 2181:2181   -v /DockerRegistry/zookeeper/conf:/conf  --restart always  zookeeperdocker run -d --name zookeeper  -p 2181:2181     --restart always  zookeeper<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">开启zookeeper</span>docker run -it --rm --link zookeeper:zookeeper zookeeper zkServer.sh -server zookeeper</code></pre><ol><li><em>docker run -d -p 2181:2181 –name some-zookeeper –restart always 0e256393bf7e</em></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;开启端口&quot;&gt;&lt;a href=&quot;#开启端口&quot; class=&quot;headerlink&quot; title=&quot;开启端口&quot;&gt;&lt;/a&gt;开启端口&lt;/h5&gt;&lt;p&gt;firewall-cmd –zone&amp;#x3D;public –add-port&amp;#x3D;2181&amp;#x2F;tcp –p</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
</feed>
